!(function (t) {
  var e = {};
  function n(i) {
    if (e[i]) return e[i].exports;
    var r = (e[i] = {
      i: i,
      l: !1,
      exports: {},
    });
    return t[i].call(r.exports, r, r.exports, n), (r.l = !0), r.exports;
  }
  (n.m = t),
    (n.c = e),
    (n.d = function (t, e, i) {
      n.o(t, e) ||
        Object.defineProperty(t, e, {
          enumerable: !0,
          get: i,
        });
    }),
    (n.r = function (t) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, {
          value: "Module",
        }),
        Object.defineProperty(t, "__esModule", {
          value: !0,
        });
    }),
    (n.t = function (t, e) {
      if ((1 & e && (t = n(t)), 8 & e)) return t;
      if (4 & e && "object" == typeof t && t && t.__esModule) return t;
      var i = Object.create(null);
      if (
        (n.r(i),
        Object.defineProperty(i, "default", {
          enumerable: !0,
          value: t,
        }),
        2 & e && "string" != typeof t)
      )
        for (var r in t)
          n.d(
            i,
            r,
            function (e) {
              return t[e];
            }.bind(null, r)
          );
      return i;
    }),
    (n.n = function (t) {
      var e =
        t && t.__esModule
          ? function () {
              return t.default;
            }
          : function () {
              return t;
            };
      return n.d(e, "a", e), e;
    }),
    (n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }),
    (n.p = "/assets/js/"),
    n((n.s = 137));
})([
  function (t, e, n) {
    var i = n(32),
      r = Function.prototype,
      s = r.call,
      o = i && r.bind.bind(s, s);
    t.exports = i
      ? o
      : function (t) {
          return function () {
            return s.apply(t, arguments);
          };
        };
  },
  function (t, e, n) {
    var i = n(61),
      r = i.all;
    t.exports = i.IS_HTMLDDA
      ? function (t) {
          return "function" == typeof t || t === r;
        }
      : function (t) {
          return "function" == typeof t;
        };
  },
  function (t, e) {
    t.exports = function (t) {
      try {
        return !!t();
      } catch (t) {
        return !0;
      }
    };
  },
  function (t, e, n) {
    var i = n(1),
      r = n(61),
      s = r.all;
    t.exports = r.IS_HTMLDDA
      ? function (t) {
          return "object" == typeof t ? null !== t : i(t) || t === s;
        }
      : function (t) {
          return "object" == typeof t ? null !== t : i(t);
        };
  },
  function (t, e, n) {
    var i = n(5),
      r = n(58),
      s = n(7),
      o = n(36),
      a = n(59),
      l = n(60),
      c = i.Symbol,
      u = r("wks"),
      h = l ? c.for || c : (c && c.withoutSetter) || o;
    t.exports = function (t) {
      return s(u, t) || (u[t] = a && s(c, t) ? c[t] : h("Symbol." + t)), u[t];
    };
  },
  function (t, e, n) {
    (function (e) {
      var n = function (t) {
        return t && t.Math == Math && t;
      };
      t.exports =
        n("object" == typeof globalThis && globalThis) ||
        n("object" == typeof window && window) ||
        n("object" == typeof self && self) ||
        n("object" == typeof e && e) ||
        (function () {
          return this;
        })() ||
        Function("return this")();
    }).call(this, n(57));
  },
  function (t, e, n) {
    var i = n(2);
    t.exports = !i(function () {
      return (
        7 !=
        Object.defineProperty({}, 1, {
          get: function () {
            return 7;
          },
        })[1]
      );
    });
  },
  function (t, e, n) {
    var i = n(0),
      r = n(16),
      s = i({}.hasOwnProperty);
    t.exports =
      Object.hasOwn ||
      function (t, e) {
        return s(r(t), e);
      };
  },
  function (t, e, n) {
    var i = n(3),
      r = String,
      s = TypeError;
    t.exports = function (t) {
      if (i(t)) return t;
      throw s(r(t) + " is not an object");
    };
  },
  function (t, e, n) {
    var i = n(6),
      r = n(63),
      s = n(62),
      o = n(8),
      a = n(37),
      l = TypeError,
      c = Object.defineProperty,
      u = Object.getOwnPropertyDescriptor;
    e.f = i
      ? s
        ? function (t, e, n) {
            if (
              (o(t),
              (e = a(e)),
              o(n),
              "function" == typeof t &&
                "prototype" === e &&
                "value" in n &&
                "writable" in n &&
                !n.writable)
            ) {
              var i = u(t, e);
              i &&
                i.writable &&
                ((t[e] = n.value),
                (n = {
                  configurable:
                    "configurable" in n ? n.configurable : i.configurable,
                  enumerable: "enumerable" in n ? n.enumerable : i.enumerable,
                  writable: !1,
                }));
            }
            return c(t, e, n);
          }
        : c
      : function (t, e, n) {
          if ((o(t), (e = a(e)), o(n), r))
            try {
              return c(t, e, n);
            } catch (t) {}
          if ("get" in n || "set" in n) throw l("Accessors not supported");
          return "value" in n && (t[e] = n.value), t;
        };
  },
  function (t, e, n) {
    var i = n(32),
      r = Function.prototype.call;
    t.exports = i
      ? r.bind(r)
      : function () {
          return r.apply(r, arguments);
        };
  },
  function (t, e, n) {
    var i = n(31),
      r = n(33);
    t.exports = function (t) {
      return i(r(t));
    };
  },
  function (t, e, n) {
    var i = n(0),
      r = i({}.toString),
      s = i("".slice);
    t.exports = function (t) {
      return s(r(t), 8, -1);
    };
  },
  function (t, e) {
    t.exports = function (t) {
      return null == t;
    };
  },
  function (t, e, n) {
    var i,
      r,
      s,
      o = n(69),
      a = n(5),
      l = n(3),
      c = n(44),
      u = n(7),
      h = n(34),
      d = n(43),
      p = n(25),
      f = a.TypeError,
      m = a.WeakMap;
    if (o || h.state) {
      var g = h.state || (h.state = new m());
      (g.get = g.get),
        (g.has = g.has),
        (g.set = g.set),
        (i = function (t, e) {
          if (g.has(t)) throw f("Object already initialized");
          return (e.facade = t), g.set(t, e), e;
        }),
        (r = function (t) {
          return g.get(t) || {};
        }),
        (s = function (t) {
          return g.has(t);
        });
    } else {
      var v = d("state");
      (p[v] = !0),
        (i = function (t, e) {
          if (u(t, v)) throw f("Object already initialized");
          return (e.facade = t), c(t, v, e), e;
        }),
        (r = function (t) {
          return u(t, v) ? t[v] : {};
        }),
        (s = function (t) {
          return u(t, v);
        });
    }
    t.exports = {
      set: i,
      get: r,
      has: s,
      enforce: function (t) {
        return s(t) ? r(t) : i(t, {});
      },
      getterFor: function (t) {
        return function (e) {
          var n;
          if (!l(e) || (n = r(e)).type !== t)
            throw f("Incompatible receiver, " + t + " required");
          return n;
        };
      },
    };
  },
  function (t, e, n) {
    var i = n(1),
      r = n(9),
      s = n(72),
      o = n(35);
    t.exports = function (t, e, n, a) {
      a || (a = {});
      var l = a.enumerable,
        c = void 0 !== a.name ? a.name : e;
      if ((i(n) && s(n, c, a), a.global)) l ? (t[e] = n) : o(e, n);
      else {
        try {
          a.unsafe ? t[e] && (l = !0) : delete t[e];
        } catch (t) {}
        l
          ? (t[e] = n)
          : r.f(t, e, {
              value: n,
              enumerable: !1,
              configurable: !a.nonConfigurable,
              writable: !a.nonWritable,
            });
      }
      return t;
    };
  },
  function (t, e, n) {
    var i = n(33),
      r = Object;
    t.exports = function (t) {
      return r(i(t));
    };
  },
  function (t, e, n) {
    var i = n(5),
      r = n(1),
      s = function (t) {
        return r(t) ? t : void 0;
      };
    t.exports = function (t, e) {
      return arguments.length < 2 ? s(i[t]) : i[t] && i[t][e];
    };
  },
  function (t, e, n) {
    var i = n(100);
    t.exports = function (t) {
      return i(t.length);
    };
  },
  function (t, e) {
    t.exports = {};
  },
  function (t, e, n) {
    var i = n(5),
      r = n(70).f,
      s = n(44),
      o = n(15),
      a = n(35),
      l = n(102),
      c = n(76);
    t.exports = function (t, e) {
      var n,
        u,
        h,
        d,
        p,
        f = t.target,
        m = t.global,
        g = t.stat;
      if ((n = m ? i : g ? i[f] || a(f, {}) : (i[f] || {}).prototype))
        for (u in e) {
          if (
            ((d = e[u]),
            (h = t.dontCallGetSet ? (p = r(n, u)) && p.value : n[u]),
            !c(m ? u : f + (g ? "." : "#") + u, t.forced) && void 0 !== h)
          ) {
            if (typeof d == typeof h) continue;
            l(d, h);
          }
          (t.sham || (h && h.sham)) && s(d, "sham", !0), o(n, u, d, t);
        }
    };
  },
  function (t, e, n) {
    var i = n(5);
    t.exports = i;
  },
  function (t, e) {
    t.exports = !1;
  },
  function (t, e, n) {
    var i,
      r = n(8),
      s = n(95),
      o = n(42),
      a = n(25),
      l = n(101),
      c = n(64),
      u = n(43),
      h = u("IE_PROTO"),
      d = function () {},
      p = function (t) {
        return "<script>" + t + "</script>";
      },
      f = function (t) {
        t.write(p("")), t.close();
        var e = t.parentWindow.Object;
        return (t = null), e;
      },
      m = function () {
        try {
          i = new ActiveXObject("htmlfile");
        } catch (t) {}
        var t, e;
        m =
          "undefined" != typeof document
            ? document.domain && i
              ? f(i)
              : (((e = c("iframe")).style.display = "none"),
                l.appendChild(e),
                (e.src = String("javascript:")),
                (t = e.contentWindow.document).open(),
                t.write(p("document.F=Object")),
                t.close(),
                t.F)
            : f(i);
        for (var n = o.length; n--; ) delete m.prototype[o[n]];
        return m();
      };
    (a[h] = !0),
      (t.exports =
        Object.create ||
        function (t, e) {
          var n;
          return (
            null !== t
              ? ((d.prototype = r(t)),
                (n = new d()),
                (d.prototype = null),
                (n[h] = t))
              : (n = m()),
            void 0 === e ? n : s.f(n, e)
          );
        });
  },
  function (t, e, n) {
    var i = n(1),
      r = n(40),
      s = TypeError;
    t.exports = function (t) {
      if (i(t)) return t;
      throw s(r(t) + " is not a function");
    };
  },
  function (t, e) {
    t.exports = {};
  },
  function (t, e) {
    t.exports = function (t, e) {
      return {
        enumerable: !(1 & t),
        configurable: !(2 & t),
        writable: !(4 & t),
        value: e,
      };
    };
  },
  function (t, e, n) {
    var i = n(20),
      r = n(0),
      s = n(25),
      o = n(3),
      a = n(7),
      l = n(9).f,
      c = n(46),
      u = n(110),
      h = n(112),
      d = n(36),
      p = n(81),
      f = !1,
      m = d("meta"),
      g = 0,
      v = function (t) {
        l(t, m, {
          value: {
            objectID: "O" + g++,
            weakData: {},
          },
        });
      },
      _ = (t.exports = {
        enable: function () {
          (_.enable = function () {}), (f = !0);
          var t = c.f,
            e = r([].splice),
            n = {};
          (n[m] = 1),
            t(n).length &&
              ((c.f = function (n) {
                for (var i = t(n), r = 0, s = i.length; r < s; r++)
                  if (i[r] === m) {
                    e(i, r, 1);
                    break;
                  }
                return i;
              }),
              i(
                {
                  target: "Object",
                  stat: !0,
                  forced: !0,
                },
                {
                  getOwnPropertyNames: u.f,
                }
              ));
        },
        fastKey: function (t, e) {
          if (!o(t))
            return "symbol" == typeof t
              ? t
              : ("string" == typeof t ? "S" : "P") + t;
          if (!a(t, m)) {
            if (!h(t)) return "F";
            if (!e) return "E";
            v(t);
          }
          return t[m].objectID;
        },
        getWeakData: function (t, e) {
          if (!a(t, m)) {
            if (!h(t)) return !0;
            if (!e) return !1;
            v(t);
          }
          return t[m].weakData;
        },
        onFreeze: function (t) {
          return p && f && h(t) && !a(t, m) && v(t), t;
        },
      });
    s[m] = !0;
  },
  function (t, e, n) {
    var i = n(114),
      r = n(24),
      s = n(32),
      o = i(i.bind);
    t.exports = function (t, e) {
      return (
        r(t),
        void 0 === e
          ? t
          : s
          ? o(t, e)
          : function () {
              return t.apply(e, arguments);
            }
      );
    };
  },
  function (t, e, n) {
    var i = n(52),
      r = n(1),
      s = n(12),
      o = n(4)("toStringTag"),
      a = Object,
      l =
        "Arguments" ==
        s(
          (function () {
            return arguments;
          })()
        );
    t.exports = i
      ? s
      : function (t) {
          var e, n, i;
          return void 0 === t
            ? "Undefined"
            : null === t
            ? "Null"
            : "string" ==
              typeof (n = (function (t, e) {
                try {
                  return t[e];
                } catch (t) {}
              })((e = a(t)), o))
            ? n
            : l
            ? s(e)
            : "Object" == (i = s(e)) && r(e.callee)
            ? "Arguments"
            : i;
        };
  },
  function (t, e, n) {
    "use strict";
    var i = n(11),
      r = n(92),
      s = n(19),
      o = n(14),
      a = n(9).f,
      l = n(45),
      c = n(48),
      u = n(22),
      h = n(6),
      d = o.set,
      p = o.getterFor("Array Iterator");
    t.exports = l(
      Array,
      "Array",
      function (t, e) {
        d(this, {
          type: "Array Iterator",
          target: i(t),
          index: 0,
          kind: e,
        });
      },
      function () {
        var t = p(this),
          e = t.target,
          n = t.kind,
          i = t.index++;
        return !e || i >= e.length
          ? ((t.target = void 0), c(void 0, !0))
          : c("keys" == n ? i : "values" == n ? e[i] : [i, e[i]], !1);
      },
      "values"
    );
    var f = (s.Arguments = s.Array);
    if ((r("keys"), r("values"), r("entries"), !u && h && "values" !== f.name))
      try {
        a(f, "name", {
          value: "values",
        });
      } catch (t) {}
  },
  function (t, e, n) {
    var i = n(0),
      r = n(2),
      s = n(12),
      o = Object,
      a = i("".split);
    t.exports = r(function () {
      return !o("z").propertyIsEnumerable(0);
    })
      ? function (t) {
          return "String" == s(t) ? a(t, "") : o(t);
        }
      : o;
  },
  function (t, e, n) {
    var i = n(2);
    t.exports = !i(function () {
      var t = function () {}.bind();
      return "function" != typeof t || t.hasOwnProperty("prototype");
    });
  },
  function (t, e, n) {
    var i = n(13),
      r = TypeError;
    t.exports = function (t) {
      if (i(t)) throw r("Can't call method on " + t);
      return t;
    };
  },
  function (t, e, n) {
    var i = n(5),
      r = n(35),
      s = i["__core-js_shared__"] || r("__core-js_shared__", {});
    t.exports = s;
  },
  function (t, e, n) {
    var i = n(5),
      r = Object.defineProperty;
    t.exports = function (t, e) {
      try {
        r(i, t, {
          value: e,
          configurable: !0,
          writable: !0,
        });
      } catch (n) {
        i[t] = e;
      }
      return e;
    };
  },
  function (t, e, n) {
    var i = n(0),
      r = 0,
      s = Math.random(),
      o = i((1).toString);
    t.exports = function (t) {
      return "Symbol(" + (void 0 === t ? "" : t) + ")_" + o(++r + s, 36);
    };
  },
  function (t, e, n) {
    var i = n(96),
      r = n(65);
    t.exports = function (t) {
      var e = i(t, "string");
      return r(e) ? e : e + "";
    };
  },
  function (t, e, n) {
    var i = n(0);
    t.exports = i({}.isPrototypeOf);
  },
  function (t, e, n) {
    var i = n(24),
      r = n(13);
    t.exports = function (t, e) {
      var n = t[e];
      return r(n) ? void 0 : i(n);
    };
  },
  function (t, e) {
    var n = String;
    t.exports = function (t) {
      try {
        return n(t);
      } catch (t) {
        return "Object";
      }
    };
  },
  function (t, e, n) {
    var i = n(99);
    t.exports = function (t) {
      var e = +t;
      return e != e || 0 === e ? 0 : i(e);
    };
  },
  function (t, e) {
    t.exports = [
      "constructor",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "toLocaleString",
      "toString",
      "valueOf",
    ];
  },
  function (t, e, n) {
    var i = n(58),
      r = n(36),
      s = i("keys");
    t.exports = function (t) {
      return s[t] || (s[t] = r(t));
    };
  },
  function (t, e, n) {
    var i = n(6),
      r = n(9),
      s = n(26);
    t.exports = i
      ? function (t, e, n) {
          return r.f(t, e, s(1, n));
        }
      : function (t, e, n) {
          return (t[e] = n), t;
        };
  },
  function (t, e, n) {
    "use strict";
    var i = n(20),
      r = n(10),
      s = n(22),
      o = n(73),
      a = n(1),
      l = n(104),
      c = n(78),
      u = n(79),
      h = n(47),
      d = n(44),
      p = n(15),
      f = n(4),
      m = n(19),
      g = n(77),
      v = o.PROPER,
      _ = o.CONFIGURABLE,
      y = g.IteratorPrototype,
      x = g.BUGGY_SAFARI_ITERATORS,
      b = f("iterator"),
      S = function () {
        return this;
      };
    t.exports = function (t, e, n, o, f, g, E) {
      l(n, e, o);
      var M,
        T,
        w,
        D = function (t) {
          if (t === f && L) return L;
          if (!x && t in P) return P[t];
          switch (t) {
            case "keys":
            case "values":
            case "entries":
              return function () {
                return new n(this, t);
              };
          }
          return function () {
            return new n(this);
          };
        },
        A = e + " Iterator",
        C = !1,
        P = t.prototype,
        R = P[b] || P["@@iterator"] || (f && P[f]),
        L = (!x && R) || D(f),
        O = ("Array" == e && P.entries) || R;
      if (
        (O &&
          (M = c(O.call(new t()))) !== Object.prototype &&
          M.next &&
          (s || c(M) === y || (u ? u(M, y) : a(M[b]) || p(M, b, S)),
          h(M, A, !0, !0),
          s && (m[A] = S)),
        v &&
          "values" == f &&
          R &&
          "values" !== R.name &&
          (!s && _
            ? d(P, "name", "values")
            : ((C = !0),
              (L = function () {
                return r(R, this);
              }))),
        f)
      )
        if (
          ((T = {
            values: D("values"),
            keys: g ? L : D("keys"),
            entries: D("entries"),
          }),
          E)
        )
          for (w in T) (x || C || !(w in P)) && p(P, w, T[w]);
        else
          i(
            {
              target: e,
              proto: !0,
              forced: x || C,
            },
            T
          );
      return (
        (s && !E) ||
          P[b] === L ||
          p(P, b, L, {
            name: f,
          }),
        (m[e] = L),
        T
      );
    };
  },
  function (t, e, n) {
    var i = n(67),
      r = n(42).concat("length", "prototype");
    e.f =
      Object.getOwnPropertyNames ||
      function (t) {
        return i(t, r);
      };
  },
  function (t, e, n) {
    var i = n(9).f,
      r = n(7),
      s = n(4)("toStringTag");
    t.exports = function (t, e, n) {
      t && !n && (t = t.prototype),
        t &&
          !r(t, s) &&
          i(t, s, {
            configurable: !0,
            value: e,
          });
    };
  },
  function (t, e) {
    t.exports = function (t, e) {
      return {
        value: t,
        done: e,
      };
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(20),
      r = n(5),
      s = n(0),
      o = n(76),
      a = n(15),
      l = n(27),
      c = n(50),
      u = n(53),
      h = n(1),
      d = n(13),
      p = n(3),
      f = n(2),
      m = n(85),
      g = n(47),
      v = n(115);
    t.exports = function (t, e, n) {
      var _ = -1 !== t.indexOf("Map"),
        y = -1 !== t.indexOf("Weak"),
        x = _ ? "set" : "add",
        b = r[t],
        S = b && b.prototype,
        E = b,
        M = {},
        T = function (t) {
          var e = s(S[t]);
          a(
            S,
            t,
            "add" == t
              ? function (t) {
                  return e(this, 0 === t ? 0 : t), this;
                }
              : "delete" == t
              ? function (t) {
                  return !(y && !p(t)) && e(this, 0 === t ? 0 : t);
                }
              : "get" == t
              ? function (t) {
                  return y && !p(t) ? void 0 : e(this, 0 === t ? 0 : t);
                }
              : "has" == t
              ? function (t) {
                  return !(y && !p(t)) && e(this, 0 === t ? 0 : t);
                }
              : function (t, n) {
                  return e(this, 0 === t ? 0 : t, n), this;
                }
          );
        };
      if (
        o(
          t,
          !h(b) ||
            !(
              y ||
              (S.forEach &&
                !f(function () {
                  new b().entries().next();
                }))
            )
        )
      )
        (E = n.getConstructor(e, t, _, x)), l.enable();
      else if (o(t, !0)) {
        var w = new E(),
          D = w[x](y ? {} : -0, 1) != w,
          A = f(function () {
            w.has(1);
          }),
          C = m(function (t) {
            new b(t);
          }),
          P =
            !y &&
            f(function () {
              for (var t = new b(), e = 5; e--; ) t[x](e, e);
              return !t.has(-0);
            });
        C ||
          (((E = e(function (t, e) {
            u(t, S);
            var n = v(new b(), t, E);
            return (
              d(e) ||
                c(e, n[x], {
                  that: n,
                  AS_ENTRIES: _,
                }),
              n
            );
          })).prototype = S),
          (S.constructor = E)),
          (A || P) && (T("delete"), T("has"), _ && T("get")),
          (P || D) && T(x),
          y && S.clear && delete S.clear;
      }
      return (
        (M[t] = E),
        i(
          {
            global: !0,
            constructor: !0,
            forced: E != b,
          },
          M
        ),
        g(E, t),
        y || n.setStrong(E, t, _),
        E
      );
    };
  },
  function (t, e, n) {
    var i = n(28),
      r = n(10),
      s = n(8),
      o = n(40),
      a = n(82),
      l = n(18),
      c = n(38),
      u = n(83),
      h = n(51),
      d = n(84),
      p = TypeError,
      f = function (t, e) {
        (this.stopped = t), (this.result = e);
      },
      m = f.prototype;
    t.exports = function (t, e, n) {
      var g,
        v,
        _,
        y,
        x,
        b,
        S,
        E = n && n.that,
        M = !(!n || !n.AS_ENTRIES),
        T = !(!n || !n.IS_RECORD),
        w = !(!n || !n.IS_ITERATOR),
        D = !(!n || !n.INTERRUPTED),
        A = i(e, E),
        C = function (t) {
          return g && d(g, "normal", t), new f(!0, t);
        },
        P = function (t) {
          return M
            ? (s(t), D ? A(t[0], t[1], C) : A(t[0], t[1]))
            : D
            ? A(t, C)
            : A(t);
        };
      if (T) g = t.iterator;
      else if (w) g = t;
      else {
        if (!(v = h(t))) throw p(o(t) + " is not iterable");
        if (a(v)) {
          for (_ = 0, y = l(t); y > _; _++)
            if ((x = P(t[_])) && c(m, x)) return x;
          return new f(!1);
        }
        g = u(t, v);
      }
      for (b = T ? t.next : g.next; !(S = r(b, g)).done; ) {
        try {
          x = P(S.value);
        } catch (t) {
          d(g, "throw", t);
        }
        if ("object" == typeof x && x && c(m, x)) return x;
      }
      return new f(!1);
    };
  },
  function (t, e, n) {
    var i = n(29),
      r = n(39),
      s = n(13),
      o = n(19),
      a = n(4)("iterator");
    t.exports = function (t) {
      if (!s(t)) return r(t, a) || r(t, "@@iterator") || o[i(t)];
    };
  },
  function (t, e, n) {
    var i = {};
    (i[n(4)("toStringTag")] = "z"), (t.exports = "[object z]" === String(i));
  },
  function (t, e, n) {
    var i = n(38),
      r = TypeError;
    t.exports = function (t, e) {
      if (i(e, t)) return t;
      throw r("Incorrect invocation");
    };
  },
  function (t, e, n) {
    var i = n(15);
    t.exports = function (t, e, n) {
      for (var r in e) i(t, r, e[r], n);
      return t;
    };
  },
  function (t, e, n) {
    var i = n(52),
      r = n(15),
      s = n(117);
    i ||
      r(Object.prototype, "toString", s, {
        unsafe: !0,
      });
  },
  function (t, e, n) {
    "use strict";
    var i = n(118).charAt,
      r = n(88),
      s = n(14),
      o = n(45),
      a = n(48),
      l = s.set,
      c = s.getterFor("String Iterator");
    o(
      String,
      "String",
      function (t) {
        l(this, {
          type: "String Iterator",
          string: r(t),
          index: 0,
        });
      },
      function () {
        var t,
          e = c(this),
          n = e.string,
          r = e.index;
        return r >= n.length
          ? a(void 0, !0)
          : ((t = i(n, r)), (e.index += t.length), a(t, !1));
      }
    );
  },
  function (t, e) {
    var n;
    n = (function () {
      return this;
    })();
    try {
      n = n || new Function("return this")();
    } catch (t) {
      "object" == typeof window && (n = window);
    }
    t.exports = n;
  },
  function (t, e, n) {
    var i = n(22),
      r = n(34);
    (t.exports = function (t, e) {
      return r[t] || (r[t] = void 0 !== e ? e : {});
    })("versions", []).push({
      version: "3.30.1",
      mode: i ? "pure" : "global",
      copyright: "Â© 2014-2023 Denis Pushkarev (zloirock.ru)",
      license: "https://github.com/zloirock/core-js/blob/v3.30.1/LICENSE",
      source: "https://github.com/zloirock/core-js",
    });
  },
  function (t, e, n) {
    var i = n(93),
      r = n(2);
    t.exports =
      !!Object.getOwnPropertySymbols &&
      !r(function () {
        var t = Symbol();
        return (
          !String(t) ||
          !(Object(t) instanceof Symbol) ||
          (!Symbol.sham && i && i < 41)
        );
      });
  },
  function (t, e, n) {
    var i = n(59);
    t.exports = i && !Symbol.sham && "symbol" == typeof Symbol.iterator;
  },
  function (t, e) {
    var n = "object" == typeof document && document.all,
      i = void 0 === n && void 0 !== n;
    t.exports = {
      all: n,
      IS_HTMLDDA: i,
    };
  },
  function (t, e, n) {
    var i = n(6),
      r = n(2);
    t.exports =
      i &&
      r(function () {
        return (
          42 !=
          Object.defineProperty(function () {}, "prototype", {
            value: 42,
            writable: !1,
          }).prototype
        );
      });
  },
  function (t, e, n) {
    var i = n(6),
      r = n(2),
      s = n(64);
    t.exports =
      !i &&
      !r(function () {
        return (
          7 !=
          Object.defineProperty(s("div"), "a", {
            get: function () {
              return 7;
            },
          }).a
        );
      });
  },
  function (t, e, n) {
    var i = n(5),
      r = n(3),
      s = i.document,
      o = r(s) && r(s.createElement);
    t.exports = function (t) {
      return o ? s.createElement(t) : {};
    };
  },
  function (t, e, n) {
    var i = n(17),
      r = n(1),
      s = n(38),
      o = n(60),
      a = Object;
    t.exports = o
      ? function (t) {
          return "symbol" == typeof t;
        }
      : function (t) {
          var e = i("Symbol");
          return r(e) && s(e.prototype, a(t));
        };
  },
  function (t, e, n) {
    var i = n(67),
      r = n(42);
    t.exports =
      Object.keys ||
      function (t) {
        return i(t, r);
      };
  },
  function (t, e, n) {
    var i = n(0),
      r = n(7),
      s = n(11),
      o = n(98).indexOf,
      a = n(25),
      l = i([].push);
    t.exports = function (t, e) {
      var n,
        i = s(t),
        c = 0,
        u = [];
      for (n in i) !r(a, n) && r(i, n) && l(u, n);
      for (; e.length > c; ) r(i, (n = e[c++])) && (~o(u, n) || l(u, n));
      return u;
    };
  },
  function (t, e, n) {
    var i = n(41),
      r = Math.max,
      s = Math.min;
    t.exports = function (t, e) {
      var n = i(t);
      return n < 0 ? r(n + e, 0) : s(n, e);
    };
  },
  function (t, e, n) {
    var i = n(5),
      r = n(1),
      s = i.WeakMap;
    t.exports = r(s) && /native code/.test(String(s));
  },
  function (t, e, n) {
    var i = n(6),
      r = n(10),
      s = n(71),
      o = n(26),
      a = n(11),
      l = n(37),
      c = n(7),
      u = n(63),
      h = Object.getOwnPropertyDescriptor;
    e.f = i
      ? h
      : function (t, e) {
          if (((t = a(t)), (e = l(e)), u))
            try {
              return h(t, e);
            } catch (t) {}
          if (c(t, e)) return o(!r(s.f, t, e), t[e]);
        };
  },
  function (t, e, n) {
    "use strict";
    var i = {}.propertyIsEnumerable,
      r = Object.getOwnPropertyDescriptor,
      s =
        r &&
        !i.call(
          {
            1: 2,
          },
          1
        );
    e.f = s
      ? function (t) {
          var e = r(this, t);
          return !!e && e.enumerable;
        }
      : i;
  },
  function (t, e, n) {
    var i = n(0),
      r = n(2),
      s = n(1),
      o = n(7),
      a = n(6),
      l = n(73).CONFIGURABLE,
      c = n(74),
      u = n(14),
      h = u.enforce,
      d = u.get,
      p = String,
      f = Object.defineProperty,
      m = i("".slice),
      g = i("".replace),
      v = i([].join),
      _ =
        a &&
        !r(function () {
          return (
            8 !==
            f(function () {}, "length", {
              value: 8,
            }).length
          );
        }),
      y = String(String).split("String"),
      x = (t.exports = function (t, e, n) {
        "Symbol(" === m(p(e), 0, 7) &&
          (e = "[" + g(p(e), /^Symbol\(([^)]*)\)/, "$1") + "]"),
          n && n.getter && (e = "get " + e),
          n && n.setter && (e = "set " + e),
          (!o(t, "name") || (l && t.name !== e)) &&
            (a
              ? f(t, "name", {
                  value: e,
                  configurable: !0,
                })
              : (t.name = e)),
          _ &&
            n &&
            o(n, "arity") &&
            t.length !== n.arity &&
            f(t, "length", {
              value: n.arity,
            });
        try {
          n && o(n, "constructor") && n.constructor
            ? a &&
              f(t, "prototype", {
                writable: !1,
              })
            : t.prototype && (t.prototype = void 0);
        } catch (t) {}
        var i = h(t);
        return (
          o(i, "source") || (i.source = v(y, "string" == typeof e ? e : "")), t
        );
      });
    Function.prototype.toString = x(function () {
      return (s(this) && d(this).source) || c(this);
    }, "toString");
  },
  function (t, e, n) {
    var i = n(6),
      r = n(7),
      s = Function.prototype,
      o = i && Object.getOwnPropertyDescriptor,
      a = r(s, "name"),
      l = a && "something" === function () {}.name,
      c = a && (!i || (i && o(s, "name").configurable));
    t.exports = {
      EXISTS: a,
      PROPER: l,
      CONFIGURABLE: c,
    };
  },
  function (t, e, n) {
    var i = n(0),
      r = n(1),
      s = n(34),
      o = i(Function.toString);
    r(s.inspectSource) ||
      (s.inspectSource = function (t) {
        return o(t);
      }),
      (t.exports = s.inspectSource);
  },
  function (t, e) {
    e.f = Object.getOwnPropertySymbols;
  },
  function (t, e, n) {
    var i = n(2),
      r = n(1),
      s = /#|\.prototype\./,
      o = function (t, e) {
        var n = l[a(t)];
        return n == u || (n != c && (r(e) ? i(e) : !!e));
      },
      a = (o.normalize = function (t) {
        return String(t).replace(s, ".").toLowerCase();
      }),
      l = (o.data = {}),
      c = (o.NATIVE = "N"),
      u = (o.POLYFILL = "P");
    t.exports = o;
  },
  function (t, e, n) {
    "use strict";
    var i,
      r,
      s,
      o = n(2),
      a = n(1),
      l = n(3),
      c = n(23),
      u = n(78),
      h = n(15),
      d = n(4),
      p = n(22),
      f = d("iterator"),
      m = !1;
    [].keys &&
      ("next" in (s = [].keys())
        ? (r = u(u(s))) !== Object.prototype && (i = r)
        : (m = !0)),
      !l(i) ||
      o(function () {
        var t = {};
        return i[f].call(t) !== t;
      })
        ? (i = {})
        : p && (i = c(i)),
      a(i[f]) ||
        h(i, f, function () {
          return this;
        }),
      (t.exports = {
        IteratorPrototype: i,
        BUGGY_SAFARI_ITERATORS: m,
      });
  },
  function (t, e, n) {
    var i = n(7),
      r = n(1),
      s = n(16),
      o = n(43),
      a = n(105),
      l = o("IE_PROTO"),
      c = Object,
      u = c.prototype;
    t.exports = a
      ? c.getPrototypeOf
      : function (t) {
          var e = s(t);
          if (i(e, l)) return e[l];
          var n = e.constructor;
          return r(n) && e instanceof n
            ? n.prototype
            : e instanceof c
            ? u
            : null;
        };
  },
  function (t, e, n) {
    var i = n(106),
      r = n(8),
      s = n(107);
    t.exports =
      Object.setPrototypeOf ||
      ("__proto__" in {}
        ? (function () {
            var t,
              e = !1,
              n = {};
            try {
              (t = i(Object.prototype, "__proto__", "set"))(n, []),
                (e = n instanceof Array);
            } catch (t) {}
            return function (n, i) {
              return r(n), s(i), e ? t(n, i) : (n.__proto__ = i), n;
            };
          })()
        : void 0);
  },
  function (t, e, n) {
    "use strict";
    var i = n(37),
      r = n(9),
      s = n(26);
    t.exports = function (t, e, n) {
      var o = i(e);
      o in t ? r.f(t, o, s(0, n)) : (t[o] = n);
    };
  },
  function (t, e, n) {
    var i = n(2);
    t.exports = !i(function () {
      return Object.isExtensible(Object.preventExtensions({}));
    });
  },
  function (t, e, n) {
    var i = n(4),
      r = n(19),
      s = i("iterator"),
      o = Array.prototype;
    t.exports = function (t) {
      return void 0 !== t && (r.Array === t || o[s] === t);
    };
  },
  function (t, e, n) {
    var i = n(10),
      r = n(24),
      s = n(8),
      o = n(40),
      a = n(51),
      l = TypeError;
    t.exports = function (t, e) {
      var n = arguments.length < 2 ? a(t) : e;
      if (r(n)) return s(i(n, t));
      throw l(o(t) + " is not iterable");
    };
  },
  function (t, e, n) {
    var i = n(10),
      r = n(8),
      s = n(39);
    t.exports = function (t, e, n) {
      var o, a;
      r(t);
      try {
        if (!(o = s(t, "return"))) {
          if ("throw" === e) throw n;
          return n;
        }
        o = i(o, t);
      } catch (t) {
        (a = !0), (o = t);
      }
      if ("throw" === e) throw n;
      if (a) throw o;
      return r(o), n;
    };
  },
  function (t, e, n) {
    var i = n(4)("iterator"),
      r = !1;
    try {
      var s = 0,
        o = {
          next: function () {
            return {
              done: !!s++,
            };
          },
          return: function () {
            r = !0;
          },
        };
      (o[i] = function () {
        return this;
      }),
        Array.from(o, function () {
          throw 2;
        });
    } catch (t) {}
    t.exports = function (t, e) {
      if (!e && !r) return !1;
      var n = !1;
      try {
        var s = {};
        (s[i] = function () {
          return {
            next: function () {
              return {
                done: (n = !0),
              };
            },
          };
        }),
          t(s);
      } catch (t) {}
      return n;
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(23),
      r = n(87),
      s = n(54),
      o = n(28),
      a = n(53),
      l = n(13),
      c = n(50),
      u = n(45),
      h = n(48),
      d = n(116),
      p = n(6),
      f = n(27).fastKey,
      m = n(14),
      g = m.set,
      v = m.getterFor;
    t.exports = {
      getConstructor: function (t, e, n, u) {
        var h = t(function (t, r) {
            a(t, d),
              g(t, {
                type: e,
                index: i(null),
                first: void 0,
                last: void 0,
                size: 0,
              }),
              p || (t.size = 0),
              l(r) ||
                c(r, t[u], {
                  that: t,
                  AS_ENTRIES: n,
                });
          }),
          d = h.prototype,
          m = v(e),
          _ = function (t, e, n) {
            var i,
              r,
              s = m(t),
              o = y(t, e);
            return (
              o
                ? (o.value = n)
                : ((s.last = o =
                    {
                      index: (r = f(e, !0)),
                      key: e,
                      value: n,
                      previous: (i = s.last),
                      next: void 0,
                      removed: !1,
                    }),
                  s.first || (s.first = o),
                  i && (i.next = o),
                  p ? s.size++ : t.size++,
                  "F" !== r && (s.index[r] = o)),
              t
            );
          },
          y = function (t, e) {
            var n,
              i = m(t),
              r = f(e);
            if ("F" !== r) return i.index[r];
            for (n = i.first; n; n = n.next) if (n.key == e) return n;
          };
        return (
          s(d, {
            clear: function () {
              for (var t = m(this), e = t.index, n = t.first; n; )
                (n.removed = !0),
                  n.previous && (n.previous = n.previous.next = void 0),
                  delete e[n.index],
                  (n = n.next);
              (t.first = t.last = void 0), p ? (t.size = 0) : (this.size = 0);
            },
            delete: function (t) {
              var e = m(this),
                n = y(this, t);
              if (n) {
                var i = n.next,
                  r = n.previous;
                delete e.index[n.index],
                  (n.removed = !0),
                  r && (r.next = i),
                  i && (i.previous = r),
                  e.first == n && (e.first = i),
                  e.last == n && (e.last = r),
                  p ? e.size-- : this.size--;
              }
              return !!n;
            },
            forEach: function (t) {
              for (
                var e,
                  n = m(this),
                  i = o(t, arguments.length > 1 ? arguments[1] : void 0);
                (e = e ? e.next : n.first);

              )
                for (i(e.value, e.key, this); e && e.removed; ) e = e.previous;
            },
            has: function (t) {
              return !!y(this, t);
            },
          }),
          s(
            d,
            n
              ? {
                  get: function (t) {
                    var e = y(this, t);
                    return e && e.value;
                  },
                  set: function (t, e) {
                    return _(this, 0 === t ? 0 : t, e);
                  },
                }
              : {
                  add: function (t) {
                    return _(this, (t = 0 === t ? 0 : t), t);
                  },
                }
          ),
          p &&
            r(d, "size", {
              configurable: !0,
              get: function () {
                return m(this).size;
              },
            }),
          h
        );
      },
      setStrong: function (t, e, n) {
        var i = e + " Iterator",
          r = v(e),
          s = v(i);
        u(
          t,
          e,
          function (t, e) {
            g(this, {
              type: i,
              target: t,
              state: r(t),
              kind: e,
              last: void 0,
            });
          },
          function () {
            for (var t = s(this), e = t.kind, n = t.last; n && n.removed; )
              n = n.previous;
            return t.target && (t.last = n = n ? n.next : t.state.first)
              ? h(
                  "keys" == e
                    ? n.key
                    : "values" == e
                    ? n.value
                    : [n.key, n.value],
                  !1
                )
              : ((t.target = void 0), h(void 0, !0));
          },
          n ? "entries" : "values",
          !n,
          !0
        ),
          d(e);
      },
    };
  },
  function (t, e, n) {
    var i = n(72),
      r = n(9);
    t.exports = function (t, e, n) {
      return (
        n.get &&
          i(n.get, e, {
            getter: !0,
          }),
        n.set &&
          i(n.set, e, {
            setter: !0,
          }),
        r.f(t, e, n)
      );
    };
  },
  function (t, e, n) {
    var i = n(29),
      r = String;
    t.exports = function (t) {
      if ("Symbol" === i(t))
        throw TypeError("Cannot convert a Symbol value to a string");
      return r(t);
    };
  },
  function (t, e, n) {
    var i = n(0),
      r = n(2),
      s = n(1),
      o = n(29),
      a = n(17),
      l = n(74),
      c = function () {},
      u = [],
      h = a("Reflect", "construct"),
      d = /^\s*(?:class|function)\b/,
      p = i(d.exec),
      f = !d.exec(c),
      m = function (t) {
        if (!s(t)) return !1;
        try {
          return h(c, u, t), !0;
        } catch (t) {
          return !1;
        }
      },
      g = function (t) {
        if (!s(t)) return !1;
        switch (o(t)) {
          case "AsyncFunction":
          case "GeneratorFunction":
          case "AsyncGeneratorFunction":
            return !1;
        }
        try {
          return f || !!p(d, l(t));
        } catch (t) {
          return !0;
        }
      };
    (g.sham = !0),
      (t.exports =
        !h ||
        r(function () {
          var t;
          return (
            m(m.call) ||
            !m(Object) ||
            !m(function () {
              t = !0;
            }) ||
            t
          );
        })
          ? g
          : m);
  },
  function (t, e, n) {
    "use strict";
    (function (t) {
      var n = "object" == typeof t && t && t.Object === Object && t;
      e.a = n;
    }).call(this, n(57));
  },
  function (t, e, n) {
    n(30), n(108), n(55), n(56);
    var i = n(21);
    t.exports = i.Map;
  },
  function (t, e, n) {
    var i = n(4),
      r = n(23),
      s = n(9).f,
      o = i("unscopables"),
      a = Array.prototype;
    null == a[o] &&
      s(a, o, {
        configurable: !0,
        value: r(null),
      }),
      (t.exports = function (t) {
        a[o][t] = !0;
      });
  },
  function (t, e, n) {
    var i,
      r,
      s = n(5),
      o = n(94),
      a = s.process,
      l = s.Deno,
      c = (a && a.versions) || (l && l.version),
      u = c && c.v8;
    u && (r = (i = u.split("."))[0] > 0 && i[0] < 4 ? 1 : +(i[0] + i[1])),
      !r &&
        o &&
        (!(i = o.match(/Edge\/(\d+)/)) || i[1] >= 74) &&
        (i = o.match(/Chrome\/(\d+)/)) &&
        (r = +i[1]),
      (t.exports = r);
  },
  function (t, e) {
    t.exports =
      ("undefined" != typeof navigator && String(navigator.userAgent)) || "";
  },
  function (t, e, n) {
    var i = n(6),
      r = n(62),
      s = n(9),
      o = n(8),
      a = n(11),
      l = n(66);
    e.f =
      i && !r
        ? Object.defineProperties
        : function (t, e) {
            o(t);
            for (var n, i = a(e), r = l(e), c = r.length, u = 0; c > u; )
              s.f(t, (n = r[u++]), i[n]);
            return t;
          };
  },
  function (t, e, n) {
    var i = n(10),
      r = n(3),
      s = n(65),
      o = n(39),
      a = n(97),
      l = n(4),
      c = TypeError,
      u = l("toPrimitive");
    t.exports = function (t, e) {
      if (!r(t) || s(t)) return t;
      var n,
        l = o(t, u);
      if (l) {
        if ((void 0 === e && (e = "default"), (n = i(l, t, e)), !r(n) || s(n)))
          return n;
        throw c("Can't convert object to primitive value");
      }
      return void 0 === e && (e = "number"), a(t, e);
    };
  },
  function (t, e, n) {
    var i = n(10),
      r = n(1),
      s = n(3),
      o = TypeError;
    t.exports = function (t, e) {
      var n, a;
      if ("string" === e && r((n = t.toString)) && !s((a = i(n, t)))) return a;
      if (r((n = t.valueOf)) && !s((a = i(n, t)))) return a;
      if ("string" !== e && r((n = t.toString)) && !s((a = i(n, t)))) return a;
      throw o("Can't convert object to primitive value");
    };
  },
  function (t, e, n) {
    var i = n(11),
      r = n(68),
      s = n(18),
      o = function (t) {
        return function (e, n, o) {
          var a,
            l = i(e),
            c = s(l),
            u = r(o, c);
          if (t && n != n) {
            for (; c > u; ) if ((a = l[u++]) != a) return !0;
          } else
            for (; c > u; u++)
              if ((t || u in l) && l[u] === n) return t || u || 0;
          return !t && -1;
        };
      };
    t.exports = {
      includes: o(!0),
      indexOf: o(!1),
    };
  },
  function (t, e) {
    var n = Math.ceil,
      i = Math.floor;
    t.exports =
      Math.trunc ||
      function (t) {
        var e = +t;
        return (e > 0 ? i : n)(e);
      };
  },
  function (t, e, n) {
    var i = n(41),
      r = Math.min;
    t.exports = function (t) {
      return t > 0 ? r(i(t), 9007199254740991) : 0;
    };
  },
  function (t, e, n) {
    var i = n(17);
    t.exports = i("document", "documentElement");
  },
  function (t, e, n) {
    var i = n(7),
      r = n(103),
      s = n(70),
      o = n(9);
    t.exports = function (t, e, n) {
      for (var a = r(e), l = o.f, c = s.f, u = 0; u < a.length; u++) {
        var h = a[u];
        i(t, h) || (n && i(n, h)) || l(t, h, c(e, h));
      }
    };
  },
  function (t, e, n) {
    var i = n(17),
      r = n(0),
      s = n(46),
      o = n(75),
      a = n(8),
      l = r([].concat);
    t.exports =
      i("Reflect", "ownKeys") ||
      function (t) {
        var e = s.f(a(t)),
          n = o.f;
        return n ? l(e, n(t)) : e;
      };
  },
  function (t, e, n) {
    "use strict";
    var i = n(77).IteratorPrototype,
      r = n(23),
      s = n(26),
      o = n(47),
      a = n(19),
      l = function () {
        return this;
      };
    t.exports = function (t, e, n, c) {
      var u = e + " Iterator";
      return (
        (t.prototype = r(i, {
          next: s(+!c, n),
        })),
        o(t, u, !1, !0),
        (a[u] = l),
        t
      );
    };
  },
  function (t, e, n) {
    var i = n(2);
    t.exports = !i(function () {
      function t() {}
      return (
        (t.prototype.constructor = null),
        Object.getPrototypeOf(new t()) !== t.prototype
      );
    });
  },
  function (t, e, n) {
    var i = n(0),
      r = n(24);
    t.exports = function (t, e, n) {
      try {
        return i(r(Object.getOwnPropertyDescriptor(t, e)[n]));
      } catch (t) {}
    };
  },
  function (t, e, n) {
    var i = n(1),
      r = String,
      s = TypeError;
    t.exports = function (t) {
      if ("object" == typeof t || i(t)) return t;
      throw s("Can't set " + r(t) + " as a prototype");
    };
  },
  function (t, e, n) {
    n(109);
  },
  function (t, e, n) {
    "use strict";
    n(49)(
      "Map",
      function (t) {
        return function () {
          return t(this, arguments.length ? arguments[0] : void 0);
        };
      },
      n(86)
    );
  },
  function (t, e, n) {
    var i = n(12),
      r = n(11),
      s = n(46).f,
      o = n(111),
      a =
        "object" == typeof window && window && Object.getOwnPropertyNames
          ? Object.getOwnPropertyNames(window)
          : [];
    t.exports.f = function (t) {
      return a && "Window" == i(t)
        ? (function (t) {
            try {
              return s(t);
            } catch (t) {
              return o(a);
            }
          })(t)
        : s(r(t));
    };
  },
  function (t, e, n) {
    var i = n(68),
      r = n(18),
      s = n(80),
      o = Array,
      a = Math.max;
    t.exports = function (t, e, n) {
      for (
        var l = r(t),
          c = i(e, l),
          u = i(void 0 === n ? l : n, l),
          h = o(a(u - c, 0)),
          d = 0;
        c < u;
        c++, d++
      )
        s(h, d, t[c]);
      return (h.length = d), h;
    };
  },
  function (t, e, n) {
    var i = n(2),
      r = n(3),
      s = n(12),
      o = n(113),
      a = Object.isExtensible,
      l = i(function () {
        a(1);
      });
    t.exports =
      l || o
        ? function (t) {
            return !!r(t) && (!o || "ArrayBuffer" != s(t)) && (!a || a(t));
          }
        : a;
  },
  function (t, e, n) {
    var i = n(2);
    t.exports = i(function () {
      if ("function" == typeof ArrayBuffer) {
        var t = new ArrayBuffer(8);
        Object.isExtensible(t) &&
          Object.defineProperty(t, "a", {
            value: 8,
          });
      }
    });
  },
  function (t, e, n) {
    var i = n(12),
      r = n(0);
    t.exports = function (t) {
      if ("Function" === i(t)) return r(t);
    };
  },
  function (t, e, n) {
    var i = n(1),
      r = n(3),
      s = n(79);
    t.exports = function (t, e, n) {
      var o, a;
      return (
        s &&
          i((o = e.constructor)) &&
          o !== n &&
          r((a = o.prototype)) &&
          a !== n.prototype &&
          s(t, a),
        t
      );
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(17),
      r = n(87),
      s = n(4),
      o = n(6),
      a = s("species");
    t.exports = function (t) {
      var e = i(t);
      o &&
        e &&
        !e[a] &&
        r(e, a, {
          configurable: !0,
          get: function () {
            return this;
          },
        });
    };
  },
  function (t, e, n) {
    "use strict";
    var i = n(52),
      r = n(29);
    t.exports = i
      ? {}.toString
      : function () {
          return "[object " + r(this) + "]";
        };
  },
  function (t, e, n) {
    var i = n(0),
      r = n(41),
      s = n(88),
      o = n(33),
      a = i("".charAt),
      l = i("".charCodeAt),
      c = i("".slice),
      u = function (t) {
        return function (e, n) {
          var i,
            u,
            h = s(o(e)),
            d = r(n),
            p = h.length;
          return d < 0 || d >= p
            ? t
              ? ""
              : void 0
            : (i = l(h, d)) < 55296 ||
              i > 56319 ||
              d + 1 === p ||
              (u = l(h, d + 1)) < 56320 ||
              u > 57343
            ? t
              ? a(h, d)
              : i
            : t
            ? c(h, d, d + 2)
            : u - 56320 + ((i - 55296) << 10) + 65536;
        };
      };
    t.exports = {
      codeAt: u(!1),
      charAt: u(!0),
    };
  },
  function (t, e, n) {
    n(30), n(55), n(120), n(56);
    var i = n(21);
    t.exports = i.Set;
  },
  function (t, e, n) {
    n(121);
  },
  function (t, e, n) {
    "use strict";
    n(49)(
      "Set",
      function (t) {
        return function () {
          return t(this, arguments.length ? arguments[0] : void 0);
        };
      },
      n(86)
    );
  },
  function (t, e, n) {
    n(30), n(55), n(123);
    var i = n(21);
    t.exports = i.WeakMap;
  },
  function (t, e, n) {
    n(124);
  },
  function (t, e, n) {
    "use strict";
    var i,
      r = n(81),
      s = n(5),
      o = n(0),
      a = n(54),
      l = n(27),
      c = n(49),
      u = n(125),
      h = n(3),
      d = n(14).enforce,
      p = n(2),
      f = n(69),
      m = Object,
      g = Array.isArray,
      v = m.isExtensible,
      _ = m.isFrozen,
      y = m.isSealed,
      x = m.freeze,
      b = m.seal,
      S = {},
      E = {},
      M = !s.ActiveXObject && "ActiveXObject" in s,
      T = function (t) {
        return function () {
          return t(this, arguments.length ? arguments[0] : void 0);
        };
      },
      w = c("WeakMap", T, u),
      D = w.prototype,
      A = o(D.set);
    if (f)
      if (M) {
        (i = u.getConstructor(T, "WeakMap", !0)), l.enable();
        var C = o(D.delete),
          P = o(D.has),
          R = o(D.get);
        a(D, {
          delete: function (t) {
            if (h(t) && !v(t)) {
              var e = d(this);
              return (
                e.frozen || (e.frozen = new i()),
                C(this, t) || e.frozen.delete(t)
              );
            }
            return C(this, t);
          },
          has: function (t) {
            if (h(t) && !v(t)) {
              var e = d(this);
              return (
                e.frozen || (e.frozen = new i()), P(this, t) || e.frozen.has(t)
              );
            }
            return P(this, t);
          },
          get: function (t) {
            if (h(t) && !v(t)) {
              var e = d(this);
              return (
                e.frozen || (e.frozen = new i()),
                P(this, t) ? R(this, t) : e.frozen.get(t)
              );
            }
            return R(this, t);
          },
          set: function (t, e) {
            if (h(t) && !v(t)) {
              var n = d(this);
              n.frozen || (n.frozen = new i()),
                P(this, t) ? A(this, t, e) : n.frozen.set(t, e);
            } else A(this, t, e);
            return this;
          },
        });
      } else
        r &&
          p(function () {
            var t = x([]);
            return A(new w(), t, 1), !_(t);
          }) &&
          a(D, {
            set: function (t, e) {
              var n;
              return (
                g(t) && (_(t) ? (n = S) : y(t) && (n = E)),
                A(this, t, e),
                n == S && x(t),
                n == E && b(t),
                this
              );
            },
          });
  },
  function (t, e, n) {
    "use strict";
    var i = n(0),
      r = n(54),
      s = n(27).getWeakData,
      o = n(53),
      a = n(8),
      l = n(13),
      c = n(3),
      u = n(50),
      h = n(126),
      d = n(7),
      p = n(14),
      f = p.set,
      m = p.getterFor,
      g = h.find,
      v = h.findIndex,
      _ = i([].splice),
      y = 0,
      x = function (t) {
        return t.frozen || (t.frozen = new b());
      },
      b = function () {
        this.entries = [];
      },
      S = function (t, e) {
        return g(t.entries, function (t) {
          return t[0] === e;
        });
      };
    (b.prototype = {
      get: function (t) {
        var e = S(this, t);
        if (e) return e[1];
      },
      has: function (t) {
        return !!S(this, t);
      },
      set: function (t, e) {
        var n = S(this, t);
        n ? (n[1] = e) : this.entries.push([t, e]);
      },
      delete: function (t) {
        var e = v(this.entries, function (e) {
          return e[0] === t;
        });
        return ~e && _(this.entries, e, 1), !!~e;
      },
    }),
      (t.exports = {
        getConstructor: function (t, e, n, i) {
          var h = t(function (t, r) {
              o(t, p),
                f(t, {
                  type: e,
                  id: y++,
                  frozen: void 0,
                }),
                l(r) ||
                  u(r, t[i], {
                    that: t,
                    AS_ENTRIES: n,
                  });
            }),
            p = h.prototype,
            g = m(e),
            v = function (t, e, n) {
              var i = g(t),
                r = s(a(e), !0);
              return !0 === r ? x(i).set(e, n) : (r[i.id] = n), t;
            };
          return (
            r(p, {
              delete: function (t) {
                var e = g(this);
                if (!c(t)) return !1;
                var n = s(t);
                return !0 === n
                  ? x(e).delete(t)
                  : n && d(n, e.id) && delete n[e.id];
              },
              has: function (t) {
                var e = g(this);
                if (!c(t)) return !1;
                var n = s(t);
                return !0 === n ? x(e).has(t) : n && d(n, e.id);
              },
            }),
            r(
              p,
              n
                ? {
                    get: function (t) {
                      var e = g(this);
                      if (c(t)) {
                        var n = s(t);
                        return !0 === n ? x(e).get(t) : n ? n[e.id] : void 0;
                      }
                    },
                    set: function (t, e) {
                      return v(this, t, e);
                    },
                  }
                : {
                    add: function (t) {
                      return v(this, t, !0);
                    },
                  }
            ),
            h
          );
        },
      });
  },
  function (t, e, n) {
    var i = n(28),
      r = n(0),
      s = n(31),
      o = n(16),
      a = n(18),
      l = n(127),
      c = r([].push),
      u = function (t) {
        var e = 1 == t,
          n = 2 == t,
          r = 3 == t,
          u = 4 == t,
          h = 6 == t,
          d = 7 == t,
          p = 5 == t || h;
        return function (f, m, g, v) {
          for (
            var _,
              y,
              x = o(f),
              b = s(x),
              S = i(m, g),
              E = a(b),
              M = 0,
              T = v || l,
              w = e ? T(f, E) : n || d ? T(f, 0) : void 0;
            E > M;
            M++
          )
            if ((p || M in b) && ((y = S((_ = b[M]), M, x)), t))
              if (e) w[M] = y;
              else if (y)
                switch (t) {
                  case 3:
                    return !0;
                  case 5:
                    return _;
                  case 6:
                    return M;
                  case 2:
                    c(w, _);
                }
              else
                switch (t) {
                  case 4:
                    return !1;
                  case 7:
                    c(w, _);
                }
          return h ? -1 : r || u ? u : w;
        };
      };
    t.exports = {
      forEach: u(0),
      map: u(1),
      filter: u(2),
      some: u(3),
      every: u(4),
      find: u(5),
      findIndex: u(6),
      filterReject: u(7),
    };
  },
  function (t, e, n) {
    var i = n(128);
    t.exports = function (t, e) {
      return new (i(t))(0 === e ? 0 : e);
    };
  },
  function (t, e, n) {
    var i = n(129),
      r = n(89),
      s = n(3),
      o = n(4)("species"),
      a = Array;
    t.exports = function (t) {
      var e;
      return (
        i(t) &&
          ((e = t.constructor),
          ((r(e) && (e === a || i(e.prototype))) ||
            (s(e) && null === (e = e[o]))) &&
            (e = void 0)),
        void 0 === e ? a : e
      );
    };
  },
  function (t, e, n) {
    var i = n(12);
    t.exports =
      Array.isArray ||
      function (t) {
        return "Array" == i(t);
      };
  },
  function (t, e, n) {
    n(56), n(131);
    var i = n(21);
    t.exports = i.Array.from;
  },
  function (t, e, n) {
    var i = n(20),
      r = n(132);
    i(
      {
        target: "Array",
        stat: !0,
        forced: !n(85)(function (t) {
          Array.from(t);
        }),
      },
      {
        from: r,
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var i = n(28),
      r = n(10),
      s = n(16),
      o = n(133),
      a = n(82),
      l = n(89),
      c = n(18),
      u = n(80),
      h = n(83),
      d = n(51),
      p = Array;
    t.exports = function (t) {
      var e = s(t),
        n = l(this),
        f = arguments.length,
        m = f > 1 ? arguments[1] : void 0,
        g = void 0 !== m;
      g && (m = i(m, f > 2 ? arguments[2] : void 0));
      var v,
        _,
        y,
        x,
        b,
        S,
        E = d(e),
        M = 0;
      if (!E || (this === p && a(E)))
        for (v = c(e), _ = n ? new this(v) : p(v); v > M; M++)
          (S = g ? m(e[M], M) : e[M]), u(_, M, S);
      else
        for (
          b = (x = h(e, E)).next, _ = n ? new this() : [];
          !(y = r(b, x)).done;
          M++
        )
          (S = g ? o(x, m, [y.value, M], !0) : y.value), u(_, M, S);
      return (_.length = M), _;
    };
  },
  function (t, e, n) {
    var i = n(8),
      r = n(84);
    t.exports = function (t, e, n, s) {
      try {
        return s ? e(i(n)[0], n[1]) : e(n);
      } catch (e) {
        r(t, "throw", e);
      }
    };
  },
  function (t, e, n) {
    n(135);
    var i = n(21);
    t.exports = i.Object.assign;
  },
  function (t, e, n) {
    var i = n(20),
      r = n(136);
    i(
      {
        target: "Object",
        stat: !0,
        arity: 2,
        forced: Object.assign !== r,
      },
      {
        assign: r,
      }
    );
  },
  function (t, e, n) {
    "use strict";
    var i = n(6),
      r = n(0),
      s = n(10),
      o = n(2),
      a = n(66),
      l = n(75),
      c = n(71),
      u = n(16),
      h = n(31),
      d = Object.assign,
      p = Object.defineProperty,
      f = r([].concat);
    t.exports =
      !d ||
      o(function () {
        if (
          i &&
          1 !==
            d(
              {
                b: 1,
              },
              d(
                p({}, "a", {
                  enumerable: !0,
                  get: function () {
                    p(this, "b", {
                      value: 3,
                      enumerable: !1,
                    });
                  },
                }),
                {
                  b: 2,
                }
              )
            ).b
        )
          return !0;
        var t = {},
          e = {},
          n = Symbol();
        return (
          (t[n] = 7),
          "abcdefghijklmnopqrst".split("").forEach(function (t) {
            e[t] = t;
          }),
          7 != d({}, t)[n] || "abcdefghijklmnopqrst" != a(d({}, e)).join("")
        );
      })
        ? function (t, e) {
            for (
              var n = u(t), r = arguments.length, o = 1, d = l.f, p = c.f;
              r > o;

            )
              for (
                var m,
                  g = h(arguments[o++]),
                  v = d ? f(a(g), d(g)) : a(g),
                  _ = v.length,
                  y = 0;
                _ > y;

              )
                (m = v[y++]), (i && !s(p, g, m)) || (n[m] = g[m]);
            return n;
          }
        : d;
  },
  function (t, e, n) {
    "use strict";
    n.r(e);
    var i = {};
    function r(t, e) {
      (t.prototype = Object.create(e.prototype)),
        (t.prototype.constructor = t),
        s(t, e);
    }
    function s(t, e) {
      return (s = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    n.r(i),
      n.d(i, "keyboardHandler", function () {
        return Wa;
      }),
      n.d(i, "mouseHandler", function () {
        return ja;
      }),
      n.d(i, "resizeHandler", function () {
        return Xa;
      }),
      n.d(i, "selectHandler", function () {
        return qa;
      }),
      n.d(i, "touchHandler", function () {
        return Ya;
      }),
      n.d(i, "wheelHandler", function () {
        return Ka;
      });
    var o = (function () {
        function t() {
          this._events = {};
        }
        var e = t.prototype;
        return (
          (e.on = function (t, e, n) {
            void 0 === n && (n = {}),
              this._events[t] || (this._events[t] = []),
              this._events[t].push({
                callback: e,
                options: n,
              });
          }),
          (e.off = function (t, e) {
            this._events[t] = e
              ? this._events[t].filter(function (t) {
                  return t.callback !== e;
                })
              : [];
          }),
          (e.trigger = function (t) {
            var e = arguments,
              n = this;
            this._events[t] &&
              this._events[t].forEach(function (i) {
                var r;
                (r = i.callback).call.apply(r, [n].concat([].slice.call(e, 1))),
                  i.options.once && n.off(t, i.callback);
              });
          }),
          t
        );
      })(),
      a = (function (t) {
        function e(e) {
          var n;
          return (
            ((n = t.call(this) || this).options = Object.assign(
              {},
              {
                init: !0,
                define: null,
                waitFullLoad: !0,
              },
              e
            )),
            (n.store = new Map()),
            (n.registry = new Map()),
            n.options.define &&
              (n.defineAll(n.options.define), n.options.init && n.init()),
            n
          );
        }
        r(e, t);
        var n = e.prototype;
        return (
          (n.init = function () {
            try {
              var t = this,
                e = (function () {
                  if (
                    "interactive" === document.readyState ||
                    "complete" === document.readyState
                  )
                    return Promise.resolve(t.start()).then(function () {});
                  document.addEventListener(
                    "DOMContentLoaded",
                    function () {
                      return t.start();
                    },
                    {
                      once: !0,
                    }
                  );
                })();
              return Promise.resolve(
                e && e.then ? e.then(function () {}) : void 0
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.start = function () {
            try {
              var t = function () {
                  return Promise.resolve(e.executeAll("init")).then(
                    function () {
                      return Promise.resolve(e.executeAll("enter")).then(
                        function () {
                          return Promise.resolve(e.executeAll("complete")).then(
                            function () {}
                          );
                        }
                      );
                    }
                  );
                },
                e = this;
              e.registry.forEach(function (t, n) {
                t.assign
                  ? e.queryAll(t.assign).forEach(function (t) {
                      e.attach(n, t, null, !1);
                    })
                  : e.attach(n, null, null, !1);
              });
              var n = (function () {
                if (e.options.waitFullLoad)
                  return Promise.resolve(e.waitFullLoad()).then(function () {});
              })();
              return Promise.resolve(n && n.then ? n.then(t) : t());
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.refresh = function (t, e, n) {
            void 0 === t && (t = !0),
              void 0 === e && (e = !0),
              void 0 === n && (n = !0);
            try {
              var i = this,
                r = [];
              return (
                i.registry.forEach(function (s, o) {
                  var a = i.store.get(o);
                  (a &&
                    a.forEach(function (a, l) {
                      s.assign
                        ? n &&
                          a.el &&
                          !a.el.isConnected &&
                          r.push(i.detach(o, l, e))
                        : t && r.push(i.executeInstance(a, "refresh"));
                    }),
                  s.assign) &&
                    i.queryAll(s.assign).forEach(function (e) {
                      var n =
                        a &&
                        a.filter(function (t) {
                          return t.el && e.isSameNode(t.el);
                        })[0];
                      n
                        ? t && r.push(i.executeInstance(n, "refresh"))
                        : r.push(i.attach(o, e));
                    });
                }),
                t && i.trigger("refresh"),
                Promise.all(r)
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.executeAll = function (t) {
            try {
              var e = this,
                n = [];
              return (
                e.trigger(t),
                e.store.forEach(function (i) {
                  i.forEach(function (i) {
                    return n.push(e.executeInstance(i, t));
                  });
                }),
                Promise.all(n)
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.executeInstance = function (t, e) {
            void 0 === e && (e = "init");
            try {
              var n = "on" + e.charAt(0).toUpperCase() + e.slice(1);
              return t[n]
                ? Promise.resolve((t._executors[e] = t[n]()))
                : Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.wait = function (t, e, n) {
            void 0 === e && (e = "init"), void 0 === n && (n = 0);
            try {
              return Promise.resolve(this.waitInstance(this.get(t, n), e));
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.waitAll = function (t, e) {
            void 0 === e && (e = "init");
            try {
              var n = this,
                i = [];
              return (
                n.store.forEach(function (t) {
                  t.forEach(function (t) {
                    return i.push(n.waitInstance(t, e));
                  });
                }),
                Promise.all(i)
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.waitInstance = function (t, e) {
            void 0 === e && (e = "init");
            try {
              return Promise.resolve(t._executors[e]);
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.waitFullLoad = function () {
            try {
              return Promise.resolve(
                new Promise(function (t) {
                  "complete" === document.readyState
                    ? t()
                    : window.addEventListener("load", function () {
                        return t();
                      });
                })
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.attach = function (t, e, n, i) {
            void 0 === i && (i = !0);
            try {
              var r = this,
                s = n || r.registry.get(t).options,
                o = new (0, r.registry.get(t).component)(r, e, s);
              r.store.has(t) || r.store.set(t, []),
                r.store.get(t).push(o),
                (o._namespace = t);
              var a = (function () {
                if (i)
                  return Promise.resolve(r.executeInstance(o, "init")).then(
                    function () {}
                  );
              })();
              return Promise.resolve(
                a && a.then
                  ? a.then(function () {
                      return o;
                    })
                  : o
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.detach = function (t, e, n) {
            void 0 === e && (e = 0), void 0 === n && (n = !0);
            try {
              var i = this,
                r = i.store.get(t).splice(e, 1)[0],
                s = (function () {
                  if (n)
                    return Promise.resolve(
                      i.executeInstance(r, "destroy")
                    ).then(function () {});
                })();
              return Promise.resolve(
                s && s.then
                  ? s.then(function () {
                      return r;
                    })
                  : r
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.define = function (t, e, n, i) {
            this.registry.set(t, {
              assign: n,
              component: e,
              options: i,
            });
          }),
          (n.defineAll = function (t) {
            var e = this;
            t.forEach(function (t) {
              e.define(t.namespace, t.component, t.assign, t.options);
            });
          }),
          (n.get = function (t, e) {
            void 0 === e && (e = 0);
            var n = this.store.get(t);
            return n ? n[e] : null;
          }),
          (n.getAll = function (t) {
            return this.store.get(t);
          }),
          (n.find = function (t, e, n) {
            void 0 === n && (n = 0);
            var i = this.findAll(t, e);
            return i ? i[n] : null;
          }),
          (n.findAll = function (t, e) {
            var n = e ? [this.store.get(e) || []] : this.store,
              i = [];
            return (
              n.forEach(function (e) {
                i.push.apply(
                  i,
                  e.filter(function (e) {
                    return (
                      e.el &&
                      ("string" == typeof t ? e.el.matches(t) : e.el === t)
                    );
                  })
                );
              }),
              i
            );
          }),
          (n.query = function (t) {
            return "string" == typeof t
              ? document.querySelector(t)
              : "object" == typeof t
              ? t
              : null;
          }),
          (n.queryAll = function (t) {
            return "string" == typeof t
              ? Array.from(document.querySelectorAll(t))
              : "object" == typeof t
              ? t
              : [];
          }),
          e
        );
      })(o),
      l = (function (t) {
        function e(e, n, i) {
          var r;
          return (
            ((r = t.call(this) || this).app = e),
            (r.el = n),
            (r.options = i),
            (r._namespace = null),
            (r._executors = {}),
            r
          );
        }
        r(e, t);
        var n = e.prototype;
        return (
          (n.onInit = function () {
            return Promise.resolve();
          }),
          (n.onRefresh = function () {
            return Promise.resolve();
          }),
          (n.onEnter = function () {
            return Promise.resolve();
          }),
          (n.onComplete = function () {
            return Promise.resolve();
          }),
          (n.onLeave = function () {
            return Promise.resolve();
          }),
          (n.onDestroy = function () {
            return Promise.resolve();
          }),
          (n.onLoading = function () {
            return Promise.resolve();
          }),
          (n.onLoaded = function () {
            return Promise.resolve();
          }),
          e
        );
      })(o),
      c = (function (t) {
        function e() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).options = Object.assign(
              {},
              {
                bindLinks: !0,
                bindHistory: !0,
                checkLinkUrlRegExp:
                  /(\?.*)?\/(?:|[^.]+(?:\.(?:htm|html|php)|))(?:\?.*|)$/,
                cleanUrlRegExp: /#.*/,
                checkResponseStatus: !0,
                history: "push",
                preventSame: !1,
                preventRunning: !1,
                parserType: "text/html",
                scrollRestoration: "manual",
                updateSelectors: ["title", "meta", "#view-main"],
                extendNodes: !1,
                removeNodes: !0,
                detachNodes: !0,
                resetScroll: !0,
                fireLeave: !0,
                fireLoading: !0,
                fireLoaded: !0,
                fireRefresh: !0,
                fireEnter: !0,
                fireComplete: !0,
                fireDestroy: !0,
                fetch: {},
              },
              e.options
            )),
            (e.event = {}),
            (e.parser = new DOMParser()),
            (e.running = !1),
            e.options.scrollRestoration &&
              (window.history.scrollRestoration = e.options.scrollRestoration),
            e.options.bindLinks && e.bindLinks(),
            e.options.bindHistory && e.bindHistory(),
            e
          );
        }
        r(e, t);
        var n = e.prototype;
        return (
          (n.bindLinks = function () {
            var t = this;
            document.addEventListener("click", function (e) {
              if (!(e.ctrlKey || e.shiftKey || e.altKey || e.metaKey))
                for (var n = e.target; n && n !== document; n = n.parentNode)
                  if (t.checkLink(n)) {
                    e.preventDefault(), t.goTo(n.href);
                    break;
                  }
            });
          }),
          (n.checkLink = function (t) {
            if ("A" !== t.tagName || !t.href || t.host !== window.location.host)
              return !1;
            if (t.getAttribute("target") || t.getAttribute("download"))
              return !1;
            if (this.options.checkLinkUrlRegExp) {
              var e = t.href.match(this.options.checkLinkUrlRegExp);
              if (!e || e[1]) return !1;
            }
            return !0;
          }),
          (n.bindHistory = function () {
            var t = this;
            (this.event.popstate = function () {
              return t.goTo(window.location.pathname, {
                history: !1,
              });
            }),
              window.addEventListener("popstate", this.event.popstate);
          }),
          (n.pushHistory = function (t, e) {
            void 0 === e && (e = "push"),
              window.history["push" === e ? "pushState" : "replaceState"](
                {},
                "",
                t
              );
          }),
          (n.replaceNodesBySelector = function (t, e, n, i) {
            void 0 === n && (n = !0), void 0 === i && (i = !1);
            var r = document.querySelectorAll(t),
              s = e.querySelectorAll(t);
            r.forEach(function (t, e) {
              s[e]
                ? i
                  ? t.append.apply(t, s[e].childNodes)
                  : t.replaceWith(s[e])
                : n && t.remove();
            });
          }),
          (n.goTo = function (t, e) {
            try {
              var n = function () {
                  function t() {
                    return Promise.resolve(i.executeRequest()).then(
                      function () {
                        function t() {
                          return Promise.resolve(
                            i.app.refresh(
                              i.reqOptions.fireRefresh,
                              i.reqOptions.fireDestroy,
                              i.reqOptions.detachNodes
                            )
                          ).then(function () {
                            function t() {
                              function t() {
                                i.running = !1;
                              }
                              var e = (function () {
                                if (i.reqOptions.fireComplete)
                                  return Promise.resolve(
                                    i.app.executeAll("complete")
                                  ).then(function () {});
                              })();
                              return e && e.then ? e.then(t) : t();
                            }
                            var e = (function () {
                              if (i.reqOptions.fireEnter)
                                return Promise.resolve(
                                  i.app.executeAll("enter")
                                ).then(function () {});
                            })();
                            return e && e.then ? e.then(t) : t();
                          });
                        }
                        var e = (function () {
                          if (i.reqOptions.fireLoaded)
                            return Promise.resolve(
                              i.app.executeAll("loaded")
                            ).then(function () {});
                        })();
                        return e && e.then ? e.then(t) : t();
                      }
                    );
                  }
                  var e = (function () {
                    if (i.reqOptions.fireLoading)
                      return Promise.resolve(i.app.executeAll("loading")).then(
                        function () {}
                      );
                  })();
                  return e && e.then ? e.then(t) : t();
                },
                i = this;
              if (
                ((i.reqOptions = Object.assign({}, i.options, e)),
                (i.reqOptions.url = t),
                (i.reqOptions.urlClean = i.reqOptions.url.replace(
                  i.reqOptions.cleanUrlRegExp,
                  ""
                )),
                (i.reqOptions.prevUrl = window.location.href),
                (i.reqOptions.prevUrlClean = i.reqOptions.prevUrl.replace(
                  i.reqOptions.cleanUrlRegExp,
                  ""
                )),
                i.reqOptions.preventSame &&
                  i.reqOptions.urlClean === i.reqOptions.prevUrlClean)
              )
                return Promise.resolve(!1);
              if (i.reqOptions.preventRunning && i.running)
                return Promise.resolve(!1);
              (i.running = !0),
                i.reqOptions.history &&
                  i.pushHistory(i.reqOptions.url, i.reqOptions.history);
              var r = (function () {
                if (i.reqOptions.fireLeave)
                  return Promise.resolve(i.app.executeAll("leave")).then(
                    function () {}
                  );
              })();
              return Promise.resolve(r && r.then ? r.then(n) : n());
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (n.executeRequest = function () {
            try {
              var t = this;
              return Promise.resolve(
                fetch(t.reqOptions.url, t.reqOptions.fetch)
              ).then(function (e) {
                if (
                  ((t.req = e), !t.reqOptions.checkResponseStatus || t.req.ok)
                )
                  return Promise.resolve(t.req.text()).then(function (e) {
                    (t.reqData = e),
                      (t.reqDocument = t.parser.parseFromString(
                        t.reqData,
                        t.reqOptions.parserType
                      )),
                      t.reqOptions.updateSelectors &&
                        t.reqOptions.updateSelectors.forEach(function (e) {
                          t.replaceNodesBySelector(
                            e,
                            t.reqDocument,
                            t.reqOptions.removeNodes,
                            t.reqOptions.extendNodes
                          );
                        }),
                      t.reqOptions.resetScroll && window.scrollTo(0, 0);
                  });
                window.location.assign(t.reqOptions.url);
              });
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          e
        );
      })(l);
    function u(t) {
      if (void 0 === t)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return t;
    }
    function h(t, e) {
      (t.prototype = Object.create(e.prototype)),
        (t.prototype.constructor = t),
        (t.__proto__ = e);
    }
    /*!
     * GSAP 3.12.2
     * https://greensock.com
     *
     * @license Copyright 2008-2023, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var d,
      p,
      f,
      m,
      g,
      v,
      _,
      y,
      x,
      b,
      S,
      E,
      M,
      T,
      w,
      D = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
          lineHeight: "",
        },
      },
      A = {
        duration: 0.5,
        overwrite: !1,
        delay: 0,
      },
      C = 1e8,
      P = 2 * Math.PI,
      R = P / 4,
      L = 0,
      O = Math.sqrt,
      I = Math.cos,
      F = Math.sin,
      U = function (t) {
        return "string" == typeof t;
      },
      N = function (t) {
        return "function" == typeof t;
      },
      k = function (t) {
        return "number" == typeof t;
      },
      z = function (t) {
        return void 0 === t;
      },
      B = function (t) {
        return "object" == typeof t;
      },
      H = function (t) {
        return !1 !== t;
      },
      V = function () {
        return "undefined" != typeof window;
      },
      G = function (t) {
        return N(t) || U(t);
      },
      W =
        ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
        function () {},
      j = Array.isArray,
      X = /(?:-?\.?\d|\.)+/gi,
      q = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
      Y = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
      K = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
      Z = /[+-]=-?[.\d]+/,
      J = /[^,'"\[\]\s]+/gi,
      $ = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
      Q = {},
      tt = {},
      et = function (t) {
        return (tt = Pt(t, Q)) && Pn;
      },
      nt = function (t, e) {
        return console.warn(
          "Invalid property",
          t,
          "set to",
          e,
          "Missing plugin? gsap.registerPlugin()"
        );
      },
      it = function (t, e) {
        return !e && console.warn(t);
      },
      rt = function (t, e) {
        return (t && (Q[t] = e) && tt && (tt[t] = e)) || Q;
      },
      st = function () {
        return 0;
      },
      ot = {
        suppressEvents: !0,
        isStart: !0,
        kill: !1,
      },
      at = {
        suppressEvents: !0,
        kill: !1,
      },
      lt = {
        suppressEvents: !0,
      },
      ct = {},
      ut = [],
      ht = {},
      dt = {},
      pt = {},
      ft = 30,
      mt = [],
      gt = "",
      vt = function (t) {
        var e,
          n,
          i = t[0];
        if ((B(i) || N(i) || (t = [t]), !(e = (i._gsap || {}).harness))) {
          for (n = mt.length; n-- && !mt[n].targetTest(i); );
          e = mt[n];
        }
        for (n = t.length; n--; )
          (t[n] && (t[n]._gsap || (t[n]._gsap = new Ge(t[n], e)))) ||
            t.splice(n, 1);
        return t;
      },
      _t = function (t) {
        return t._gsap || vt(ae(t))[0]._gsap;
      },
      yt = function (t, e, n) {
        return (n = t[e]) && N(n)
          ? t[e]()
          : (z(n) && t.getAttribute && t.getAttribute(e)) || n;
      },
      xt = function (t, e) {
        return (t = t.split(",")).forEach(e) || t;
      },
      bt = function (t) {
        return Math.round(1e5 * t) / 1e5 || 0;
      },
      St = function (t) {
        return Math.round(1e7 * t) / 1e7 || 0;
      },
      Et = function (t, e) {
        var n = e.charAt(0),
          i = parseFloat(e.substr(2));
        return (
          (t = parseFloat(t)),
          "+" === n ? t + i : "-" === n ? t - i : "*" === n ? t * i : t / i
        );
      },
      Mt = function (t, e) {
        for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n; );
        return i < n;
      },
      Tt = function () {
        var t,
          e,
          n = ut.length,
          i = ut.slice(0);
        for (ht = {}, ut.length = 0, t = 0; t < n; t++)
          (e = i[t]) &&
            e._lazy &&
            (e.render(e._lazy[0], e._lazy[1], !0)._lazy = 0);
      },
      wt = function (t, e, n, i) {
        ut.length && !p && Tt(),
          t.render(e, n, i || (p && e < 0 && (t._initted || t._startAt))),
          ut.length && !p && Tt();
      },
      Dt = function (t) {
        var e = parseFloat(t);
        return (e || 0 === e) && (t + "").match(J).length < 2
          ? e
          : U(t)
          ? t.trim()
          : t;
      },
      At = function (t) {
        return t;
      },
      Ct = function (t, e) {
        for (var n in e) n in t || (t[n] = e[n]);
        return t;
      },
      Pt = function (t, e) {
        for (var n in e) t[n] = e[n];
        return t;
      },
      Rt = function t(e, n) {
        for (var i in n)
          "__proto__" !== i &&
            "constructor" !== i &&
            "prototype" !== i &&
            (e[i] = B(n[i]) ? t(e[i] || (e[i] = {}), n[i]) : n[i]);
        return e;
      },
      Lt = function (t, e) {
        var n,
          i = {};
        for (n in t) n in e || (i[n] = t[n]);
        return i;
      },
      Ot = function (t) {
        var e,
          n = t.parent || m,
          i = t.keyframes
            ? ((e = j(t.keyframes)),
              function (t, n) {
                for (var i in n)
                  i in t ||
                    ("duration" === i && e) ||
                    "ease" === i ||
                    (t[i] = n[i]);
              })
            : Ct;
        if (H(t.inherit))
          for (; n; ) i(t, n.vars.defaults), (n = n.parent || n._dp);
        return t;
      },
      It = function (t, e, n, i, r) {
        void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
        var s,
          o = t[i];
        if (r) for (s = e[r]; o && o[r] > s; ) o = o._prev;
        return (
          o
            ? ((e._next = o._next), (o._next = e))
            : ((e._next = t[n]), (t[n] = e)),
          e._next ? (e._next._prev = e) : (t[i] = e),
          (e._prev = o),
          (e.parent = e._dp = t),
          e
        );
      },
      Ft = function (t, e, n, i) {
        void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
        var r = e._prev,
          s = e._next;
        r ? (r._next = s) : t[n] === e && (t[n] = s),
          s ? (s._prev = r) : t[i] === e && (t[i] = r),
          (e._next = e._prev = e.parent = null);
      },
      Ut = function (t, e) {
        t.parent &&
          (!e || t.parent.autoRemoveChildren) &&
          t.parent.remove &&
          t.parent.remove(t),
          (t._act = 0);
      },
      Nt = function (t, e) {
        if (t && (!e || e._end > t._dur || e._start < 0))
          for (var n = t; n; ) (n._dirty = 1), (n = n.parent);
        return t;
      },
      kt = function (t) {
        for (var e = t.parent; e && e.parent; )
          (e._dirty = 1), e.totalDuration(), (e = e.parent);
        return t;
      },
      zt = function (t, e, n, i) {
        return (
          t._startAt &&
          (p
            ? t._startAt.revert(at)
            : (t.vars.immediateRender && !t.vars.autoRevert) ||
              t._startAt.render(e, !0, i))
        );
      },
      Bt = function (t) {
        return t._repeat ? Ht(t._tTime, (t = t.duration() + t._rDelay)) * t : 0;
      },
      Ht = function (t, e) {
        var n = Math.floor((t /= e));
        return t && n === t ? n - 1 : n;
      },
      Vt = function (t, e) {
        return (
          (t - e._start) * e._ts +
          (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
        );
      },
      Gt = function (t) {
        return (t._end = St(
          t._start + (t._tDur / Math.abs(t._ts || t._rts || 1e-8) || 0)
        ));
      },
      Wt = function (t, e) {
        var n = t._dp;
        return (
          n &&
            n.smoothChildTiming &&
            t._ts &&
            ((t._start = St(
              n._time -
                (t._ts > 0
                  ? e / t._ts
                  : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)
            )),
            Gt(t),
            n._dirty || Nt(n, t)),
          t
        );
      },
      jt = function (t, e) {
        var n;
        if (
          ((e._time ||
            (!e._dur && e._initted) ||
            (e._start < t._time && (e._dur || !e.add))) &&
            ((n = Vt(t.rawTime(), e)),
            (!e._dur || ne(0, e.totalDuration(), n) - e._tTime > 1e-8) &&
              e.render(n, !0)),
          Nt(t, e)._dp && t._initted && t._time >= t._dur && t._ts)
        ) {
          if (t._dur < t.duration())
            for (n = t; n._dp; )
              n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
          t._zTime = -1e-8;
        }
      },
      Xt = function (t, e, n, i) {
        return (
          e.parent && Ut(e),
          (e._start = St(
            (k(n) ? n : n || t !== m ? Qt(t, n, e) : t._time) + e._delay
          )),
          (e._end = St(
            e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)
          )),
          It(t, e, "_first", "_last", t._sort ? "_start" : 0),
          Kt(e) || (t._recent = e),
          i || jt(t, e),
          t._ts < 0 && Wt(t, t._tTime),
          t
        );
      },
      qt = function (t, e) {
        return (
          (Q.ScrollTrigger || nt("scrollTrigger", e)) &&
          Q.ScrollTrigger.create(e, t)
        );
      },
      Yt = function (t, e, n, i, r) {
        return (
          Je(t, e, r),
          t._initted
            ? !n &&
              t._pt &&
              !p &&
              ((t._dur && !1 !== t.vars.lazy) || (!t._dur && t.vars.lazy)) &&
              x !== Pe.frame
              ? (ut.push(t), (t._lazy = [r, i]), 1)
              : void 0
            : 1
        );
      },
      Kt = function (t) {
        var e = t.data;
        return "isFromStart" === e || "isStart" === e;
      },
      Zt = function (t, e, n, i) {
        var r = t._repeat,
          s = St(e) || 0,
          o = t._tTime / t._tDur;
        return (
          o && !i && (t._time *= s / t._dur),
          (t._dur = s),
          (t._tDur = r ? (r < 0 ? 1e10 : St(s * (r + 1) + t._rDelay * r)) : s),
          o > 0 && !i && Wt(t, (t._tTime = t._tDur * o)),
          t.parent && Gt(t),
          n || Nt(t.parent, t),
          t
        );
      },
      Jt = function (t) {
        return t instanceof je ? Nt(t) : Zt(t, t._dur);
      },
      $t = {
        _start: 0,
        endTime: st,
        totalDuration: st,
      },
      Qt = function t(e, n, i) {
        var r,
          s,
          o,
          a = e.labels,
          l = e._recent || $t,
          c = e.duration() >= C ? l.endTime(!1) : e._dur;
        return U(n) && (isNaN(n) || n in a)
          ? ((s = n.charAt(0)),
            (o = "%" === n.substr(-1)),
            (r = n.indexOf("=")),
            "<" === s || ">" === s
              ? (r >= 0 && (n = n.replace(/=/, "")),
                ("<" === s ? l._start : l.endTime(l._repeat >= 0)) +
                  (parseFloat(n.substr(1)) || 0) *
                    (o ? (r < 0 ? l : i).totalDuration() / 100 : 1))
              : r < 0
              ? (n in a || (a[n] = c), a[n])
              : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
                o && i && (s = (s / 100) * (j(i) ? i[0] : i).totalDuration()),
                r > 1 ? t(e, n.substr(0, r - 1), i) + s : c + s))
          : null == n
          ? c
          : +n;
      },
      te = function (t, e, n) {
        var i,
          r,
          s = k(e[1]),
          o = (s ? 2 : 1) + (t < 2 ? 0 : 1),
          a = e[o];
        if ((s && (a.duration = e[1]), (a.parent = n), t)) {
          for (i = a, r = n; r && !("immediateRender" in i); )
            (i = r.vars.defaults || {}), (r = H(r.vars.inherit) && r.parent);
          (a.immediateRender = H(i.immediateRender)),
            t < 2 ? (a.runBackwards = 1) : (a.startAt = e[o - 1]);
        }
        return new nn(e[0], a, e[o + 1]);
      },
      ee = function (t, e) {
        return t || 0 === t ? e(t) : e;
      },
      ne = function (t, e, n) {
        return n < t ? t : n > e ? e : n;
      },
      ie = function (t, e) {
        return U(t) && (e = $.exec(t)) ? e[1] : "";
      },
      re = [].slice,
      se = function (t, e) {
        return (
          t &&
          B(t) &&
          "length" in t &&
          ((!e && !t.length) || (t.length - 1 in t && B(t[0]))) &&
          !t.nodeType &&
          t !== g
        );
      },
      oe = function (t, e, n) {
        return (
          void 0 === n && (n = []),
          t.forEach(function (t) {
            var i;
            return (U(t) && !e) || se(t, 1)
              ? (i = n).push.apply(i, ae(t))
              : n.push(t);
          }) || n
        );
      },
      ae = function (t, e, n) {
        return f && !e && f.selector
          ? f.selector(t)
          : !U(t) || n || (!v && Re())
          ? j(t)
            ? oe(t, n)
            : se(t)
            ? re.call(t, 0)
            : t
            ? [t]
            : []
          : re.call((e || _).querySelectorAll(t), 0);
      },
      le = function (t) {
        return (
          (t = ae(t)[0] || it("Invalid scope") || {}),
          function (e) {
            var n = t.current || t.nativeElement || t;
            return ae(
              e,
              n.querySelectorAll
                ? n
                : n === t
                ? it("Invalid scope") || _.createElement("div")
                : t
            );
          }
        );
      },
      ce = function (t) {
        return t.sort(function () {
          return 0.5 - Math.random();
        });
      },
      ue = function (t) {
        if (N(t)) return t;
        var e = B(t)
            ? t
            : {
                each: t,
              },
          n = ke(e.ease),
          i = e.from || 0,
          r = parseFloat(e.base) || 0,
          s = {},
          o = i > 0 && i < 1,
          a = isNaN(i) || o,
          l = e.axis,
          c = i,
          u = i;
        return (
          U(i)
            ? (c = u =
                {
                  center: 0.5,
                  edges: 0.5,
                  end: 1,
                }[i] || 0)
            : !o && a && ((c = i[0]), (u = i[1])),
          function (t, o, h) {
            var d,
              p,
              f,
              m,
              g,
              v,
              _,
              y,
              x,
              b = (h || e).length,
              S = s[b];
            if (!S) {
              if (!(x = "auto" === e.grid ? 0 : (e.grid || [1, C])[1])) {
                for (
                  _ = -C;
                  _ < (_ = h[x++].getBoundingClientRect().left) && x < b;

                );
                x--;
              }
              for (
                S = s[b] = [],
                  d = a ? Math.min(x, b) * c - 0.5 : i % x,
                  p = x === C ? 0 : a ? (b * u) / x - 0.5 : (i / x) | 0,
                  _ = 0,
                  y = C,
                  v = 0;
                v < b;
                v++
              )
                (f = (v % x) - d),
                  (m = p - ((v / x) | 0)),
                  (S[v] = g =
                    l ? Math.abs("y" === l ? m : f) : O(f * f + m * m)),
                  g > _ && (_ = g),
                  g < y && (y = g);
              "random" === i && ce(S),
                (S.max = _ - y),
                (S.min = y),
                (S.v = b =
                  (parseFloat(e.amount) ||
                    parseFloat(e.each) *
                      (x > b
                        ? b - 1
                        : l
                        ? "y" === l
                          ? b / x
                          : x
                        : Math.max(x, b / x)) ||
                    0) * ("edges" === i ? -1 : 1)),
                (S.b = b < 0 ? r - b : r),
                (S.u = ie(e.amount || e.each) || 0),
                (n = n && b < 0 ? Ue(n) : n);
            }
            return (
              (b = (S[t] - S.min) / S.max || 0),
              St(S.b + (n ? n(b) : b) * S.v) + S.u
            );
          }
        );
      },
      he = function (t) {
        var e = Math.pow(10, ((t + "").split(".")[1] || "").length);
        return function (n) {
          var i = St(Math.round(parseFloat(n) / t) * t * e);
          return (i - (i % 1)) / e + (k(n) ? 0 : ie(n));
        };
      },
      de = function (t, e) {
        var n,
          i,
          r = j(t);
        return (
          !r &&
            B(t) &&
            ((n = r = t.radius || C),
            t.values
              ? ((t = ae(t.values)), (i = !k(t[0])) && (n *= n))
              : (t = he(t.increment))),
          ee(
            e,
            r
              ? N(t)
                ? function (e) {
                    return (i = t(e)), Math.abs(i - e) <= n ? i : e;
                  }
                : function (e) {
                    for (
                      var r,
                        s,
                        o = parseFloat(i ? e.x : e),
                        a = parseFloat(i ? e.y : 0),
                        l = C,
                        c = 0,
                        u = t.length;
                      u--;

                    )
                      (r = i
                        ? (r = t[u].x - o) * r + (s = t[u].y - a) * s
                        : Math.abs(t[u] - o)) < l && ((l = r), (c = u));
                    return (
                      (c = !n || l <= n ? t[c] : e),
                      i || c === e || k(e) ? c : c + ie(e)
                    );
                  }
              : he(t)
          )
        );
      },
      pe = function (t, e, n, i) {
        return ee(j(t) ? !e : !0 === n ? !!(n = 0) : !i, function () {
          return j(t)
            ? t[~~(Math.random() * t.length)]
            : (n = n || 1e-5) &&
                (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                Math.floor(
                  Math.round(
                    (t - n / 2 + Math.random() * (e - t + 0.99 * n)) / n
                  ) *
                    n *
                    i
                ) / i;
        });
      },
      fe = function (t, e, n) {
        return ee(n, function (n) {
          return t[~~e(n)];
        });
      },
      me = function (t) {
        for (var e, n, i, r, s = 0, o = ""; ~(e = t.indexOf("random(", s)); )
          (i = t.indexOf(")", e)),
            (r = "[" === t.charAt(e + 7)),
            (n = t.substr(e + 7, i - e - 7).match(r ? J : X)),
            (o +=
              t.substr(s, e - s) +
              pe(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
            (s = i + 1);
        return o + t.substr(s, t.length - s);
      },
      ge = function (t, e, n, i, r) {
        var s = e - t,
          o = i - n;
        return ee(r, function (e) {
          return n + (((e - t) / s) * o || 0);
        });
      },
      ve = function (t, e, n) {
        var i,
          r,
          s,
          o = t.labels,
          a = C;
        for (i in o)
          (r = o[i] - e) < 0 == !!n &&
            r &&
            a > (r = Math.abs(r)) &&
            ((s = i), (a = r));
        return s;
      },
      _e = function (t, e, n) {
        var i,
          r,
          s,
          o = t.vars,
          a = o[e],
          l = f,
          c = t._ctx;
        if (a)
          return (
            (i = o[e + "Params"]),
            (r = o.callbackScope || t),
            n && ut.length && Tt(),
            c && (f = c),
            (s = i ? a.apply(r, i) : a.call(r)),
            (f = l),
            s
          );
      },
      ye = function (t) {
        return (
          Ut(t),
          t.scrollTrigger && t.scrollTrigger.kill(!!p),
          t.progress() < 1 && _e(t, "onInterrupt"),
          t
        );
      },
      xe = [],
      be = function (t) {
        if (V() && t) {
          var e = (t = (!t.name && t.default) || t).name,
            n = N(t),
            i =
              e && !n && t.init
                ? function () {
                    this._props = [];
                  }
                : t,
            r = {
              init: st,
              render: dn,
              add: Ke,
              kill: fn,
              modifier: pn,
              rawVars: 0,
            },
            s = {
              targetTest: 0,
              get: 0,
              getSetter: ln,
              aliases: {},
              register: 0,
            };
          if ((Re(), t !== i)) {
            if (dt[e]) return;
            Ct(i, Ct(Lt(t, r), s)),
              Pt(i.prototype, Pt(r, Lt(t, s))),
              (dt[(i.prop = e)] = i),
              t.targetTest && (mt.push(i), (ct[e] = 1)),
              (e =
                ("css" === e
                  ? "CSS"
                  : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin");
          }
          rt(e, i), t.register && t.register(Pn, i, vn);
        } else t && xe.push(t);
      },
      Se = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0],
      },
      Ee = function (t, e, n) {
        return (
          (255 *
            (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1
              ? e + (n - e) * t * 6
              : t < 0.5
              ? n
              : 3 * t < 2
              ? e + (n - e) * (2 / 3 - t) * 6
              : e) +
            0.5) |
          0
        );
      },
      Me = function (t, e, n) {
        var i,
          r,
          s,
          o,
          a,
          l,
          c,
          u,
          h,
          d,
          p = t ? (k(t) ? [t >> 16, (t >> 8) & 255, 255 & t] : 0) : Se.black;
        if (!p) {
          if (("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Se[t]))
            p = Se[t];
          else if ("#" === t.charAt(0)) {
            if (
              (t.length < 6 &&
                ((i = t.charAt(1)),
                (r = t.charAt(2)),
                (s = t.charAt(3)),
                (t =
                  "#" +
                  i +
                  i +
                  r +
                  r +
                  s +
                  s +
                  (5 === t.length ? t.charAt(4) + t.charAt(4) : ""))),
              9 === t.length)
            )
              return [
                (p = parseInt(t.substr(1, 6), 16)) >> 16,
                (p >> 8) & 255,
                255 & p,
                parseInt(t.substr(7), 16) / 255,
              ];
            p = [
              (t = parseInt(t.substr(1), 16)) >> 16,
              (t >> 8) & 255,
              255 & t,
            ];
          } else if ("hsl" === t.substr(0, 3))
            if (((p = d = t.match(X)), e)) {
              if (~t.indexOf("="))
                return (p = t.match(q)), n && p.length < 4 && (p[3] = 1), p;
            } else
              (o = (+p[0] % 360) / 360),
                (a = +p[1] / 100),
                (i =
                  2 * (l = +p[2] / 100) -
                  (r = l <= 0.5 ? l * (a + 1) : l + a - l * a)),
                p.length > 3 && (p[3] *= 1),
                (p[0] = Ee(o + 1 / 3, i, r)),
                (p[1] = Ee(o, i, r)),
                (p[2] = Ee(o - 1 / 3, i, r));
          else p = t.match(X) || Se.transparent;
          p = p.map(Number);
        }
        return (
          e &&
            !d &&
            ((i = p[0] / 255),
            (r = p[1] / 255),
            (s = p[2] / 255),
            (l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
            c === u
              ? (o = a = 0)
              : ((h = c - u),
                (a = l > 0.5 ? h / (2 - c - u) : h / (c + u)),
                (o =
                  c === i
                    ? (r - s) / h + (r < s ? 6 : 0)
                    : c === r
                    ? (s - i) / h + 2
                    : (i - r) / h + 4),
                (o *= 60)),
            (p[0] = ~~(o + 0.5)),
            (p[1] = ~~(100 * a + 0.5)),
            (p[2] = ~~(100 * l + 0.5))),
          n && p.length < 4 && (p[3] = 1),
          p
        );
      },
      Te = function (t) {
        var e = [],
          n = [],
          i = -1;
        return (
          t.split(De).forEach(function (t) {
            var r = t.match(Y) || [];
            e.push.apply(e, r), n.push((i += r.length + 1));
          }),
          (e.c = n),
          e
        );
      },
      we = function (t, e, n) {
        var i,
          r,
          s,
          o,
          a = "",
          l = (t + a).match(De),
          c = e ? "hsla(" : "rgba(",
          u = 0;
        if (!l) return t;
        if (
          ((l = l.map(function (t) {
            return (
              (t = Me(t, e, 1)) &&
              c +
                (e
                  ? t[0] + "," + t[1] + "%," + t[2] + "%," + t[3]
                  : t.join(",")) +
                ")"
            );
          })),
          n && ((s = Te(t)), (i = n.c).join(a) !== s.c.join(a)))
        )
          for (o = (r = t.replace(De, "1").split(Y)).length - 1; u < o; u++)
            a +=
              r[u] +
              (~i.indexOf(u)
                ? l.shift() || c + "0,0,0,0)"
                : (s.length ? s : l.length ? l : n).shift());
        if (!r)
          for (o = (r = t.split(De)).length - 1; u < o; u++) a += r[u] + l[u];
        return a + r[o];
      },
      De = (function () {
        var t,
          e =
            "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
        for (t in Se) e += "|" + t + "\\b";
        return new RegExp(e + ")", "gi");
      })(),
      Ae = /hsl[a]?\(/,
      Ce = function (t) {
        var e,
          n = t.join(" ");
        if (((De.lastIndex = 0), De.test(n)))
          return (
            (e = Ae.test(n)),
            (t[1] = we(t[1], e)),
            (t[0] = we(t[0], e, Te(t[1]))),
            !0
          );
      },
      Pe = (function () {
        var t,
          e,
          n,
          i,
          r,
          s,
          o = Date.now,
          a = 500,
          l = 33,
          c = o(),
          u = c,
          h = 1e3 / 240,
          d = h,
          p = [],
          f = function n(f) {
            var m,
              g,
              v,
              _,
              y = o() - u,
              x = !0 === f;
            if (
              (y > a && (c += y - l),
              ((m = (v = (u += y) - c) - d) > 0 || x) &&
                ((_ = ++i.frame),
                (r = v - 1e3 * i.time),
                (i.time = v /= 1e3),
                (d += m + (m >= h ? 4 : h - m)),
                (g = 1)),
              x || (t = e(n)),
              g)
            )
              for (s = 0; s < p.length; s++) p[s](v, r, _, f);
          };
        return (i = {
          time: 0,
          frame: 0,
          tick: function () {
            f(!0);
          },
          deltaRatio: function (t) {
            return r / (1e3 / (t || 60));
          },
          wake: function () {
            y &&
              (!v &&
                V() &&
                ((g = v = window),
                (_ = g.document || {}),
                (Q.gsap = Pn),
                (g.gsapVersions || (g.gsapVersions = [])).push(Pn.version),
                et(tt || g.GreenSockGlobals || (!g.gsap && g) || {}),
                (n = g.requestAnimationFrame),
                xe.forEach(be)),
              t && i.sleep(),
              (e =
                n ||
                function (t) {
                  return setTimeout(t, (d - 1e3 * i.time + 1) | 0);
                }),
              (S = 1),
              f(2));
          },
          sleep: function () {
            (n ? g.cancelAnimationFrame : clearTimeout)(t), (S = 0), (e = st);
          },
          lagSmoothing: function (t, e) {
            (a = t || 1 / 0), (l = Math.min(e || 33, a));
          },
          fps: function (t) {
            (h = 1e3 / (t || 240)), (d = 1e3 * i.time + h);
          },
          add: function (t, e, n) {
            var r = e
              ? function (e, n, s, o) {
                  t(e, n, s, o), i.remove(r);
                }
              : t;
            return i.remove(t), p[n ? "unshift" : "push"](r), Re(), r;
          },
          remove: function (t, e) {
            ~(e = p.indexOf(t)) && p.splice(e, 1) && s >= e && s--;
          },
          _listeners: p,
        });
      })(),
      Re = function () {
        return !S && Pe.wake();
      },
      Le = {},
      Oe = /^[\d.\-M][\d.\-,\s]/,
      Ie = /["']/g,
      Fe = function (t) {
        for (
          var e,
            n,
            i,
            r = {},
            s = t.substr(1, t.length - 3).split(":"),
            o = s[0],
            a = 1,
            l = s.length;
          a < l;
          a++
        )
          (n = s[a]),
            (e = a !== l - 1 ? n.lastIndexOf(",") : n.length),
            (i = n.substr(0, e)),
            (r[o] = isNaN(i) ? i.replace(Ie, "").trim() : +i),
            (o = n.substr(e + 1).trim());
        return r;
      },
      Ue = function (t) {
        return function (e) {
          return 1 - t(1 - e);
        };
      },
      Ne = function t(e, n) {
        for (var i, r = e._first; r; )
          r instanceof je
            ? t(r, n)
            : !r.vars.yoyoEase ||
              (r._yoyo && r._repeat) ||
              r._yoyo === n ||
              (r.timeline
                ? t(r.timeline, n)
                : ((i = r._ease),
                  (r._ease = r._yEase),
                  (r._yEase = i),
                  (r._yoyo = n))),
            (r = r._next);
      },
      ke = function (t, e) {
        return (
          (t &&
            (N(t)
              ? t
              : Le[t] ||
                (function (t) {
                  var e,
                    n,
                    i,
                    r,
                    s = (t + "").split("("),
                    o = Le[s[0]];
                  return o && s.length > 1 && o.config
                    ? o.config.apply(
                        null,
                        ~t.indexOf("{")
                          ? [Fe(s[1])]
                          : ((e = t),
                            (n = e.indexOf("(") + 1),
                            (i = e.indexOf(")")),
                            (r = e.indexOf("(", n)),
                            e.substring(
                              n,
                              ~r && r < i ? e.indexOf(")", i + 1) : i
                            ))
                              .split(",")
                              .map(Dt)
                      )
                    : Le._CE && Oe.test(t)
                    ? Le._CE("", t)
                    : o;
                })(t))) ||
          e
        );
      },
      ze = function (t, e, n, i) {
        void 0 === n &&
          (n = function (t) {
            return 1 - e(1 - t);
          }),
          void 0 === i &&
            (i = function (t) {
              return t < 0.5 ? e(2 * t) / 2 : 1 - e(2 * (1 - t)) / 2;
            });
        var r,
          s = {
            easeIn: e,
            easeOut: n,
            easeInOut: i,
          };
        return (
          xt(t, function (t) {
            for (var e in ((Le[t] = Q[t] = s),
            (Le[(r = t.toLowerCase())] = n),
            s))
              Le[
                r +
                  ("easeIn" === e ? ".in" : "easeOut" === e ? ".out" : ".inOut")
              ] = Le[t + "." + e] = s[e];
          }),
          s
        );
      },
      Be = function (t) {
        return function (e) {
          return e < 0.5 ? (1 - t(1 - 2 * e)) / 2 : 0.5 + t(2 * (e - 0.5)) / 2;
        };
      },
      He = function t(e, n, i) {
        var r = n >= 1 ? n : 1,
          s = (i || (e ? 0.3 : 0.45)) / (n < 1 ? n : 1),
          o = (s / P) * (Math.asin(1 / r) || 0),
          a = function (t) {
            return 1 === t ? 1 : r * Math.pow(2, -10 * t) * F((t - o) * s) + 1;
          },
          l =
            "out" === e
              ? a
              : "in" === e
              ? function (t) {
                  return 1 - a(1 - t);
                }
              : Be(a);
        return (
          (s = P / s),
          (l.config = function (n, i) {
            return t(e, n, i);
          }),
          l
        );
      },
      Ve = function t(e, n) {
        void 0 === n && (n = 1.70158);
        var i = function (t) {
            return t ? --t * t * ((n + 1) * t + n) + 1 : 0;
          },
          r =
            "out" === e
              ? i
              : "in" === e
              ? function (t) {
                  return 1 - i(1 - t);
                }
              : Be(i);
        return (
          (r.config = function (n) {
            return t(e, n);
          }),
          r
        );
      };
    xt("Linear,Quad,Cubic,Quart,Quint,Strong", function (t, e) {
      var n = e < 5 ? e + 1 : e;
      ze(
        t + ",Power" + (n - 1),
        e
          ? function (t) {
              return Math.pow(t, n);
            }
          : function (t) {
              return t;
            },
        function (t) {
          return 1 - Math.pow(1 - t, n);
        },
        function (t) {
          return t < 0.5
            ? Math.pow(2 * t, n) / 2
            : 1 - Math.pow(2 * (1 - t), n) / 2;
        }
      );
    }),
      (Le.Linear.easeNone = Le.none = Le.Linear.easeIn),
      ze("Elastic", He("in"), He("out"), He()),
      (E = 7.5625),
      (T = 1 / (M = 2.75)),
      ze(
        "Bounce",
        function (t) {
          return 1 - w(1 - t);
        },
        (w = function (t) {
          return t < T
            ? E * t * t
            : t < 0.7272727272727273
            ? E * Math.pow(t - 1.5 / M, 2) + 0.75
            : t < 0.9090909090909092
            ? E * (t -= 2.25 / M) * t + 0.9375
            : E * Math.pow(t - 2.625 / M, 2) + 0.984375;
        })
      ),
      ze("Expo", function (t) {
        return t ? Math.pow(2, 10 * (t - 1)) : 0;
      }),
      ze("Circ", function (t) {
        return -(O(1 - t * t) - 1);
      }),
      ze("Sine", function (t) {
        return 1 === t ? 1 : 1 - I(t * R);
      }),
      ze("Back", Ve("in"), Ve("out"), Ve()),
      (Le.SteppedEase =
        Le.steps =
        Q.SteppedEase =
          {
            config: function (t, e) {
              void 0 === t && (t = 1);
              var n = 1 / t,
                i = t + (e ? 0 : 1),
                r = e ? 1 : 0;
              return function (t) {
                return (((i * ne(0, 1 - 1e-8, t)) | 0) + r) * n;
              };
            },
          }),
      (A.ease = Le["quad.out"]),
      xt(
        "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
        function (t) {
          return (gt += t + "," + t + "Params,");
        }
      );
    var Ge = function (t, e) {
        (this.id = L++),
          (t._gsap = this),
          (this.target = t),
          (this.harness = e),
          (this.get = e ? e.get : yt),
          (this.set = e ? e.getSetter : ln);
      },
      We = (function () {
        function t(t) {
          (this.vars = t),
            (this._delay = +t.delay || 0),
            (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
              ((this._rDelay = t.repeatDelay || 0),
              (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
            (this._ts = 1),
            Zt(this, +t.duration, 1, 1),
            (this.data = t.data),
            f && ((this._ctx = f), f.data.push(this)),
            S || Pe.wake();
        }
        var e = t.prototype;
        return (
          (e.delay = function (t) {
            return t || 0 === t
              ? (this.parent &&
                  this.parent.smoothChildTiming &&
                  this.startTime(this._start + t - this._delay),
                (this._delay = t),
                this)
              : this._delay;
          }),
          (e.duration = function (t) {
            return arguments.length
              ? this.totalDuration(
                  this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t
                )
              : this.totalDuration() && this._dur;
          }),
          (e.totalDuration = function (t) {
            return arguments.length
              ? ((this._dirty = 0),
                Zt(
                  this,
                  this._repeat < 0
                    ? t
                    : (t - this._repeat * this._rDelay) / (this._repeat + 1)
                ))
              : this._tDur;
          }),
          (e.totalTime = function (t, e) {
            if ((Re(), !arguments.length)) return this._tTime;
            var n = this._dp;
            if (n && n.smoothChildTiming && this._ts) {
              for (
                Wt(this, t), !n._dp || n.parent || jt(n, this);
                n && n.parent;

              )
                n.parent._time !==
                  n._start +
                    (n._ts >= 0
                      ? n._tTime / n._ts
                      : (n.totalDuration() - n._tTime) / -n._ts) &&
                  n.totalTime(n._tTime, !0),
                  (n = n.parent);
              !this.parent &&
                this._dp.autoRemoveChildren &&
                ((this._ts > 0 && t < this._tDur) ||
                  (this._ts < 0 && t > 0) ||
                  (!this._tDur && !t)) &&
                Xt(this._dp, this, this._start - this._delay);
            }
            return (
              (this._tTime !== t ||
                (!this._dur && !e) ||
                (this._initted && 1e-8 === Math.abs(this._zTime)) ||
                (!t && !this._initted && (this.add || this._ptLookup))) &&
                (this._ts || (this._pTime = t), wt(this, t, e)),
              this
            );
          }),
          (e.time = function (t, e) {
            return arguments.length
              ? this.totalTime(
                  Math.min(this.totalDuration(), t + Bt(this)) %
                    (this._dur + this._rDelay) || (t ? this._dur : 0),
                  e
                )
              : this._time;
          }),
          (e.totalProgress = function (t, e) {
            return arguments.length
              ? this.totalTime(this.totalDuration() * t, e)
              : this.totalDuration()
              ? Math.min(1, this._tTime / this._tDur)
              : this.ratio;
          }),
          (e.progress = function (t, e) {
            return arguments.length
              ? this.totalTime(
                  this.duration() *
                    (!this._yoyo || 1 & this.iteration() ? t : 1 - t) +
                    Bt(this),
                  e
                )
              : this.duration()
              ? Math.min(1, this._time / this._dur)
              : this.ratio;
          }),
          (e.iteration = function (t, e) {
            var n = this.duration() + this._rDelay;
            return arguments.length
              ? this.totalTime(this._time + (t - 1) * n, e)
              : this._repeat
              ? Ht(this._tTime, n) + 1
              : 1;
          }),
          (e.timeScale = function (t) {
            if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
            if (this._rts === t) return this;
            var e =
              this.parent && this._ts
                ? Vt(this.parent._time, this)
                : this._tTime;
            return (
              (this._rts = +t || 0),
              (this._ts = this._ps || -1e-8 === t ? 0 : this._rts),
              this.totalTime(ne(-Math.abs(this._delay), this._tDur, e), !0),
              Gt(this),
              kt(this)
            );
          }),
          (e.paused = function (t) {
            return arguments.length
              ? (this._ps !== t &&
                  ((this._ps = t),
                  t
                    ? ((this._pTime =
                        this._tTime || Math.max(-this._delay, this.rawTime())),
                      (this._ts = this._act = 0))
                    : (Re(),
                      (this._ts = this._rts),
                      this.totalTime(
                        this.parent && !this.parent.smoothChildTiming
                          ? this.rawTime()
                          : this._tTime || this._pTime,
                        1 === this.progress() &&
                          1e-8 !== Math.abs(this._zTime) &&
                          (this._tTime -= 1e-8)
                      ))),
                this)
              : this._ps;
          }),
          (e.startTime = function (t) {
            if (arguments.length) {
              this._start = t;
              var e = this.parent || this._dp;
              return (
                e && (e._sort || !this.parent) && Xt(e, this, t - this._delay),
                this
              );
            }
            return this._start;
          }),
          (e.endTime = function (t) {
            return (
              this._start +
              (H(t) ? this.totalDuration() : this.duration()) /
                Math.abs(this._ts || 1)
            );
          }),
          (e.rawTime = function (t) {
            var e = this.parent || this._dp;
            return e
              ? t &&
                (!this._ts ||
                  (this._repeat && this._time && this.totalProgress() < 1))
                ? this._tTime % (this._dur + this._rDelay)
                : this._ts
                ? Vt(e.rawTime(t), this)
                : this._tTime
              : this._tTime;
          }),
          (e.revert = function (t) {
            void 0 === t && (t = lt);
            var e = p;
            return (
              (p = t),
              (this._initted || this._startAt) &&
                (this.timeline && this.timeline.revert(t),
                this.totalTime(-0.01, t.suppressEvents)),
              "nested" !== this.data && !1 !== t.kill && this.kill(),
              (p = e),
              this
            );
          }),
          (e.globalTime = function (t) {
            for (var e = this, n = arguments.length ? t : e.rawTime(); e; )
              (n = e._start + n / (e._ts || 1)), (e = e._dp);
            return !this.parent && this._sat
              ? this._sat.vars.immediateRender
                ? -1 / 0
                : this._sat.globalTime(t)
              : n;
          }),
          (e.repeat = function (t) {
            return arguments.length
              ? ((this._repeat = t === 1 / 0 ? -2 : t), Jt(this))
              : -2 === this._repeat
              ? 1 / 0
              : this._repeat;
          }),
          (e.repeatDelay = function (t) {
            if (arguments.length) {
              var e = this._time;
              return (this._rDelay = t), Jt(this), e ? this.time(e) : this;
            }
            return this._rDelay;
          }),
          (e.yoyo = function (t) {
            return arguments.length ? ((this._yoyo = t), this) : this._yoyo;
          }),
          (e.seek = function (t, e) {
            return this.totalTime(Qt(this, t), H(e));
          }),
          (e.restart = function (t, e) {
            return this.play().totalTime(t ? -this._delay : 0, H(e));
          }),
          (e.play = function (t, e) {
            return null != t && this.seek(t, e), this.reversed(!1).paused(!1);
          }),
          (e.reverse = function (t, e) {
            return (
              null != t && this.seek(t || this.totalDuration(), e),
              this.reversed(!0).paused(!1)
            );
          }),
          (e.pause = function (t, e) {
            return null != t && this.seek(t, e), this.paused(!0);
          }),
          (e.resume = function () {
            return this.paused(!1);
          }),
          (e.reversed = function (t) {
            return arguments.length
              ? (!!t !== this.reversed() &&
                  this.timeScale(-this._rts || (t ? -1e-8 : 0)),
                this)
              : this._rts < 0;
          }),
          (e.invalidate = function () {
            return (this._initted = this._act = 0), (this._zTime = -1e-8), this;
          }),
          (e.isActive = function () {
            var t,
              e = this.parent || this._dp,
              n = this._start;
            return !(
              e &&
              !(
                this._ts &&
                this._initted &&
                e.isActive() &&
                (t = e.rawTime(!0)) >= n &&
                t < this.endTime(!0) - 1e-8
              )
            );
          }),
          (e.eventCallback = function (t, e, n) {
            var i = this.vars;
            return arguments.length > 1
              ? (e
                  ? ((i[t] = e),
                    n && (i[t + "Params"] = n),
                    "onUpdate" === t && (this._onUpdate = e))
                  : delete i[t],
                this)
              : i[t];
          }),
          (e.then = function (t) {
            var e = this;
            return new Promise(function (n) {
              var i = N(t) ? t : At,
                r = function () {
                  var t = e.then;
                  (e.then = null),
                    N(i) && (i = i(e)) && (i.then || i === e) && (e.then = t),
                    n(i),
                    (e.then = t);
                };
              (e._initted && 1 === e.totalProgress() && e._ts >= 0) ||
              (!e._tTime && e._ts < 0)
                ? r()
                : (e._prom = r);
            });
          }),
          (e.kill = function () {
            ye(this);
          }),
          t
        );
      })();
    Ct(We.prototype, {
      _time: 0,
      _start: 0,
      _end: 0,
      _tTime: 0,
      _tDur: 0,
      _dirty: 0,
      _repeat: 0,
      _yoyo: !1,
      parent: null,
      _initted: !1,
      _rDelay: 0,
      _ts: 1,
      _dp: 0,
      ratio: 0,
      _zTime: -1e-8,
      _prom: 0,
      _ps: !1,
      _rts: 1,
    });
    var je = (function (t) {
      function e(e, n) {
        var i;
        return (
          void 0 === e && (e = {}),
          ((i = t.call(this, e) || this).labels = {}),
          (i.smoothChildTiming = !!e.smoothChildTiming),
          (i.autoRemoveChildren = !!e.autoRemoveChildren),
          (i._sort = H(e.sortChildren)),
          m && Xt(e.parent || m, u(i), n),
          e.reversed && i.reverse(),
          e.paused && i.paused(!0),
          e.scrollTrigger && qt(u(i), e.scrollTrigger),
          i
        );
      }
      h(e, t);
      var n = e.prototype;
      return (
        (n.to = function (t, e, n) {
          return te(0, arguments, this), this;
        }),
        (n.from = function (t, e, n) {
          return te(1, arguments, this), this;
        }),
        (n.fromTo = function (t, e, n, i) {
          return te(2, arguments, this), this;
        }),
        (n.set = function (t, e, n) {
          return (
            (e.duration = 0),
            (e.parent = this),
            Ot(e).repeatDelay || (e.repeat = 0),
            (e.immediateRender = !!e.immediateRender),
            new nn(t, e, Qt(this, n), 1),
            this
          );
        }),
        (n.call = function (t, e, n) {
          return Xt(this, nn.delayedCall(0, t, e), n);
        }),
        (n.staggerTo = function (t, e, n, i, r, s, o) {
          return (
            (n.duration = e),
            (n.stagger = n.stagger || i),
            (n.onComplete = s),
            (n.onCompleteParams = o),
            (n.parent = this),
            new nn(t, n, Qt(this, r)),
            this
          );
        }),
        (n.staggerFrom = function (t, e, n, i, r, s, o) {
          return (
            (n.runBackwards = 1),
            (Ot(n).immediateRender = H(n.immediateRender)),
            this.staggerTo(t, e, n, i, r, s, o)
          );
        }),
        (n.staggerFromTo = function (t, e, n, i, r, s, o, a) {
          return (
            (i.startAt = n),
            (Ot(i).immediateRender = H(i.immediateRender)),
            this.staggerTo(t, e, i, r, s, o, a)
          );
        }),
        (n.render = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            f,
            g,
            v = this._time,
            _ = this._dirty ? this.totalDuration() : this._tDur,
            y = this._dur,
            x = t <= 0 ? 0 : St(t),
            b = this._zTime < 0 != t < 0 && (this._initted || !y);
          if (
            (this !== m && x > _ && t >= 0 && (x = _),
            x !== this._tTime || n || b)
          ) {
            if (
              (v !== this._time &&
                y &&
                ((x += this._time - v), (t += this._time - v)),
              (i = x),
              (h = this._start),
              (l = !(u = this._ts)),
              b && (y || (v = this._zTime), (t || !e) && (this._zTime = t)),
              this._repeat)
            ) {
              if (
                ((f = this._yoyo),
                (a = y + this._rDelay),
                this._repeat < -1 && t < 0)
              )
                return this.totalTime(100 * a + t, e, n);
              if (
                ((i = St(x % a)),
                x === _
                  ? ((o = this._repeat), (i = y))
                  : ((o = ~~(x / a)) && o === x / a && ((i = y), o--),
                    i > y && (i = y)),
                (d = Ht(this._tTime, a)),
                !v &&
                  this._tTime &&
                  d !== o &&
                  this._tTime - d * a - this._dur <= 0 &&
                  (d = o),
                f && 1 & o && ((i = y - i), (g = 1)),
                o !== d && !this._lock)
              ) {
                var S = f && 1 & d,
                  E = S === (f && 1 & o);
                if (
                  (o < d && (S = !S),
                  (v = S ? 0 : x % y ? y : x),
                  (this._lock = 1),
                  (this.render(v || (g ? 0 : St(o * a)), e, !y)._lock = 0),
                  (this._tTime = x),
                  !e && this.parent && _e(this, "onRepeat"),
                  this.vars.repeatRefresh &&
                    !g &&
                    (this.invalidate()._lock = 1),
                  (v && v !== this._time) ||
                    l !== !this._ts ||
                    (this.vars.onRepeat && !this.parent && !this._act))
                )
                  return this;
                if (
                  ((y = this._dur),
                  (_ = this._tDur),
                  E &&
                    ((this._lock = 2),
                    (v = S ? y : -1e-4),
                    this.render(v, !0),
                    this.vars.repeatRefresh && !g && this.invalidate()),
                  (this._lock = 0),
                  !this._ts && !l)
                )
                  return this;
                Ne(this, g);
              }
            }
            if (
              (this._hasPause &&
                !this._forcing &&
                this._lock < 2 &&
                (c = (function (t, e, n) {
                  var i;
                  if (n > e)
                    for (i = t._first; i && i._start <= n; ) {
                      if ("isPause" === i.data && i._start > e) return i;
                      i = i._next;
                    }
                  else
                    for (i = t._last; i && i._start >= n; ) {
                      if ("isPause" === i.data && i._start < e) return i;
                      i = i._prev;
                    }
                })(this, St(v), St(i))) &&
                (x -= i - (i = c._start)),
              (this._tTime = x),
              (this._time = i),
              (this._act = !u),
              this._initted ||
                ((this._onUpdate = this.vars.onUpdate),
                (this._initted = 1),
                (this._zTime = t),
                (v = 0)),
              !v && i && !e && !o && (_e(this, "onStart"), this._tTime !== x))
            )
              return this;
            if (i >= v && t >= 0)
              for (r = this._first; r; ) {
                if (
                  ((s = r._next), (r._act || i >= r._start) && r._ts && c !== r)
                ) {
                  if (r.parent !== this) return this.render(t, e, n);
                  if (
                    (r.render(
                      r._ts > 0
                        ? (i - r._start) * r._ts
                        : (r._dirty ? r.totalDuration() : r._tDur) +
                            (i - r._start) * r._ts,
                      e,
                      n
                    ),
                    i !== this._time || (!this._ts && !l))
                  ) {
                    (c = 0), s && (x += this._zTime = -1e-8);
                    break;
                  }
                }
                r = s;
              }
            else {
              r = this._last;
              for (var M = t < 0 ? t : i; r; ) {
                if (
                  ((s = r._prev), (r._act || M <= r._end) && r._ts && c !== r)
                ) {
                  if (r.parent !== this) return this.render(t, e, n);
                  if (
                    (r.render(
                      r._ts > 0
                        ? (M - r._start) * r._ts
                        : (r._dirty ? r.totalDuration() : r._tDur) +
                            (M - r._start) * r._ts,
                      e,
                      n || (p && (r._initted || r._startAt))
                    ),
                    i !== this._time || (!this._ts && !l))
                  ) {
                    (c = 0), s && (x += this._zTime = M ? -1e-8 : 1e-8);
                    break;
                  }
                }
                r = s;
              }
            }
            if (
              c &&
              !e &&
              (this.pause(),
              (c.render(i >= v ? 0 : -1e-8)._zTime = i >= v ? 1 : -1),
              this._ts)
            )
              return (this._start = h), Gt(this), this.render(t, e, n);
            this._onUpdate && !e && _e(this, "onUpdate", !0),
              ((x === _ && this._tTime >= this.totalDuration()) || (!x && v)) &&
                ((h !== this._start && Math.abs(u) === Math.abs(this._ts)) ||
                  this._lock ||
                  ((t || !y) &&
                    ((x === _ && this._ts > 0) || (!x && this._ts < 0)) &&
                    Ut(this, 1),
                  e ||
                    (t < 0 && !v) ||
                    (!x && !v && _) ||
                    (_e(
                      this,
                      x === _ && t >= 0 ? "onComplete" : "onReverseComplete",
                      !0
                    ),
                    this._prom &&
                      !(x < _ && this.timeScale() > 0) &&
                      this._prom())));
          }
          return this;
        }),
        (n.add = function (t, e) {
          var n = this;
          if ((k(e) || (e = Qt(this, e, t)), !(t instanceof We))) {
            if (j(t))
              return (
                t.forEach(function (t) {
                  return n.add(t, e);
                }),
                this
              );
            if (U(t)) return this.addLabel(t, e);
            if (!N(t)) return this;
            t = nn.delayedCall(0, t);
          }
          return this !== t ? Xt(this, t, e) : this;
        }),
        (n.getChildren = function (t, e, n, i) {
          void 0 === t && (t = !0),
            void 0 === e && (e = !0),
            void 0 === n && (n = !0),
            void 0 === i && (i = -C);
          for (var r = [], s = this._first; s; )
            s._start >= i &&
              (s instanceof nn
                ? e && r.push(s)
                : (n && r.push(s),
                  t && r.push.apply(r, s.getChildren(!0, e, n)))),
              (s = s._next);
          return r;
        }),
        (n.getById = function (t) {
          for (var e = this.getChildren(1, 1, 1), n = e.length; n--; )
            if (e[n].vars.id === t) return e[n];
        }),
        (n.remove = function (t) {
          return U(t)
            ? this.removeLabel(t)
            : N(t)
            ? this.killTweensOf(t)
            : (Ft(this, t),
              t === this._recent && (this._recent = this._last),
              Nt(this));
        }),
        (n.totalTime = function (e, n) {
          return arguments.length
            ? ((this._forcing = 1),
              !this._dp &&
                this._ts &&
                (this._start = St(
                  Pe.time -
                    (this._ts > 0
                      ? e / this._ts
                      : (this.totalDuration() - e) / -this._ts)
                )),
              t.prototype.totalTime.call(this, e, n),
              (this._forcing = 0),
              this)
            : this._tTime;
        }),
        (n.addLabel = function (t, e) {
          return (this.labels[t] = Qt(this, e)), this;
        }),
        (n.removeLabel = function (t) {
          return delete this.labels[t], this;
        }),
        (n.addPause = function (t, e, n) {
          var i = nn.delayedCall(0, e || st, n);
          return (
            (i.data = "isPause"), (this._hasPause = 1), Xt(this, i, Qt(this, t))
          );
        }),
        (n.removePause = function (t) {
          var e = this._first;
          for (t = Qt(this, t); e; )
            e._start === t && "isPause" === e.data && Ut(e), (e = e._next);
        }),
        (n.killTweensOf = function (t, e, n) {
          for (var i = this.getTweensOf(t, n), r = i.length; r--; )
            Xe !== i[r] && i[r].kill(t, e);
          return this;
        }),
        (n.getTweensOf = function (t, e) {
          for (var n, i = [], r = ae(t), s = this._first, o = k(e); s; )
            s instanceof nn
              ? Mt(s._targets, r) &&
                (o
                  ? (!Xe || (s._initted && s._ts)) &&
                    s.globalTime(0) <= e &&
                    s.globalTime(s.totalDuration()) > e
                  : !e || s.isActive()) &&
                i.push(s)
              : (n = s.getTweensOf(r, e)).length && i.push.apply(i, n),
              (s = s._next);
          return i;
        }),
        (n.tweenTo = function (t, e) {
          e = e || {};
          var n,
            i = this,
            r = Qt(i, t),
            s = e,
            o = s.startAt,
            a = s.onStart,
            l = s.onStartParams,
            c = s.immediateRender,
            u = nn.to(
              i,
              Ct(
                {
                  ease: e.ease || "none",
                  lazy: !1,
                  immediateRender: !1,
                  time: r,
                  overwrite: "auto",
                  duration:
                    e.duration ||
                    Math.abs(
                      (r - (o && "time" in o ? o.time : i._time)) /
                        i.timeScale()
                    ) ||
                    1e-8,
                  onStart: function () {
                    if ((i.pause(), !n)) {
                      var t =
                        e.duration ||
                        Math.abs(
                          (r - (o && "time" in o ? o.time : i._time)) /
                            i.timeScale()
                        );
                      u._dur !== t && Zt(u, t, 0, 1).render(u._time, !0, !0),
                        (n = 1);
                    }
                    a && a.apply(u, l || []);
                  },
                },
                e
              )
            );
          return c ? u.render(0) : u;
        }),
        (n.tweenFromTo = function (t, e, n) {
          return this.tweenTo(
            e,
            Ct(
              {
                startAt: {
                  time: Qt(this, t),
                },
              },
              n
            )
          );
        }),
        (n.recent = function () {
          return this._recent;
        }),
        (n.nextLabel = function (t) {
          return void 0 === t && (t = this._time), ve(this, Qt(this, t));
        }),
        (n.previousLabel = function (t) {
          return void 0 === t && (t = this._time), ve(this, Qt(this, t), 1);
        }),
        (n.currentLabel = function (t) {
          return arguments.length
            ? this.seek(t, !0)
            : this.previousLabel(this._time + 1e-8);
        }),
        (n.shiftChildren = function (t, e, n) {
          void 0 === n && (n = 0);
          for (var i, r = this._first, s = this.labels; r; )
            r._start >= n && ((r._start += t), (r._end += t)), (r = r._next);
          if (e) for (i in s) s[i] >= n && (s[i] += t);
          return Nt(this);
        }),
        (n.invalidate = function (e) {
          var n = this._first;
          for (this._lock = 0; n; ) n.invalidate(e), (n = n._next);
          return t.prototype.invalidate.call(this, e);
        }),
        (n.clear = function (t) {
          void 0 === t && (t = !0);
          for (var e, n = this._first; n; )
            (e = n._next), this.remove(n), (n = e);
          return (
            this._dp && (this._time = this._tTime = this._pTime = 0),
            t && (this.labels = {}),
            Nt(this)
          );
        }),
        (n.totalDuration = function (t) {
          var e,
            n,
            i,
            r = 0,
            s = this,
            o = s._last,
            a = C;
          if (arguments.length)
            return s.timeScale(
              (s._repeat < 0 ? s.duration() : s.totalDuration()) /
                (s.reversed() ? -t : t)
            );
          if (s._dirty) {
            for (i = s.parent; o; )
              (e = o._prev),
                o._dirty && o.totalDuration(),
                (n = o._start) > a && s._sort && o._ts && !s._lock
                  ? ((s._lock = 1), (Xt(s, o, n - o._delay, 1)._lock = 0))
                  : (a = n),
                n < 0 &&
                  o._ts &&
                  ((r -= n),
                  ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                    ((s._start += n / s._ts), (s._time -= n), (s._tTime -= n)),
                  s.shiftChildren(-n, !1, -Infinity),
                  (a = 0)),
                o._end > r && o._ts && (r = o._end),
                (o = e);
            Zt(s, s === m && s._time > r ? s._time : r, 1, 1), (s._dirty = 0);
          }
          return s._tDur;
        }),
        (e.updateRoot = function (t) {
          if ((m._ts && (wt(m, Vt(t, m)), (x = Pe.frame)), Pe.frame >= ft)) {
            ft += D.autoSleep || 120;
            var e = m._first;
            if ((!e || !e._ts) && D.autoSleep && Pe._listeners.length < 2) {
              for (; e && !e._ts; ) e = e._next;
              e || Pe.sleep();
            }
          }
        }),
        e
      );
    })(We);
    Ct(je.prototype, {
      _lock: 0,
      _hasPause: 0,
      _forcing: 0,
    });
    var Xe,
      qe,
      Ye = function (t, e, n, i, r, s, o) {
        var a,
          l,
          c,
          u,
          h,
          d,
          p,
          f,
          m = new vn(this._pt, t, e, 0, 1, hn, null, r),
          g = 0,
          v = 0;
        for (
          m.b = n,
            m.e = i,
            n += "",
            (p = ~(i += "").indexOf("random(")) && (i = me(i)),
            s && (s((f = [n, i]), t, e), (n = f[0]), (i = f[1])),
            l = n.match(K) || [];
          (a = K.exec(i));

        )
          (u = a[0]),
            (h = i.substring(g, a.index)),
            c ? (c = (c + 1) % 5) : "rgba(" === h.substr(-5) && (c = 1),
            u !== l[v++] &&
              ((d = parseFloat(l[v - 1]) || 0),
              (m._pt = {
                _next: m._pt,
                p: h || 1 === v ? h : ",",
                s: d,
                c: "=" === u.charAt(1) ? Et(d, u) - d : parseFloat(u) - d,
                m: c && c < 4 ? Math.round : 0,
              }),
              (g = K.lastIndex));
        return (
          (m.c = g < i.length ? i.substring(g, i.length) : ""),
          (m.fp = o),
          (Z.test(i) || p) && (m.e = 0),
          (this._pt = m),
          m
        );
      },
      Ke = function (t, e, n, i, r, s, o, a, l, c) {
        N(i) && (i = i(r || 0, t, s));
        var u,
          h = t[e],
          d =
            "get" !== n
              ? n
              : N(h)
              ? l
                ? t[
                    e.indexOf("set") || !N(t["get" + e.substr(3)])
                      ? e
                      : "get" + e.substr(3)
                  ](l)
                : t[e]()
              : h,
          p = N(h) ? (l ? on : sn) : rn;
        if (
          (U(i) &&
            (~i.indexOf("random(") && (i = me(i)),
            "=" === i.charAt(1) &&
              ((u = Et(d, i) + (ie(d) || 0)) || 0 === u) &&
              (i = u)),
          !c || d !== i || qe)
        )
          return isNaN(d * i) || "" === i
            ? (!h && !(e in t) && nt(e, i),
              Ye.call(this, t, e, d, i, p, a || D.stringFilter, l))
            : ((u = new vn(
                this._pt,
                t,
                e,
                +d || 0,
                i - (d || 0),
                "boolean" == typeof h ? un : cn,
                0,
                p
              )),
              l && (u.fp = l),
              o && u.modifier(o, this, t),
              (this._pt = u));
      },
      Ze = function (t, e, n, i, r, s) {
        var o, a, l, c;
        if (
          dt[t] &&
          !1 !==
            (o = new dt[t]()).init(
              r,
              o.rawVars
                ? e[t]
                : (function (t, e, n, i, r) {
                    if (
                      (N(t) && (t = Qe(t, r, e, n, i)),
                      !B(t) || (t.style && t.nodeType) || j(t) || W(t))
                    )
                      return U(t) ? Qe(t, r, e, n, i) : t;
                    var s,
                      o = {};
                    for (s in t) o[s] = Qe(t[s], r, e, n, i);
                    return o;
                  })(e[t], i, r, s, n),
              n,
              i,
              s
            ) &&
          ((n._pt = a = new vn(n._pt, r, t, 0, 1, o.render, o, 0, o.priority)),
          n !== b)
        )
          for (
            l = n._ptLookup[n._targets.indexOf(r)], c = o._props.length;
            c--;

          )
            l[o._props[c]] = a;
        return o;
      },
      Je = function t(e, n, i) {
        var r,
          s,
          o,
          a,
          l,
          c,
          u,
          h,
          f,
          g,
          v,
          _,
          y,
          x = e.vars,
          b = x.ease,
          S = x.startAt,
          E = x.immediateRender,
          M = x.lazy,
          T = x.onUpdate,
          w = x.onUpdateParams,
          D = x.callbackScope,
          P = x.runBackwards,
          R = x.yoyoEase,
          L = x.keyframes,
          O = x.autoRevert,
          I = e._dur,
          F = e._startAt,
          U = e._targets,
          N = e.parent,
          k = N && "nested" === N.data ? N.vars.targets : U,
          z = "auto" === e._overwrite && !d,
          B = e.timeline;
        if (
          (B && (!L || !b) && (b = "none"),
          (e._ease = ke(b, A.ease)),
          (e._yEase = R ? Ue(ke(!0 === R ? b : R, A.ease)) : 0),
          R &&
            e._yoyo &&
            !e._repeat &&
            ((R = e._yEase), (e._yEase = e._ease), (e._ease = R)),
          (e._from = !B && !!x.runBackwards),
          !B || (L && !x.stagger))
        ) {
          if (
            ((_ = (h = U[0] ? _t(U[0]).harness : 0) && x[h.prop]),
            (r = Lt(x, ct)),
            F &&
              (F._zTime < 0 && F.progress(1),
              n < 0 && P && E && !O
                ? F.render(-1, !0)
                : F.revert(P && I ? at : ot),
              (F._lazy = 0)),
            S)
          ) {
            if (
              (Ut(
                (e._startAt = nn.set(
                  U,
                  Ct(
                    {
                      data: "isStart",
                      overwrite: !1,
                      parent: N,
                      immediateRender: !0,
                      lazy: !F && H(M),
                      startAt: null,
                      delay: 0,
                      onUpdate: T,
                      onUpdateParams: w,
                      callbackScope: D,
                      stagger: 0,
                    },
                    S
                  )
                ))
              ),
              (e._startAt._dp = 0),
              (e._startAt._sat = e),
              n < 0 && (p || (!E && !O)) && e._startAt.revert(at),
              E && I && n <= 0 && i <= 0)
            )
              return void (n && (e._zTime = n));
          } else if (P && I && !F)
            if (
              (n && (E = !1),
              (o = Ct(
                {
                  overwrite: !1,
                  data: "isFromStart",
                  lazy: E && !F && H(M),
                  immediateRender: E,
                  stagger: 0,
                  parent: N,
                },
                r
              )),
              _ && (o[h.prop] = _),
              Ut((e._startAt = nn.set(U, o))),
              (e._startAt._dp = 0),
              (e._startAt._sat = e),
              n < 0 && (p ? e._startAt.revert(at) : e._startAt.render(-1, !0)),
              (e._zTime = n),
              E)
            ) {
              if (!n) return;
            } else t(e._startAt, 1e-8, 1e-8);
          for (
            e._pt = e._ptCache = 0, M = (I && H(M)) || (M && !I), s = 0;
            s < U.length;
            s++
          ) {
            if (
              ((u = (l = U[s])._gsap || vt(U)[s]._gsap),
              (e._ptLookup[s] = g = {}),
              ht[u.id] && ut.length && Tt(),
              (v = k === U ? s : k.indexOf(l)),
              h &&
                !1 !== (f = new h()).init(l, _ || r, e, v, k) &&
                ((e._pt = a =
                  new vn(e._pt, l, f.name, 0, 1, f.render, f, 0, f.priority)),
                f._props.forEach(function (t) {
                  g[t] = a;
                }),
                f.priority && (c = 1)),
              !h || _)
            )
              for (o in r)
                dt[o] && (f = Ze(o, r, e, v, l, k))
                  ? f.priority && (c = 1)
                  : (g[o] = a =
                      Ke.call(e, l, o, "get", r[o], v, k, 0, x.stringFilter));
            e._op && e._op[s] && e.kill(l, e._op[s]),
              z &&
                e._pt &&
                ((Xe = e),
                m.killTweensOf(l, g, e.globalTime(n)),
                (y = !e.parent),
                (Xe = 0)),
              e._pt && M && (ht[u.id] = 1);
          }
          c && gn(e), e._onInit && e._onInit(e);
        }
        (e._onUpdate = T),
          (e._initted = (!e._op || e._pt) && !y),
          L && n <= 0 && B.render(C, !0, !0);
      },
      $e = function (t, e, n, i) {
        var r,
          s,
          o = e.ease || i || "power1.inOut";
        if (j(e))
          (s = n[t] || (n[t] = [])),
            e.forEach(function (t, n) {
              return s.push({
                t: (n / (e.length - 1)) * 100,
                v: t,
                e: o,
              });
            });
        else
          for (r in e)
            (s = n[r] || (n[r] = [])),
              "ease" === r ||
                s.push({
                  t: parseFloat(t),
                  v: e[r],
                  e: o,
                });
      },
      Qe = function (t, e, n, i, r) {
        return N(t)
          ? t.call(e, n, i, r)
          : U(t) && ~t.indexOf("random(")
          ? me(t)
          : t;
      },
      tn = gt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
      en = {};
    xt(tn + ",id,stagger,delay,duration,paused,scrollTrigger", function (t) {
      return (en[t] = 1);
    });
    var nn = (function (t) {
      function e(e, n, i, r) {
        var s;
        "number" == typeof n && ((i.duration = n), (n = i), (i = null));
        var o,
          a,
          l,
          c,
          h,
          p,
          f,
          g,
          v = (s = t.call(this, r ? n : Ot(n)) || this).vars,
          _ = v.duration,
          y = v.delay,
          x = v.immediateRender,
          b = v.stagger,
          S = v.overwrite,
          E = v.keyframes,
          M = v.defaults,
          T = v.scrollTrigger,
          w = v.yoyoEase,
          A = n.parent || m,
          C = (j(e) || W(e) ? k(e[0]) : "length" in n) ? [e] : ae(e);
        if (
          ((s._targets = C.length
            ? vt(C)
            : it(
                "GSAP target " + e + " not found. https://greensock.com",
                !D.nullTargetWarn
              ) || []),
          (s._ptLookup = []),
          (s._overwrite = S),
          E || b || G(_) || G(y))
        ) {
          if (
            ((n = s.vars),
            (o = s.timeline =
              new je({
                data: "nested",
                defaults: M || {},
                targets: A && "nested" === A.data ? A.vars.targets : C,
              })).kill(),
            (o.parent = o._dp = u(s)),
            (o._start = 0),
            b || G(_) || G(y))
          ) {
            if (((c = C.length), (f = b && ue(b)), B(b)))
              for (h in b) ~tn.indexOf(h) && (g || (g = {}), (g[h] = b[h]));
            for (a = 0; a < c; a++)
              ((l = Lt(n, en)).stagger = 0),
                w && (l.yoyoEase = w),
                g && Pt(l, g),
                (p = C[a]),
                (l.duration = +Qe(_, u(s), a, p, C)),
                (l.delay = (+Qe(y, u(s), a, p, C) || 0) - s._delay),
                !b &&
                  1 === c &&
                  l.delay &&
                  ((s._delay = y = l.delay), (s._start += y), (l.delay = 0)),
                o.to(p, l, f ? f(a, p, C) : 0),
                (o._ease = Le.none);
            o.duration() ? (_ = y = 0) : (s.timeline = 0);
          } else if (E) {
            Ot(
              Ct(o.vars.defaults, {
                ease: "none",
              })
            ),
              (o._ease = ke(E.ease || n.ease || "none"));
            var P,
              R,
              L,
              O = 0;
            if (j(E))
              E.forEach(function (t) {
                return o.to(C, t, ">");
              }),
                o.duration();
            else {
              for (h in ((l = {}), E))
                "ease" === h || "easeEach" === h || $e(h, E[h], l, E.easeEach);
              for (h in l)
                for (
                  P = l[h].sort(function (t, e) {
                    return t.t - e.t;
                  }),
                    O = 0,
                    a = 0;
                  a < P.length;
                  a++
                )
                  ((L = {
                    ease: (R = P[a]).e,
                    duration: ((R.t - (a ? P[a - 1].t : 0)) / 100) * _,
                  })[h] = R.v),
                    o.to(C, L, O),
                    (O += L.duration);
              o.duration() < _ &&
                o.to(
                  {},
                  {
                    duration: _ - o.duration(),
                  }
                );
            }
          }
          _ || s.duration((_ = o.duration()));
        } else s.timeline = 0;
        return (
          !0 !== S || d || ((Xe = u(s)), m.killTweensOf(C), (Xe = 0)),
          Xt(A, u(s), i),
          n.reversed && s.reverse(),
          n.paused && s.paused(!0),
          (x ||
            (!_ &&
              !E &&
              s._start === St(A._time) &&
              H(x) &&
              (function t(e) {
                return !e || (e._ts && t(e.parent));
              })(u(s)) &&
              "nested" !== A.data)) &&
            ((s._tTime = -1e-8), s.render(Math.max(0, -y) || 0)),
          T && qt(u(s), T),
          s
        );
      }
      h(e, t);
      var n = e.prototype;
      return (
        (n.render = function (t, e, n) {
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u,
            h,
            d = this._time,
            f = this._tDur,
            m = this._dur,
            g = t < 0,
            v = t > f - 1e-8 && !g ? f : t < 1e-8 ? 0 : t;
          if (m) {
            if (
              v !== this._tTime ||
              !t ||
              n ||
              (!this._initted && this._tTime) ||
              (this._startAt && this._zTime < 0 !== g)
            ) {
              if (((i = v), (u = this.timeline), this._repeat)) {
                if (((o = m + this._rDelay), this._repeat < -1 && g))
                  return this.totalTime(100 * o + t, e, n);
                if (
                  ((i = St(v % o)),
                  v === f
                    ? ((s = this._repeat), (i = m))
                    : ((s = ~~(v / o)) && s === v / o && ((i = m), s--),
                      i > m && (i = m)),
                  (l = this._yoyo && 1 & s) && ((h = this._yEase), (i = m - i)),
                  (a = Ht(this._tTime, o)),
                  i === d && !n && this._initted)
                )
                  return (this._tTime = v), this;
                s !== a &&
                  (u && this._yEase && Ne(u, l),
                  !this.vars.repeatRefresh ||
                    l ||
                    this._lock ||
                    ((this._lock = n = 1),
                    (this.render(St(o * s), !0).invalidate()._lock = 0)));
              }
              if (!this._initted) {
                if (Yt(this, g ? t : i, n, e, v))
                  return (this._tTime = 0), this;
                if (d !== this._time) return this;
                if (m !== this._dur) return this.render(t, e, n);
              }
              if (
                ((this._tTime = v),
                (this._time = i),
                !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
                (this.ratio = c = (h || this._ease)(i / m)),
                this._from && (this.ratio = c = 1 - c),
                i && !d && !e && !s && (_e(this, "onStart"), this._tTime !== v))
              )
                return this;
              for (r = this._pt; r; ) r.r(c, r.d), (r = r._next);
              (u &&
                u.render(
                  t < 0 ? t : !i && l ? -1e-8 : u._dur * u._ease(i / this._dur),
                  e,
                  n
                )) ||
                (this._startAt && (this._zTime = t)),
                this._onUpdate &&
                  !e &&
                  (g && zt(this, t, 0, n), _e(this, "onUpdate")),
                this._repeat &&
                  s !== a &&
                  this.vars.onRepeat &&
                  !e &&
                  this.parent &&
                  _e(this, "onRepeat"),
                (v !== this._tDur && v) ||
                  this._tTime !== v ||
                  (g && !this._onUpdate && zt(this, t, 0, !0),
                  (t || !m) &&
                    ((v === this._tDur && this._ts > 0) ||
                      (!v && this._ts < 0)) &&
                    Ut(this, 1),
                  e ||
                    (g && !d) ||
                    !(v || d || l) ||
                    (_e(this, v === f ? "onComplete" : "onReverseComplete", !0),
                    this._prom &&
                      !(v < f && this.timeScale() > 0) &&
                      this._prom()));
            }
          } else
            !(function (t, e, n, i) {
              var r,
                s,
                o,
                a = t.ratio,
                l =
                  e < 0 ||
                  (!e &&
                    ((!t._start &&
                      (function t(e) {
                        var n = e.parent;
                        return (
                          n &&
                          n._ts &&
                          n._initted &&
                          !n._lock &&
                          (n.rawTime() < 0 || t(n))
                        );
                      })(t) &&
                      (t._initted || !Kt(t))) ||
                      ((t._ts < 0 || t._dp._ts < 0) && !Kt(t))))
                    ? 0
                    : 1,
                c = t._rDelay,
                u = 0;
              if (
                (c &&
                  t._repeat &&
                  ((u = ne(0, t._tDur, e)),
                  (s = Ht(u, c)),
                  t._yoyo && 1 & s && (l = 1 - l),
                  s !== Ht(t._tTime, c) &&
                    ((a = 1 - l),
                    t.vars.repeatRefresh && t._initted && t.invalidate())),
                l !== a || p || i || 1e-8 === t._zTime || (!e && t._zTime))
              ) {
                if (!t._initted && Yt(t, e, i, n, u)) return;
                for (
                  o = t._zTime,
                    t._zTime = e || (n ? 1e-8 : 0),
                    n || (n = e && !o),
                    t.ratio = l,
                    t._from && (l = 1 - l),
                    t._time = 0,
                    t._tTime = u,
                    r = t._pt;
                  r;

                )
                  r.r(l, r.d), (r = r._next);
                e < 0 && zt(t, e, 0, !0),
                  t._onUpdate && !n && _e(t, "onUpdate"),
                  u && t._repeat && !n && t.parent && _e(t, "onRepeat"),
                  (e >= t._tDur || e < 0) &&
                    t.ratio === l &&
                    (l && Ut(t, 1),
                    n ||
                      p ||
                      (_e(t, l ? "onComplete" : "onReverseComplete", !0),
                      t._prom && t._prom()));
              } else t._zTime || (t._zTime = e);
            })(this, t, e, n);
          return this;
        }),
        (n.targets = function () {
          return this._targets;
        }),
        (n.invalidate = function (e) {
          return (
            (!e || !this.vars.runBackwards) && (this._startAt = 0),
            (this._pt =
              this._op =
              this._onUpdate =
              this._lazy =
              this.ratio =
                0),
            (this._ptLookup = []),
            this.timeline && this.timeline.invalidate(e),
            t.prototype.invalidate.call(this, e)
          );
        }),
        (n.resetTo = function (t, e, n, i) {
          S || Pe.wake(), this._ts || this.play();
          var r = Math.min(
            this._dur,
            (this._dp._time - this._start) * this._ts
          );
          return (
            this._initted || Je(this, r),
            (function (t, e, n, i, r, s, o) {
              var a,
                l,
                c,
                u,
                h = ((t._pt && t._ptCache) || (t._ptCache = {}))[e];
              if (!h)
                for (
                  h = t._ptCache[e] = [],
                    c = t._ptLookup,
                    u = t._targets.length;
                  u--;

                ) {
                  if ((a = c[u][e]) && a.d && a.d._pt)
                    for (a = a.d._pt; a && a.p !== e && a.fp !== e; )
                      a = a._next;
                  if (!a)
                    return (qe = 1), (t.vars[e] = "+=0"), Je(t, o), (qe = 0), 1;
                  h.push(a);
                }
              for (u = h.length; u--; )
                ((a = (l = h[u])._pt || l).s =
                  (!i && 0 !== i) || r ? a.s + (i || 0) + s * a.c : i),
                  (a.c = n - a.s),
                  l.e && (l.e = bt(n) + ie(l.e)),
                  l.b && (l.b = a.s + ie(l.b));
            })(this, t, e, n, i, this._ease(r / this._dur), r)
              ? this.resetTo(t, e, n, i)
              : (Wt(this, 0),
                this.parent ||
                  It(
                    this._dp,
                    this,
                    "_first",
                    "_last",
                    this._dp._sort ? "_start" : 0
                  ),
                this.render(0))
          );
        }),
        (n.kill = function (t, e) {
          if ((void 0 === e && (e = "all"), !(t || (e && "all" !== e))))
            return (this._lazy = this._pt = 0), this.parent ? ye(this) : this;
          if (this.timeline) {
            var n = this.timeline.totalDuration();
            return (
              this.timeline.killTweensOf(t, e, Xe && !0 !== Xe.vars.overwrite)
                ._first || ye(this),
              this.parent &&
                n !== this.timeline.totalDuration() &&
                Zt(this, (this._dur * this.timeline._tDur) / n, 0, 1),
              this
            );
          }
          var i,
            r,
            s,
            o,
            a,
            l,
            c,
            u = this._targets,
            h = t ? ae(t) : u,
            d = this._ptLookup,
            p = this._pt;
          if (
            (!e || "all" === e) &&
            (function (t, e) {
              for (
                var n = t.length, i = n === e.length;
                i && n-- && t[n] === e[n];

              );
              return n < 0;
            })(u, h)
          )
            return "all" === e && (this._pt = 0), ye(this);
          for (
            i = this._op = this._op || [],
              "all" !== e &&
                (U(e) &&
                  ((a = {}),
                  xt(e, function (t) {
                    return (a[t] = 1);
                  }),
                  (e = a)),
                (e = (function (t, e) {
                  var n,
                    i,
                    r,
                    s,
                    o = t[0] ? _t(t[0]).harness : 0,
                    a = o && o.aliases;
                  if (!a) return e;
                  for (i in ((n = Pt({}, e)), a))
                    if ((i in n))
                      for (r = (s = a[i].split(",")).length; r--; )
                        n[s[r]] = n[i];
                  return n;
                })(u, e))),
              c = u.length;
            c--;

          )
            if (~h.indexOf(u[c]))
              for (a in ((r = d[c]),
              "all" === e
                ? ((i[c] = e), (o = r), (s = {}))
                : ((s = i[c] = i[c] || {}), (o = e)),
              o))
                (l = r && r[a]) &&
                  (("kill" in l.d && !0 !== l.d.kill(a)) || Ft(this, l, "_pt"),
                  delete r[a]),
                  "all" !== s && (s[a] = 1);
          return this._initted && !this._pt && p && ye(this), this;
        }),
        (e.to = function (t, n) {
          return new e(t, n, arguments[2]);
        }),
        (e.from = function (t, e) {
          return te(1, arguments);
        }),
        (e.delayedCall = function (t, n, i, r) {
          return new e(n, 0, {
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: t,
            onComplete: n,
            onReverseComplete: n,
            onCompleteParams: i,
            onReverseCompleteParams: i,
            callbackScope: r,
          });
        }),
        (e.fromTo = function (t, e, n) {
          return te(2, arguments);
        }),
        (e.set = function (t, n) {
          return (n.duration = 0), n.repeatDelay || (n.repeat = 0), new e(t, n);
        }),
        (e.killTweensOf = function (t, e, n) {
          return m.killTweensOf(t, e, n);
        }),
        e
      );
    })(We);
    Ct(nn.prototype, {
      _targets: [],
      _lazy: 0,
      _startAt: 0,
      _op: 0,
      _onInit: 0,
    }),
      xt("staggerTo,staggerFrom,staggerFromTo", function (t) {
        nn[t] = function () {
          var e = new je(),
            n = re.call(arguments, 0);
          return (
            n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
          );
        };
      });
    var rn = function (t, e, n) {
        return (t[e] = n);
      },
      sn = function (t, e, n) {
        return t[e](n);
      },
      on = function (t, e, n, i) {
        return t[e](i.fp, n);
      },
      an = function (t, e, n) {
        return t.setAttribute(e, n);
      },
      ln = function (t, e) {
        return N(t[e]) ? sn : z(t[e]) && t.setAttribute ? an : rn;
      },
      cn = function (t, e) {
        return e.set(e.t, e.p, Math.round(1e6 * (e.s + e.c * t)) / 1e6, e);
      },
      un = function (t, e) {
        return e.set(e.t, e.p, !!(e.s + e.c * t), e);
      },
      hn = function (t, e) {
        var n = e._pt,
          i = "";
        if (!t && e.b) i = e.b;
        else if (1 === t && e.e) i = e.e;
        else {
          for (; n; )
            (i =
              n.p +
              (n.m
                ? n.m(n.s + n.c * t)
                : Math.round(1e4 * (n.s + n.c * t)) / 1e4) +
              i),
              (n = n._next);
          i += e.c;
        }
        e.set(e.t, e.p, i, e);
      },
      dn = function (t, e) {
        for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
      },
      pn = function (t, e, n, i) {
        for (var r, s = this._pt; s; )
          (r = s._next), s.p === i && s.modifier(t, e, n), (s = r);
      },
      fn = function (t) {
        for (var e, n, i = this._pt; i; )
          (n = i._next),
            (i.p === t && !i.op) || i.op === t
              ? Ft(this, i, "_pt")
              : i.dep || (e = 1),
            (i = n);
        return !e;
      },
      mn = function (t, e, n, i) {
        i.mSet(t, e, i.m.call(i.tween, n, i.mt), i);
      },
      gn = function (t) {
        for (var e, n, i, r, s = t._pt; s; ) {
          for (e = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
          (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
            (s._next = n) ? (n._prev = s) : (r = s),
            (s = e);
        }
        t._pt = i;
      },
      vn = (function () {
        function t(t, e, n, i, r, s, o, a, l) {
          (this.t = e),
            (this.s = i),
            (this.c = r),
            (this.p = n),
            (this.r = s || cn),
            (this.d = o || this),
            (this.set = a || rn),
            (this.pr = l || 0),
            (this._next = t),
            t && (t._prev = this);
        }
        return (
          (t.prototype.modifier = function (t, e, n) {
            (this.mSet = this.mSet || this.set),
              (this.set = mn),
              (this.m = t),
              (this.mt = n),
              (this.tween = e);
          }),
          t
        );
      })();
    xt(
      gt +
        "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
      function (t) {
        return (ct[t] = 1);
      }
    ),
      (Q.TweenMax = Q.TweenLite = nn),
      (Q.TimelineLite = Q.TimelineMax = je),
      (m = new je({
        sortChildren: !1,
        defaults: A,
        autoRemoveChildren: !0,
        id: "root",
        smoothChildTiming: !0,
      })),
      (D.stringFilter = Ce);
    var _n = [],
      yn = {},
      xn = [],
      bn = 0,
      Sn = 0,
      En = function (t) {
        return (yn[t] || xn).map(function (t) {
          return t();
        });
      },
      Mn = function () {
        var t = Date.now(),
          e = [];
        t - bn > 2 &&
          (En("matchMediaInit"),
          _n.forEach(function (t) {
            var n,
              i,
              r,
              s,
              o = t.queries,
              a = t.conditions;
            for (i in o)
              (n = g.matchMedia(o[i]).matches) && (r = 1),
                n !== a[i] && ((a[i] = n), (s = 1));
            s && (t.revert(), r && e.push(t));
          }),
          En("matchMediaRevert"),
          e.forEach(function (t) {
            return t.onMatch(t);
          }),
          (bn = t),
          En("matchMedia"));
      },
      Tn = (function () {
        function t(t, e) {
          (this.selector = e && le(e)),
            (this.data = []),
            (this._r = []),
            (this.isReverted = !1),
            (this.id = Sn++),
            t && this.add(t);
        }
        var e = t.prototype;
        return (
          (e.add = function (t, e, n) {
            N(t) && ((n = e), (e = t), (t = N));
            var i = this,
              r = function () {
                var t,
                  r = f,
                  s = i.selector;
                return (
                  r && r !== i && r.data.push(i),
                  n && (i.selector = le(n)),
                  (f = i),
                  (t = e.apply(i, arguments)),
                  N(t) && i._r.push(t),
                  (f = r),
                  (i.selector = s),
                  (i.isReverted = !1),
                  t
                );
              };
            return (i.last = r), t === N ? r(i) : t ? (i[t] = r) : r;
          }),
          (e.ignore = function (t) {
            var e = f;
            (f = null), t(this), (f = e);
          }),
          (e.getTweens = function () {
            var e = [];
            return (
              this.data.forEach(function (n) {
                return n instanceof t
                  ? e.push.apply(e, n.getTweens())
                  : n instanceof nn &&
                      !(n.parent && "nested" === n.parent.data) &&
                      e.push(n);
              }),
              e
            );
          }),
          (e.clear = function () {
            this._r.length = this.data.length = 0;
          }),
          (e.kill = function (t, e) {
            var n = this;
            if (t) {
              var i = this.getTweens();
              this.data.forEach(function (t) {
                "isFlip" === t.data &&
                  (t.revert(),
                  t.getChildren(!0, !0, !1).forEach(function (t) {
                    return i.splice(i.indexOf(t), 1);
                  }));
              }),
                i
                  .map(function (t) {
                    return {
                      g: t.globalTime(0),
                      t: t,
                    };
                  })
                  .sort(function (t, e) {
                    return e.g - t.g || -1 / 0;
                  })
                  .forEach(function (e) {
                    return e.t.revert(t);
                  }),
                this.data.forEach(function (e) {
                  return !(e instanceof nn) && e.revert && e.revert(t);
                }),
                this._r.forEach(function (e) {
                  return e(t, n);
                }),
                (this.isReverted = !0);
            } else
              this.data.forEach(function (t) {
                return t.kill && t.kill();
              });
            if ((this.clear(), e))
              for (var r = _n.length; r--; )
                _n[r].id === this.id && _n.splice(r, 1);
          }),
          (e.revert = function (t) {
            this.kill(t || {});
          }),
          t
        );
      })(),
      wn = (function () {
        function t(t) {
          (this.contexts = []), (this.scope = t);
        }
        var e = t.prototype;
        return (
          (e.add = function (t, e, n) {
            B(t) ||
              (t = {
                matches: t,
              });
            var i,
              r,
              s,
              o = new Tn(0, n || this.scope),
              a = (o.conditions = {});
            for (r in (f && !o.selector && (o.selector = f.selector),
            this.contexts.push(o),
            (e = o.add("onMatch", e)),
            (o.queries = t),
            t))
              "all" === r
                ? (s = 1)
                : (i = g.matchMedia(t[r])) &&
                  (_n.indexOf(o) < 0 && _n.push(o),
                  (a[r] = i.matches) && (s = 1),
                  i.addListener
                    ? i.addListener(Mn)
                    : i.addEventListener("change", Mn));
            return s && e(o), this;
          }),
          (e.revert = function (t) {
            this.kill(t || {});
          }),
          (e.kill = function (t) {
            this.contexts.forEach(function (e) {
              return e.kill(t, !0);
            });
          }),
          t
        );
      })(),
      Dn = {
        registerPlugin: function () {
          for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
            e[n] = arguments[n];
          e.forEach(function (t) {
            return be(t);
          });
        },
        timeline: function (t) {
          return new je(t);
        },
        getTweensOf: function (t, e) {
          return m.getTweensOf(t, e);
        },
        getProperty: function (t, e, n, i) {
          U(t) && (t = ae(t)[0]);
          var r = _t(t || {}).get,
            s = n ? At : Dt;
          return (
            "native" === n && (n = ""),
            t
              ? e
                ? s(((dt[e] && dt[e].get) || r)(t, e, n, i))
                : function (e, n, i) {
                    return s(((dt[e] && dt[e].get) || r)(t, e, n, i));
                  }
              : t
          );
        },
        quickSetter: function (t, e, n) {
          if ((t = ae(t)).length > 1) {
            var i = t.map(function (t) {
                return Pn.quickSetter(t, e, n);
              }),
              r = i.length;
            return function (t) {
              for (var e = r; e--; ) i[e](t);
            };
          }
          t = t[0] || {};
          var s = dt[e],
            o = _t(t),
            a = (o.harness && (o.harness.aliases || {})[e]) || e,
            l = s
              ? function (e) {
                  var i = new s();
                  (b._pt = 0),
                    i.init(t, n ? e + n : e, b, 0, [t]),
                    i.render(1, i),
                    b._pt && dn(1, b);
                }
              : o.set(t, a);
          return s
            ? l
            : function (e) {
                return l(t, a, n ? e + n : e, o, 1);
              };
        },
        quickTo: function (t, e, n) {
          var i,
            r = Pn.to(
              t,
              Pt((((i = {})[e] = "+=0.1"), (i.paused = !0), i), n || {})
            ),
            s = function (t, n, i) {
              return r.resetTo(e, t, n, i);
            };
          return (s.tween = r), s;
        },
        isTweening: function (t) {
          return m.getTweensOf(t, !0).length > 0;
        },
        defaults: function (t) {
          return t && t.ease && (t.ease = ke(t.ease, A.ease)), Rt(A, t || {});
        },
        config: function (t) {
          return Rt(D, t || {});
        },
        registerEffect: function (t) {
          var e = t.name,
            n = t.effect,
            i = t.plugins,
            r = t.defaults,
            s = t.extendTimeline;
          (i || "").split(",").forEach(function (t) {
            return (
              t &&
              !dt[t] &&
              !Q[t] &&
              it(e + " effect requires " + t + " plugin.")
            );
          }),
            (pt[e] = function (t, e, i) {
              return n(ae(t), Ct(e || {}, r), i);
            }),
            s &&
              (je.prototype[e] = function (t, n, i) {
                return this.add(pt[e](t, B(n) ? n : (i = n) && {}, this), i);
              });
        },
        registerEase: function (t, e) {
          Le[t] = ke(e);
        },
        parseEase: function (t, e) {
          return arguments.length ? ke(t, e) : Le;
        },
        getById: function (t) {
          return m.getById(t);
        },
        exportRoot: function (t, e) {
          void 0 === t && (t = {});
          var n,
            i,
            r = new je(t);
          for (
            r.smoothChildTiming = H(t.smoothChildTiming),
              m.remove(r),
              r._dp = 0,
              r._time = r._tTime = m._time,
              n = m._first;
            n;

          )
            (i = n._next),
              (!e &&
                !n._dur &&
                n instanceof nn &&
                n.vars.onComplete === n._targets[0]) ||
                Xt(r, n, n._start - n._delay),
              (n = i);
          return Xt(m, r, 0), r;
        },
        context: function (t, e) {
          return t ? new Tn(t, e) : f;
        },
        matchMedia: function (t) {
          return new wn(t);
        },
        matchMediaRefresh: function () {
          return (
            _n.forEach(function (t) {
              var e,
                n,
                i = t.conditions;
              for (n in i) i[n] && ((i[n] = !1), (e = 1));
              e && t.revert();
            }) || Mn()
          );
        },
        addEventListener: function (t, e) {
          var n = yn[t] || (yn[t] = []);
          ~n.indexOf(e) || n.push(e);
        },
        removeEventListener: function (t, e) {
          var n = yn[t],
            i = n && n.indexOf(e);
          i >= 0 && n.splice(i, 1);
        },
        utils: {
          wrap: function t(e, n, i) {
            var r = n - e;
            return j(e)
              ? fe(e, t(0, e.length), n)
              : ee(i, function (t) {
                  return ((r + ((t - e) % r)) % r) + e;
                });
          },
          wrapYoyo: function t(e, n, i) {
            var r = n - e,
              s = 2 * r;
            return j(e)
              ? fe(e, t(0, e.length - 1), n)
              : ee(i, function (t) {
                  return (
                    e + ((t = (s + ((t - e) % s)) % s || 0) > r ? s - t : t)
                  );
                });
          },
          distribute: ue,
          random: pe,
          snap: de,
          normalize: function (t, e, n) {
            return ge(t, e, 0, 1, n);
          },
          getUnit: ie,
          clamp: function (t, e, n) {
            return ee(n, function (n) {
              return ne(t, e, n);
            });
          },
          splitColor: Me,
          toArray: ae,
          selector: le,
          mapRange: ge,
          pipe: function () {
            for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)
              e[n] = arguments[n];
            return function (t) {
              return e.reduce(function (t, e) {
                return e(t);
              }, t);
            };
          },
          unitize: function (t, e) {
            return function (n) {
              return t(parseFloat(n)) + (e || ie(n));
            };
          },
          interpolate: function t(e, n, i, r) {
            var s = isNaN(e + n)
              ? 0
              : function (t) {
                  return (1 - t) * e + t * n;
                };
            if (!s) {
              var o,
                a,
                l,
                c,
                u,
                h = U(e),
                d = {};
              if ((!0 === i && (r = 1) && (i = null), h))
                (e = {
                  p: e,
                }),
                  (n = {
                    p: n,
                  });
              else if (j(e) && !j(n)) {
                for (l = [], c = e.length, u = c - 2, a = 1; a < c; a++)
                  l.push(t(e[a - 1], e[a]));
                c--,
                  (s = function (t) {
                    t *= c;
                    var e = Math.min(u, ~~t);
                    return l[e](t - e);
                  }),
                  (i = n);
              } else r || (e = Pt(j(e) ? [] : {}, e));
              if (!l) {
                for (o in n) Ke.call(d, e, o, "get", n[o]);
                s = function (t) {
                  return dn(t, d) || (h ? e.p : e);
                };
              }
            }
            return ee(i, s);
          },
          shuffle: ce,
        },
        install: et,
        effects: pt,
        ticker: Pe,
        updateRoot: je.updateRoot,
        plugins: dt,
        globalTimeline: m,
        core: {
          PropTween: vn,
          globals: rt,
          Tween: nn,
          Timeline: je,
          Animation: We,
          getCache: _t,
          _removeLinkedListItem: Ft,
          reverting: function () {
            return p;
          },
          context: function (t) {
            return t && f && (f.data.push(t), (t._ctx = f)), f;
          },
          suppressOverwrites: function (t) {
            return (d = t);
          },
        },
      };
    xt("to,from,fromTo,delayedCall,set,killTweensOf", function (t) {
      return (Dn[t] = nn[t]);
    }),
      Pe.add(je.updateRoot),
      (b = Dn.to(
        {},
        {
          duration: 0,
        }
      ));
    var An = function (t, e) {
        for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e; )
          n = n._next;
        return n;
      },
      Cn = function (t, e) {
        return {
          name: t,
          rawVars: 1,
          init: function (t, n, i) {
            i._onInit = function (t) {
              var i, r;
              if (
                (U(n) &&
                  ((i = {}),
                  xt(n, function (t) {
                    return (i[t] = 1);
                  }),
                  (n = i)),
                e)
              ) {
                for (r in ((i = {}), n)) i[r] = e(n[r]);
                n = i;
              }
              !(function (t, e) {
                var n,
                  i,
                  r,
                  s = t._targets;
                for (n in e)
                  for (i = s.length; i--; )
                    (r = t._ptLookup[i][n]) &&
                      (r = r.d) &&
                      (r._pt && (r = An(r, n)),
                      r && r.modifier && r.modifier(e[n], t, s[i], n));
              })(t, n);
            };
          },
        };
      },
      Pn =
        Dn.registerPlugin(
          {
            name: "attr",
            init: function (t, e, n, i, r) {
              var s, o, a;
              for (s in ((this.tween = n), e))
                (a = t.getAttribute(s) || ""),
                  ((o = this.add(
                    t,
                    "setAttribute",
                    (a || 0) + "",
                    e[s],
                    i,
                    r,
                    0,
                    0,
                    s
                  )).op = s),
                  (o.b = a),
                  this._props.push(s);
            },
            render: function (t, e) {
              for (var n = e._pt; n; )
                p ? n.set(n.t, n.p, n.b, n) : n.r(t, n.d), (n = n._next);
            },
          },
          {
            name: "endArray",
            init: function (t, e) {
              for (var n = e.length; n--; )
                this.add(t, n, t[n] || 0, e[n], 0, 0, 0, 0, 0, 1);
            },
          },
          Cn("roundProps", he),
          Cn("modifiers"),
          Cn("snap", de)
        ) || Dn;
    (nn.version = je.version = Pn.version = "3.12.2"), (y = 1), V() && Re();
    Le.Power0,
      Le.Power1,
      Le.Power2,
      Le.Power3,
      Le.Power4,
      Le.Linear,
      Le.Quad,
      Le.Cubic,
      Le.Quart,
      Le.Quint,
      Le.Strong,
      Le.Elastic,
      Le.Back,
      Le.SteppedEase,
      Le.Bounce,
      Le.Sine,
      Le.Expo,
      Le.Circ;
    /*!
     * CSSPlugin 3.12.2
     * https://greensock.com
     *
     * Copyright 2008-2023, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Rn,
      Ln,
      On,
      In,
      Fn,
      Un,
      Nn,
      kn,
      zn = {},
      Bn = 180 / Math.PI,
      Hn = Math.PI / 180,
      Vn = Math.atan2,
      Gn = /([A-Z])/g,
      Wn = /(left|right|width|margin|padding|x)/i,
      jn = /[\s,\(]\S/,
      Xn = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity",
      },
      qn = function (t, e) {
        return e.set(
          e.t,
          e.p,
          Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
          e
        );
      },
      Yn = function (t, e) {
        return e.set(
          e.t,
          e.p,
          1 === t ? e.e : Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u,
          e
        );
      },
      Kn = function (t, e) {
        return e.set(
          e.t,
          e.p,
          t ? Math.round(1e4 * (e.s + e.c * t)) / 1e4 + e.u : e.b,
          e
        );
      },
      Zn = function (t, e) {
        var n = e.s + e.c * t;
        e.set(e.t, e.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + e.u, e);
      },
      Jn = function (t, e) {
        return e.set(e.t, e.p, t ? e.e : e.b, e);
      },
      $n = function (t, e) {
        return e.set(e.t, e.p, 1 !== t ? e.b : e.e, e);
      },
      Qn = function (t, e, n) {
        return (t.style[e] = n);
      },
      ti = function (t, e, n) {
        return t.style.setProperty(e, n);
      },
      ei = function (t, e, n) {
        return (t._gsap[e] = n);
      },
      ni = function (t, e, n) {
        return (t._gsap.scaleX = t._gsap.scaleY = n);
      },
      ii = function (t, e, n, i, r) {
        var s = t._gsap;
        (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
      },
      ri = function (t, e, n, i, r) {
        var s = t._gsap;
        (s[e] = n), s.renderTransform(r, s);
      },
      si = "transform",
      oi = si + "Origin",
      ai = function t(e, n) {
        var i = this,
          r = this.target,
          s = r.style;
        if (e in zn && s) {
          if (((this.tfm = this.tfm || {}), "transform" === e))
            return Xn.transform.split(",").forEach(function (e) {
              return t.call(i, e, n);
            });
          if (
            (~(e = Xn[e] || e).indexOf(",")
              ? e.split(",").forEach(function (t) {
                  return (i.tfm[t] = Ti(r, t));
                })
              : (this.tfm[e] = r._gsap.x ? r._gsap[e] : Ti(r, e)),
            this.props.indexOf(si) >= 0)
          )
            return;
          r._gsap.svg &&
            ((this.svgo = r.getAttribute("data-svg-origin")),
            this.props.push(oi, n, "")),
            (e = si);
        }
        (s || n) && this.props.push(e, n, s[e]);
      },
      li = function (t) {
        t.translate &&
          (t.removeProperty("translate"),
          t.removeProperty("scale"),
          t.removeProperty("rotate"));
      },
      ci = function () {
        var t,
          e,
          n = this.props,
          i = this.target,
          r = i.style,
          s = i._gsap;
        for (t = 0; t < n.length; t += 3)
          n[t + 1]
            ? (i[n[t]] = n[t + 2])
            : n[t + 2]
            ? (r[n[t]] = n[t + 2])
            : r.removeProperty(
                "--" === n[t].substr(0, 2)
                  ? n[t]
                  : n[t].replace(Gn, "-$1").toLowerCase()
              );
        if (this.tfm) {
          for (e in this.tfm) s[e] = this.tfm[e];
          s.svg &&
            (s.renderTransform(),
            i.setAttribute("data-svg-origin", this.svgo || "")),
            ((t = Nn()) && t.isStart) || r[si] || (li(r), (s.uncache = 1));
        }
      },
      ui = function (t, e) {
        var n = {
          target: t,
          props: [],
          revert: ci,
          save: ai,
        };
        return (
          t._gsap || Pn.core.getCache(t),
          e &&
            e.split(",").forEach(function (t) {
              return n.save(t);
            }),
          n
        );
      },
      hi = function (t, e) {
        var n = Ln.createElementNS
          ? Ln.createElementNS(
              (e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
              t
            )
          : Ln.createElement(t);
        return n.style ? n : Ln.createElement(t);
      },
      di = function t(e, n, i) {
        var r = getComputedStyle(e);
        return (
          r[n] ||
          r.getPropertyValue(n.replace(Gn, "-$1").toLowerCase()) ||
          r.getPropertyValue(n) ||
          (!i && t(e, fi(n) || n, 1)) ||
          ""
        );
      },
      pi = "O,Moz,ms,Ms,Webkit".split(","),
      fi = function (t, e, n) {
        var i = (e || Fn).style,
          r = 5;
        if (t in i && !n) return t;
        for (
          t = t.charAt(0).toUpperCase() + t.substr(1);
          r-- && !(pi[r] + t in i);

        );
        return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? pi[r] : "") + t;
      },
      mi = function () {
        "undefined" != typeof window &&
          window.document &&
          ((Rn = window),
          (Ln = Rn.document),
          (On = Ln.documentElement),
          (Fn = hi("div") || {
            style: {},
          }),
          hi("div"),
          (si = fi(si)),
          (oi = si + "Origin"),
          (Fn.style.cssText =
            "border-width:0;line-height:0;position:absolute;padding:0"),
          (kn = !!fi("perspective")),
          (Nn = Pn.core.reverting),
          (In = 1));
      },
      gi = function t(e) {
        var n,
          i = hi(
            "svg",
            (this.ownerSVGElement &&
              this.ownerSVGElement.getAttribute("xmlns")) ||
              "http://www.w3.org/2000/svg"
          ),
          r = this.parentNode,
          s = this.nextSibling,
          o = this.style.cssText;
        if (
          (On.appendChild(i),
          i.appendChild(this),
          (this.style.display = "block"),
          e)
        )
          try {
            (n = this.getBBox()),
              (this._gsapBBox = this.getBBox),
              (this.getBBox = t);
          } catch (t) {}
        else this._gsapBBox && (n = this._gsapBBox());
        return (
          r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
          On.removeChild(i),
          (this.style.cssText = o),
          n
        );
      },
      vi = function (t, e) {
        for (var n = e.length; n--; )
          if (t.hasAttribute(e[n])) return t.getAttribute(e[n]);
      },
      _i = function (t) {
        var e;
        try {
          e = t.getBBox();
        } catch (n) {
          e = gi.call(t, !0);
        }
        return (
          (e && (e.width || e.height)) ||
            t.getBBox === gi ||
            (e = gi.call(t, !0)),
          !e || e.width || e.x || e.y
            ? e
            : {
                x: +vi(t, ["x", "cx", "x1"]) || 0,
                y: +vi(t, ["y", "cy", "y1"]) || 0,
                width: 0,
                height: 0,
              }
        );
      },
      yi = function (t) {
        return !(!t.getCTM || (t.parentNode && !t.ownerSVGElement) || !_i(t));
      },
      xi = function (t, e) {
        if (e) {
          var n = t.style;
          e in zn && e !== oi && (e = si),
            n.removeProperty
              ? (("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6)) ||
                  (e = "-" + e),
                n.removeProperty(e.replace(Gn, "-$1").toLowerCase()))
              : n.removeAttribute(e);
        }
      },
      bi = function (t, e, n, i, r, s) {
        var o = new vn(t._pt, e, n, 0, 1, s ? $n : Jn);
        return (t._pt = o), (o.b = i), (o.e = r), t._props.push(n), o;
      },
      Si = {
        deg: 1,
        rad: 1,
        turn: 1,
      },
      Ei = {
        grid: 1,
        flex: 1,
      },
      Mi = function t(e, n, i, r) {
        var s,
          o,
          a,
          l,
          c = parseFloat(i) || 0,
          u = (i + "").trim().substr((c + "").length) || "px",
          h = Fn.style,
          d = Wn.test(n),
          p = "svg" === e.tagName.toLowerCase(),
          f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
          m = "px" === r,
          g = "%" === r;
        return r === u || !c || Si[r] || Si[u]
          ? c
          : ("px" !== u && !m && (c = t(e, n, i, "px")),
            (l = e.getCTM && yi(e)),
            (!g && "%" !== u) || (!zn[n] && !~n.indexOf("adius"))
              ? ((h[d ? "width" : "height"] = 100 + (m ? u : r)),
                (o =
                  ~n.indexOf("adius") || ("em" === r && e.appendChild && !p)
                    ? e
                    : e.parentNode),
                l && (o = (e.ownerSVGElement || {}).parentNode),
                (o && o !== Ln && o.appendChild) || (o = Ln.body),
                (a = o._gsap) &&
                g &&
                a.width &&
                d &&
                a.time === Pe.time &&
                !a.uncache
                  ? bt((c / a.width) * 100)
                  : ((g || "%" === u) &&
                      !Ei[di(o, "display")] &&
                      (h.position = di(e, "position")),
                    o === e && (h.position = "static"),
                    o.appendChild(Fn),
                    (s = Fn[f]),
                    o.removeChild(Fn),
                    (h.position = "absolute"),
                    d && g && (((a = _t(o)).time = Pe.time), (a.width = o[f])),
                    bt(m ? (s * c) / 100 : s && c ? (100 / s) * c : 0)))
              : ((s = l ? e.getBBox()[d ? "width" : "height"] : e[f]),
                bt(g ? (c / s) * 100 : (c / 100) * s)));
      },
      Ti = function (t, e, n, i) {
        var r;
        return (
          In || mi(),
          e in Xn &&
            "transform" !== e &&
            ~(e = Xn[e]).indexOf(",") &&
            (e = e.split(",")[0]),
          zn[e] && "transform" !== e
            ? ((r = Ui(t, i)),
              (r =
                "transformOrigin" !== e
                  ? r[e]
                  : r.svg
                  ? r.origin
                  : Ni(di(t, oi)) + " " + r.zOrigin + "px"))
            : (!(r = t.style[e]) ||
                "auto" === r ||
                i ||
                ~(r + "").indexOf("calc(")) &&
              (r =
                (Ci[e] && Ci[e](t, e, n)) ||
                di(t, e) ||
                yt(t, e) ||
                ("opacity" === e ? 1 : 0)),
          n && !~(r + "").trim().indexOf(" ") ? Mi(t, e, r, n) + n : r
        );
      },
      wi = function (t, e, n, i) {
        if (!n || "none" === n) {
          var r = fi(e, t, 1),
            s = r && di(t, r, 1);
          s && s !== n
            ? ((e = r), (n = s))
            : "borderColor" === e && (n = di(t, "borderTopColor"));
        }
        var o,
          a,
          l,
          c,
          u,
          h,
          d,
          p,
          f,
          m,
          g,
          v = new vn(this._pt, t.style, e, 0, 1, hn),
          _ = 0,
          y = 0;
        if (
          ((v.b = n),
          (v.e = i),
          (n += ""),
          "auto" === (i += "") &&
            ((t.style[e] = i), (i = di(t, e) || i), (t.style[e] = n)),
          Ce((o = [n, i])),
          (i = o[1]),
          (l = (n = o[0]).match(Y) || []),
          (i.match(Y) || []).length)
        ) {
          for (; (a = Y.exec(i)); )
            (d = a[0]),
              (f = i.substring(_, a.index)),
              u
                ? (u = (u + 1) % 5)
                : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                  (u = 1),
              d !== (h = l[y++] || "") &&
                ((c = parseFloat(h) || 0),
                (g = h.substr((c + "").length)),
                "=" === d.charAt(1) && (d = Et(c, d) + g),
                (p = parseFloat(d)),
                (m = d.substr((p + "").length)),
                (_ = Y.lastIndex - m.length),
                m ||
                  ((m = m || D.units[e] || g),
                  _ === i.length && ((i += m), (v.e += m))),
                g !== m && (c = Mi(t, e, h, m) || 0),
                (v._pt = {
                  _next: v._pt,
                  p: f || 1 === y ? f : ",",
                  s: c,
                  c: p - c,
                  m: (u && u < 4) || "zIndex" === e ? Math.round : 0,
                }));
          v.c = _ < i.length ? i.substring(_, i.length) : "";
        } else v.r = "display" === e && "none" === i ? $n : Jn;
        return Z.test(i) && (v.e = 0), (this._pt = v), v;
      },
      Di = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%",
      },
      Ai = function (t, e) {
        if (e.tween && e.tween._time === e.tween._dur) {
          var n,
            i,
            r,
            s = e.t,
            o = s.style,
            a = e.u,
            l = s._gsap;
          if ("all" === a || !0 === a) (o.cssText = ""), (i = 1);
          else
            for (r = (a = a.split(",")).length; --r > -1; )
              (n = a[r]),
                zn[n] && ((i = 1), (n = "transformOrigin" === n ? oi : si)),
                xi(s, n);
          i &&
            (xi(s, si),
            l &&
              (l.svg && s.removeAttribute("transform"),
              Ui(s, 1),
              (l.uncache = 1),
              li(o)));
        }
      },
      Ci = {
        clearProps: function (t, e, n, i, r) {
          if ("isFromStart" !== r.data) {
            var s = (t._pt = new vn(t._pt, e, n, 0, 0, Ai));
            return (s.u = i), (s.pr = -10), (s.tween = r), t._props.push(n), 1;
          }
        },
      },
      Pi = [1, 0, 0, 1, 0, 0],
      Ri = {},
      Li = function (t) {
        return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t;
      },
      Oi = function (t) {
        var e = di(t, si);
        return Li(e) ? Pi : e.substr(7).match(q).map(bt);
      },
      Ii = function (t, e) {
        var n,
          i,
          r,
          s,
          o = t._gsap || _t(t),
          a = t.style,
          l = Oi(t);
        return o.svg && t.getAttribute("transform")
          ? "1,0,0,1,0,0" ===
            (l = [
              (r = t.transform.baseVal.consolidate().matrix).a,
              r.b,
              r.c,
              r.d,
              r.e,
              r.f,
            ]).join(",")
            ? Pi
            : l
          : (l !== Pi ||
              t.offsetParent ||
              t === On ||
              o.svg ||
              ((r = a.display),
              (a.display = "block"),
              ((n = t.parentNode) && t.offsetParent) ||
                ((s = 1), (i = t.nextElementSibling), On.appendChild(t)),
              (l = Oi(t)),
              r ? (a.display = r) : xi(t, "display"),
              s &&
                (i
                  ? n.insertBefore(t, i)
                  : n
                  ? n.appendChild(t)
                  : On.removeChild(t))),
            e && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
      },
      Fi = function (t, e, n, i, r, s) {
        var o,
          a,
          l,
          c = t._gsap,
          u = r || Ii(t, !0),
          h = c.xOrigin || 0,
          d = c.yOrigin || 0,
          p = c.xOffset || 0,
          f = c.yOffset || 0,
          m = u[0],
          g = u[1],
          v = u[2],
          _ = u[3],
          y = u[4],
          x = u[5],
          b = e.split(" "),
          S = parseFloat(b[0]) || 0,
          E = parseFloat(b[1]) || 0;
        n
          ? u !== Pi &&
            (a = m * _ - g * v) &&
            ((l = S * (-g / a) + E * (m / a) - (m * x - g * y) / a),
            (S = S * (_ / a) + E * (-v / a) + (v * x - _ * y) / a),
            (E = l))
          : ((S =
              (o = _i(t)).x + (~b[0].indexOf("%") ? (S / 100) * o.width : S)),
            (E =
              o.y + (~(b[1] || b[0]).indexOf("%") ? (E / 100) * o.height : E))),
          i || (!1 !== i && c.smooth)
            ? ((y = S - h),
              (x = E - d),
              (c.xOffset = p + (y * m + x * v) - y),
              (c.yOffset = f + (y * g + x * _) - x))
            : (c.xOffset = c.yOffset = 0),
          (c.xOrigin = S),
          (c.yOrigin = E),
          (c.smooth = !!i),
          (c.origin = e),
          (c.originIsAbsolute = !!n),
          (t.style[oi] = "0px 0px"),
          s &&
            (bi(s, c, "xOrigin", h, S),
            bi(s, c, "yOrigin", d, E),
            bi(s, c, "xOffset", p, c.xOffset),
            bi(s, c, "yOffset", f, c.yOffset)),
          t.setAttribute("data-svg-origin", S + " " + E);
      },
      Ui = function (t, e) {
        var n = t._gsap || new Ge(t);
        if ("x" in n && !e && !n.uncache) return n;
        var i,
          r,
          s,
          o,
          a,
          l,
          c,
          u,
          h,
          d,
          p,
          f,
          m,
          g,
          v,
          _,
          y,
          x,
          b,
          S,
          E,
          M,
          T,
          w,
          A,
          C,
          P,
          R,
          L,
          O,
          I,
          F,
          U = t.style,
          N = n.scaleX < 0,
          k = getComputedStyle(t),
          z = di(t, oi) || "0";
        return (
          (i = r = s = l = c = u = h = d = p = 0),
          (o = a = 1),
          (n.svg = !(!t.getCTM || !yi(t))),
          k.translate &&
            (("none" === k.translate &&
              "none" === k.scale &&
              "none" === k.rotate) ||
              (U[si] =
                ("none" !== k.translate
                  ? "translate3d(" +
                    (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                    ") "
                  : "") +
                ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") +
                ("none" !== k.scale
                  ? "scale(" + k.scale.split(" ").join(",") + ") "
                  : "") +
                ("none" !== k[si] ? k[si] : "")),
            (U.scale = U.rotate = U.translate = "none")),
          (g = Ii(t, n.svg)),
          n.svg &&
            (n.uncache
              ? ((A = t.getBBox()),
                (z = n.xOrigin - A.x + "px " + (n.yOrigin - A.y) + "px"),
                (w = ""))
              : (w = !e && t.getAttribute("data-svg-origin")),
            Fi(t, w || z, !!w || n.originIsAbsolute, !1 !== n.smooth, g)),
          (f = n.xOrigin || 0),
          (m = n.yOrigin || 0),
          g !== Pi &&
            ((x = g[0]),
            (b = g[1]),
            (S = g[2]),
            (E = g[3]),
            (i = M = g[4]),
            (r = T = g[5]),
            6 === g.length
              ? ((o = Math.sqrt(x * x + b * b)),
                (a = Math.sqrt(E * E + S * S)),
                (l = x || b ? Vn(b, x) * Bn : 0),
                (h = S || E ? Vn(S, E) * Bn + l : 0) &&
                  (a *= Math.abs(Math.cos(h * Hn))),
                n.svg &&
                  ((i -= f - (f * x + m * S)), (r -= m - (f * b + m * E))))
              : ((F = g[6]),
                (O = g[7]),
                (P = g[8]),
                (R = g[9]),
                (L = g[10]),
                (I = g[11]),
                (i = g[12]),
                (r = g[13]),
                (s = g[14]),
                (c = (v = Vn(F, L)) * Bn),
                v &&
                  ((w = M * (_ = Math.cos(-v)) + P * (y = Math.sin(-v))),
                  (A = T * _ + R * y),
                  (C = F * _ + L * y),
                  (P = M * -y + P * _),
                  (R = T * -y + R * _),
                  (L = F * -y + L * _),
                  (I = O * -y + I * _),
                  (M = w),
                  (T = A),
                  (F = C)),
                (u = (v = Vn(-S, L)) * Bn),
                v &&
                  ((_ = Math.cos(-v)),
                  (I = E * (y = Math.sin(-v)) + I * _),
                  (x = w = x * _ - P * y),
                  (b = A = b * _ - R * y),
                  (S = C = S * _ - L * y)),
                (l = (v = Vn(b, x)) * Bn),
                v &&
                  ((w = x * (_ = Math.cos(v)) + b * (y = Math.sin(v))),
                  (A = M * _ + T * y),
                  (b = b * _ - x * y),
                  (T = T * _ - M * y),
                  (x = w),
                  (M = A)),
                c &&
                  Math.abs(c) + Math.abs(l) > 359.9 &&
                  ((c = l = 0), (u = 180 - u)),
                (o = bt(Math.sqrt(x * x + b * b + S * S))),
                (a = bt(Math.sqrt(T * T + F * F))),
                (v = Vn(M, T)),
                (h = Math.abs(v) > 2e-4 ? v * Bn : 0),
                (p = I ? 1 / (I < 0 ? -I : I) : 0)),
            n.svg &&
              ((w = t.getAttribute("transform")),
              (n.forceCSS = t.setAttribute("transform", "") || !Li(di(t, si))),
              w && t.setAttribute("transform", w))),
          Math.abs(h) > 90 &&
            Math.abs(h) < 270 &&
            (N
              ? ((o *= -1),
                (h += l <= 0 ? 180 : -180),
                (l += l <= 0 ? 180 : -180))
              : ((a *= -1), (h += h <= 0 ? 180 : -180))),
          (e = e || n.uncache),
          (n.x =
            i -
            ((n.xPercent =
              i &&
              ((!e && n.xPercent) ||
                (Math.round(t.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
              ? (t.offsetWidth * n.xPercent) / 100
              : 0) +
            "px"),
          (n.y =
            r -
            ((n.yPercent =
              r &&
              ((!e && n.yPercent) ||
                (Math.round(t.offsetHeight / 2) === Math.round(-r) ? -50 : 0)))
              ? (t.offsetHeight * n.yPercent) / 100
              : 0) +
            "px"),
          (n.z = s + "px"),
          (n.scaleX = bt(o)),
          (n.scaleY = bt(a)),
          (n.rotation = bt(l) + "deg"),
          (n.rotationX = bt(c) + "deg"),
          (n.rotationY = bt(u) + "deg"),
          (n.skewX = h + "deg"),
          (n.skewY = d + "deg"),
          (n.transformPerspective = p + "px"),
          (n.zOrigin = parseFloat(z.split(" ")[2]) || 0) && (U[oi] = Ni(z)),
          (n.xOffset = n.yOffset = 0),
          (n.force3D = D.force3D),
          (n.renderTransform = n.svg ? Hi : kn ? Bi : zi),
          (n.uncache = 0),
          n
        );
      },
      Ni = function (t) {
        return (t = t.split(" "))[0] + " " + t[1];
      },
      ki = function (t, e, n) {
        var i = ie(e);
        return bt(parseFloat(e) + parseFloat(Mi(t, "x", n + "px", i))) + i;
      },
      zi = function (t, e) {
        (e.z = "0px"),
          (e.rotationY = e.rotationX = "0deg"),
          (e.force3D = 0),
          Bi(t, e);
      },
      Bi = function (t, e) {
        var n = e || this,
          i = n.xPercent,
          r = n.yPercent,
          s = n.x,
          o = n.y,
          a = n.z,
          l = n.rotation,
          c = n.rotationY,
          u = n.rotationX,
          h = n.skewX,
          d = n.skewY,
          p = n.scaleX,
          f = n.scaleY,
          m = n.transformPerspective,
          g = n.force3D,
          v = n.target,
          _ = n.zOrigin,
          y = "",
          x = ("auto" === g && t && 1 !== t) || !0 === g;
        if (_ && ("0deg" !== u || "0deg" !== c)) {
          var b,
            S = parseFloat(c) * Hn,
            E = Math.sin(S),
            M = Math.cos(S);
          (S = parseFloat(u) * Hn),
            (b = Math.cos(S)),
            (s = ki(v, s, E * b * -_)),
            (o = ki(v, o, -Math.sin(S) * -_)),
            (a = ki(v, a, M * b * -_ + _));
        }
        "0px" !== m && (y += "perspective(" + m + ") "),
          (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
          (x || "0px" !== s || "0px" !== o || "0px" !== a) &&
            (y +=
              "0px" !== a || x
                ? "translate3d(" + s + ", " + o + ", " + a + ") "
                : "translate(" + s + ", " + o + ") "),
          "0deg" !== l && (y += "rotate(" + l + ") "),
          "0deg" !== c && (y += "rotateY(" + c + ") "),
          "0deg" !== u && (y += "rotateX(" + u + ") "),
          ("0deg" === h && "0deg" === d) ||
            (y += "skew(" + h + ", " + d + ") "),
          (1 === p && 1 === f) || (y += "scale(" + p + ", " + f + ") "),
          (v.style[si] = y || "translate(0, 0)");
      },
      Hi = function (t, e) {
        var n,
          i,
          r,
          s,
          o,
          a = e || this,
          l = a.xPercent,
          c = a.yPercent,
          u = a.x,
          h = a.y,
          d = a.rotation,
          p = a.skewX,
          f = a.skewY,
          m = a.scaleX,
          g = a.scaleY,
          v = a.target,
          _ = a.xOrigin,
          y = a.yOrigin,
          x = a.xOffset,
          b = a.yOffset,
          S = a.forceCSS,
          E = parseFloat(u),
          M = parseFloat(h);
        (d = parseFloat(d)),
          (p = parseFloat(p)),
          (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
          d || p
            ? ((d *= Hn),
              (p *= Hn),
              (n = Math.cos(d) * m),
              (i = Math.sin(d) * m),
              (r = Math.sin(d - p) * -g),
              (s = Math.cos(d - p) * g),
              p &&
                ((f *= Hn),
                (o = Math.tan(p - f)),
                (r *= o = Math.sqrt(1 + o * o)),
                (s *= o),
                f &&
                  ((o = Math.tan(f)),
                  (n *= o = Math.sqrt(1 + o * o)),
                  (i *= o))),
              (n = bt(n)),
              (i = bt(i)),
              (r = bt(r)),
              (s = bt(s)))
            : ((n = m), (s = g), (i = r = 0)),
          ((E && !~(u + "").indexOf("px")) ||
            (M && !~(h + "").indexOf("px"))) &&
            ((E = Mi(v, "x", u, "px")), (M = Mi(v, "y", h, "px"))),
          (_ || y || x || b) &&
            ((E = bt(E + _ - (_ * n + y * r) + x)),
            (M = bt(M + y - (_ * i + y * s) + b))),
          (l || c) &&
            ((o = v.getBBox()),
            (E = bt(E + (l / 100) * o.width)),
            (M = bt(M + (c / 100) * o.height))),
          (o =
            "matrix(" +
            n +
            "," +
            i +
            "," +
            r +
            "," +
            s +
            "," +
            E +
            "," +
            M +
            ")"),
          v.setAttribute("transform", o),
          S && (v.style[si] = o);
      },
      Vi = function (t, e, n, i, r) {
        var s,
          o,
          a = U(r),
          l = parseFloat(r) * (a && ~r.indexOf("rad") ? Bn : 1) - i,
          c = i + l + "deg";
        return (
          a &&
            ("short" === (s = r.split("_")[1]) &&
              (l %= 360) !== l % 180 &&
              (l += l < 0 ? 360 : -360),
            "cw" === s && l < 0
              ? (l = ((l + 36e9) % 360) - 360 * ~~(l / 360))
              : "ccw" === s &&
                l > 0 &&
                (l = ((l - 36e9) % 360) - 360 * ~~(l / 360))),
          (t._pt = o = new vn(t._pt, e, n, i, l, Yn)),
          (o.e = c),
          (o.u = "deg"),
          t._props.push(n),
          o
        );
      },
      Gi = function (t, e) {
        for (var n in e) t[n] = e[n];
        return t;
      },
      Wi = function (t, e, n) {
        var i,
          r,
          s,
          o,
          a,
          l,
          c,
          u = Gi({}, n._gsap),
          h = n.style;
        for (r in (u.svg
          ? ((s = n.getAttribute("transform")),
            n.setAttribute("transform", ""),
            (h[si] = e),
            (i = Ui(n, 1)),
            xi(n, si),
            n.setAttribute("transform", s))
          : ((s = getComputedStyle(n)[si]),
            (h[si] = e),
            (i = Ui(n, 1)),
            (h[si] = s)),
        zn))
          (s = u[r]) !== (o = i[r]) &&
            "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
            ((a = ie(s) !== (c = ie(o)) ? Mi(n, r, s, c) : parseFloat(s)),
            (l = parseFloat(o)),
            (t._pt = new vn(t._pt, i, r, a, l - a, qn)),
            (t._pt.u = c || 0),
            t._props.push(r));
        Gi(i, u);
      };
    xt("padding,margin,Width,Radius", function (t, e) {
      var n = "Top",
        i = "Right",
        r = "Bottom",
        s = "Left",
        o = (e < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(function (
          n
        ) {
          return e < 2 ? t + n : "border" + n + t;
        });
      Ci[e > 1 ? "border" + t : t] = function (t, e, n, i, r) {
        var s, a;
        if (arguments.length < 4)
          return (
            (s = o.map(function (e) {
              return Ti(t, e, n);
            })),
            5 === (a = s.join(" ")).split(s[0]).length ? s[0] : a
          );
        (s = (i + "").split(" ")),
          (a = {}),
          o.forEach(function (t, e) {
            return (a[t] = s[e] = s[e] || s[((e - 1) / 2) | 0]);
          }),
          t.init(e, a, r);
      };
    });
    var ji,
      Xi,
      qi = {
        name: "css",
        register: mi,
        targetTest: function (t) {
          return t.style && t.nodeType;
        },
        init: function (t, e, n, i, r) {
          var s,
            o,
            a,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            m,
            g,
            v,
            _,
            y,
            x,
            b,
            S,
            E,
            M,
            T = this._props,
            w = t.style,
            A = n.vars.startAt;
          for (h in (In || mi(),
          (this.styles = this.styles || ui(t)),
          (x = this.styles.props),
          (this.tween = n),
          e))
            if (
              "autoRound" !== h &&
              ((o = e[h]), !dt[h] || !Ze(h, e, n, i, t, r))
            )
              if (
                ((c = typeof o),
                (u = Ci[h]),
                "function" === c && (c = typeof (o = o.call(n, i, t, r))),
                "string" === c && ~o.indexOf("random(") && (o = me(o)),
                u)
              )
                u(this, t, h, o, n) && (y = 1);
              else if ("--" === h.substr(0, 2))
                (s = (getComputedStyle(t).getPropertyValue(h) + "").trim()),
                  (o += ""),
                  (De.lastIndex = 0),
                  De.test(s) || ((d = ie(s)), (p = ie(o))),
                  p ? d !== p && (s = Mi(t, h, s, p) + p) : d && (o += d),
                  this.add(w, "setProperty", s, o, i, r, 0, 0, h),
                  T.push(h),
                  x.push(h, 0, w[h]);
              else if ("undefined" !== c) {
                if (
                  (A && h in A
                    ? ((s =
                        "function" == typeof A[h]
                          ? A[h].call(n, i, t, r)
                          : A[h]),
                      U(s) && ~s.indexOf("random(") && (s = me(s)),
                      ie(s + "") || (s += D.units[h] || ie(Ti(t, h)) || ""),
                      "=" === (s + "").charAt(1) && (s = Ti(t, h)))
                    : (s = Ti(t, h)),
                  (l = parseFloat(s)),
                  (f =
                    "string" === c && "=" === o.charAt(1) && o.substr(0, 2)) &&
                    (o = o.substr(2)),
                  (a = parseFloat(o)),
                  h in Xn &&
                    ("autoAlpha" === h &&
                      (1 === l &&
                        "hidden" === Ti(t, "visibility") &&
                        a &&
                        (l = 0),
                      x.push("visibility", 0, w.visibility),
                      bi(
                        this,
                        w,
                        "visibility",
                        l ? "inherit" : "hidden",
                        a ? "inherit" : "hidden",
                        !a
                      )),
                    "scale" !== h &&
                      "transform" !== h &&
                      ~(h = Xn[h]).indexOf(",") &&
                      (h = h.split(",")[0])),
                  (m = h in zn))
                )
                  if (
                    (this.styles.save(h),
                    g ||
                      (((v = t._gsap).renderTransform && !e.parseTransform) ||
                        Ui(t, e.parseTransform),
                      (_ = !1 !== e.smoothOrigin && v.smooth),
                      ((g = this._pt =
                        new vn(
                          this._pt,
                          w,
                          si,
                          0,
                          1,
                          v.renderTransform,
                          v,
                          0,
                          -1
                        )).dep = 1)),
                    "scale" === h)
                  )
                    (this._pt = new vn(
                      this._pt,
                      v,
                      "scaleY",
                      v.scaleY,
                      (f ? Et(v.scaleY, f + a) : a) - v.scaleY || 0,
                      qn
                    )),
                      (this._pt.u = 0),
                      T.push("scaleY", h),
                      (h += "X");
                  else {
                    if ("transformOrigin" === h) {
                      x.push(oi, 0, w[oi]),
                        (S = void 0),
                        (E = void 0),
                        (M = void 0),
                        (S = (b = o).split(" ")),
                        (E = S[0]),
                        (M = S[1] || "50%"),
                        ("top" !== E &&
                          "bottom" !== E &&
                          "left" !== M &&
                          "right" !== M) ||
                          ((b = E), (E = M), (M = b)),
                        (S[0] = Di[E] || E),
                        (S[1] = Di[M] || M),
                        (o = S.join(" ")),
                        v.svg
                          ? Fi(t, o, 0, _, 0, this)
                          : ((p = parseFloat(o.split(" ")[2]) || 0) !==
                              v.zOrigin && bi(this, v, "zOrigin", v.zOrigin, p),
                            bi(this, w, h, Ni(s), Ni(o)));
                      continue;
                    }
                    if ("svgOrigin" === h) {
                      Fi(t, o, 1, _, 0, this);
                      continue;
                    }
                    if (h in Ri) {
                      Vi(this, v, h, l, f ? Et(l, f + o) : o);
                      continue;
                    }
                    if ("smoothOrigin" === h) {
                      bi(this, v, "smooth", v.smooth, o);
                      continue;
                    }
                    if ("force3D" === h) {
                      v[h] = o;
                      continue;
                    }
                    if ("transform" === h) {
                      Wi(this, o, t);
                      continue;
                    }
                  }
                else h in w || (h = fi(h) || h);
                if (
                  m ||
                  ((a || 0 === a) && (l || 0 === l) && !jn.test(o) && h in w)
                )
                  a || (a = 0),
                    (d = (s + "").substr((l + "").length)) !==
                      (p = ie(o) || (h in D.units ? D.units[h] : d)) &&
                      (l = Mi(t, h, s, p)),
                    (this._pt = new vn(
                      this._pt,
                      m ? v : w,
                      h,
                      l,
                      (f ? Et(l, f + a) : a) - l,
                      m || ("px" !== p && "zIndex" !== h) || !1 === e.autoRound
                        ? qn
                        : Zn
                    )),
                    (this._pt.u = p || 0),
                    d !== p &&
                      "%" !== p &&
                      ((this._pt.b = s), (this._pt.r = Kn));
                else if (h in w) wi.call(this, t, h, s, f ? f + o : o);
                else if (h in t) this.add(t, h, s || t[h], f ? f + o : o, i, r);
                else if ("parseTransform" !== h) {
                  nt(h, o);
                  continue;
                }
                m || (h in w ? x.push(h, 0, w[h]) : x.push(h, 1, s || t[h])),
                  T.push(h);
              }
          y && gn(this);
        },
        render: function (t, e) {
          if (e.tween._time || !Nn())
            for (var n = e._pt; n; ) n.r(t, n.d), (n = n._next);
          else e.styles.revert();
        },
        get: Ti,
        aliases: Xn,
        getSetter: function (t, e, n) {
          var i = Xn[e];
          return (
            i && i.indexOf(",") < 0 && (e = i),
            e in zn && e !== oi && (t._gsap.x || Ti(t, "x"))
              ? n && Un === n
                ? "scale" === e
                  ? ni
                  : ei
                : (Un = n || {}) && ("scale" === e ? ii : ri)
              : t.style && !z(t.style[e])
              ? Qn
              : ~e.indexOf("-")
              ? ti
              : ln(t, e)
          );
        },
        core: {
          _removeProperty: xi,
          _getMatrix: Ii,
        },
      };
    (Pn.utils.checkPrefix = fi),
      (Pn.core.getStyleSaver = ui),
      (Xi = xt(
        "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," +
          (ji = "rotation,rotationX,rotationY,skewX,skewY") +
          ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
        function (t) {
          zn[t] = 1;
        }
      )),
      xt(ji, function (t) {
        (D.units[t] = "deg"), (Ri[t] = 1);
      }),
      (Xn[Xi[13]] = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent," + ji),
      xt(
        "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
        function (t) {
          var e = t.split(":");
          Xn[e[1]] = Xi[e[0]];
        }
      ),
      xt(
        "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
        function (t) {
          D.units[t] = "px";
        }
      ),
      Pn.registerPlugin(qi);
    var Yi = Pn.registerPlugin(qi) || Pn;
    Yi.core.Tween;
    function Ki(t, e) {
      for (var n = 0; n < e.length; n++) {
        var i = e[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(t, i.key, i);
      }
    }
    /*!
     * Observer 3.12.2
     * https://greensock.com
     *
     * @license Copyright 2008-2023, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Zi,
      Ji,
      $i,
      Qi,
      tr,
      er,
      nr,
      ir,
      rr,
      sr,
      or,
      ar,
      lr,
      cr = function () {
        return (
          Zi ||
          ("undefined" != typeof window &&
            (Zi = window.gsap) &&
            Zi.registerPlugin &&
            Zi)
        );
      },
      ur = 1,
      hr = [],
      dr = [],
      pr = [],
      fr = Date.now,
      mr = function (t, e) {
        return e;
      },
      gr = function (t, e) {
        return ~pr.indexOf(t) && pr[pr.indexOf(t) + 1][e];
      },
      vr = function (t) {
        return !!~sr.indexOf(t);
      },
      _r = function (t, e, n, i, r) {
        return t.addEventListener(e, n, {
          passive: !i,
          capture: !!r,
        });
      },
      yr = function (t, e, n, i) {
        return t.removeEventListener(e, n, !!i);
      },
      xr = function () {
        return (or && or.isPressed) || dr.cache++;
      },
      br = function (t, e) {
        var n = function n(i) {
          if (i || 0 === i) {
            ur && ($i.history.scrollRestoration = "manual");
            var r = or && or.isPressed;
            (i = n.v = Math.round(i) || (or && or.iOS ? 1 : 0)),
              t(i),
              (n.cacheID = dr.cache),
              r && mr("ss", i);
          } else
            (e || dr.cache !== n.cacheID || mr("ref")) &&
              ((n.cacheID = dr.cache), (n.v = t()));
          return n.v + n.offset;
        };
        return (n.offset = 0), t && n;
      },
      Sr = {
        s: "scrollLeft",
        p: "left",
        p2: "Left",
        os: "right",
        os2: "Right",
        d: "width",
        d2: "Width",
        a: "x",
        sc: br(function (t) {
          return arguments.length
            ? $i.scrollTo(t, Er.sc())
            : $i.pageXOffset ||
                Qi.scrollLeft ||
                tr.scrollLeft ||
                er.scrollLeft ||
                0;
        }),
      },
      Er = {
        s: "scrollTop",
        p: "top",
        p2: "Top",
        os: "bottom",
        os2: "Bottom",
        d: "height",
        d2: "Height",
        a: "y",
        op: Sr,
        sc: br(function (t) {
          return arguments.length
            ? $i.scrollTo(Sr.sc(), t)
            : $i.pageYOffset ||
                Qi.scrollTop ||
                tr.scrollTop ||
                er.scrollTop ||
                0;
        }),
      },
      Mr = function (t, e) {
        return (
          ((e && e._ctx && e._ctx.selector) || Zi.utils.toArray)(t)[0] ||
          ("string" == typeof t && !1 !== Zi.config().nullTargetWarn
            ? console.warn("Element not found:", t)
            : null)
        );
      },
      Tr = function (t, e) {
        var n = e.s,
          i = e.sc;
        vr(t) && (t = Qi.scrollingElement || tr);
        var r = dr.indexOf(t),
          s = i === Er.sc ? 1 : 2;
        !~r && (r = dr.push(t) - 1), dr[r + s] || _r(t, "scroll", xr);
        var o = dr[r + s],
          a =
            o ||
            (dr[r + s] =
              br(gr(t, n), !0) ||
              (vr(t)
                ? i
                : br(function (e) {
                    return arguments.length ? (t[n] = e) : t[n];
                  })));
        return (
          (a.target = t),
          o || (a.smooth = "smooth" === Zi.getProperty(t, "scrollBehavior")),
          a
        );
      },
      wr = function (t, e, n) {
        var i = t,
          r = t,
          s = fr(),
          o = s,
          a = e || 50,
          l = Math.max(500, 3 * a),
          c = function (t, e) {
            var l = fr();
            e || l - s > a
              ? ((r = i), (i = t), (o = s), (s = l))
              : n
              ? (i += t)
              : (i = r + ((t - r) / (l - o)) * (s - o));
          };
        return {
          update: c,
          reset: function () {
            (r = i = n ? 0 : i), (o = s = 0);
          },
          getVelocity: function (t) {
            var e = o,
              a = r,
              u = fr();
            return (
              (t || 0 === t) && t !== i && c(t),
              s === o || u - o > l
                ? 0
                : ((i + (n ? a : -a)) / ((n ? u : s) - e)) * 1e3
            );
          },
        };
      },
      Dr = function (t, e) {
        return (
          e && !t._gsapAllow && t.preventDefault(),
          t.changedTouches ? t.changedTouches[0] : t
        );
      },
      Ar = function (t) {
        var e = Math.max.apply(Math, t),
          n = Math.min.apply(Math, t);
        return Math.abs(e) >= Math.abs(n) ? e : n;
      },
      Cr = function () {
        (rr = Zi.core.globals().ScrollTrigger) &&
          rr.core &&
          (function () {
            var t = rr.core,
              e = t.bridge || {},
              n = t._scrollers,
              i = t._proxies;
            n.push.apply(n, dr),
              i.push.apply(i, pr),
              (dr = n),
              (pr = i),
              (mr = function (t, n) {
                return e[t](n);
              });
          })();
      },
      Pr = function (t) {
        return (
          (Zi = t || cr()) &&
            "undefined" != typeof document &&
            document.body &&
            (($i = window),
            (Qi = document),
            (tr = Qi.documentElement),
            (er = Qi.body),
            (sr = [$i, Qi, tr, er]),
            Zi.utils.clamp,
            (lr = Zi.core.context || function () {}),
            (ir = "onpointerenter" in er ? "pointer" : "mouse"),
            (nr = Rr.isTouch =
              $i.matchMedia &&
              $i.matchMedia("(hover: none), (pointer: coarse)").matches
                ? 1
                : "ontouchstart" in $i ||
                  navigator.maxTouchPoints > 0 ||
                  navigator.msMaxTouchPoints > 0
                ? 2
                : 0),
            (ar = Rr.eventTypes =
              (
                "ontouchstart" in tr
                  ? "touchstart,touchmove,touchcancel,touchend"
                  : "onpointerdown" in tr
                  ? "pointerdown,pointermove,pointercancel,pointerup"
                  : "mousedown,mousemove,mouseup,mouseup"
              ).split(",")),
            setTimeout(function () {
              return (ur = 0);
            }, 500),
            Cr(),
            (Ji = 1)),
          Ji
        );
      };
    (Sr.op = Er), (dr.cache = 0);
    var Rr = (function () {
      function t(t) {
        this.init(t);
      }
      var e, n, i;
      return (
        (t.prototype.init = function (t) {
          Ji || Pr(Zi) || console.warn("Please gsap.registerPlugin(Observer)"),
            rr || Cr();
          var e = t.tolerance,
            n = t.dragMinimum,
            i = t.type,
            r = t.target,
            s = t.lineHeight,
            o = t.debounce,
            a = t.preventDefault,
            l = t.onStop,
            c = t.onStopDelay,
            u = t.ignore,
            h = t.wheelSpeed,
            d = t.event,
            p = t.onDragStart,
            f = t.onDragEnd,
            m = t.onDrag,
            g = t.onPress,
            v = t.onRelease,
            _ = t.onRight,
            y = t.onLeft,
            x = t.onUp,
            b = t.onDown,
            S = t.onChangeX,
            E = t.onChangeY,
            M = t.onChange,
            T = t.onToggleX,
            w = t.onToggleY,
            D = t.onHover,
            A = t.onHoverEnd,
            C = t.onMove,
            P = t.ignoreCheck,
            R = t.isNormalizer,
            L = t.onGestureStart,
            O = t.onGestureEnd,
            I = t.onWheel,
            F = t.onEnable,
            U = t.onDisable,
            N = t.onClick,
            k = t.scrollSpeed,
            z = t.capture,
            B = t.allowClicks,
            H = t.lockAxis,
            V = t.onLockAxis;
          (this.target = r = Mr(r) || tr),
            (this.vars = t),
            u && (u = Zi.utils.toArray(u)),
            (e = e || 1e-9),
            (n = n || 0),
            (h = h || 1),
            (k = k || 1),
            (i = i || "wheel,touch,pointer"),
            (o = !1 !== o),
            s || (s = parseFloat($i.getComputedStyle(er).lineHeight) || 22);
          var G,
            W,
            j,
            X,
            q,
            Y,
            K,
            Z = this,
            J = 0,
            $ = 0,
            Q = Tr(r, Sr),
            tt = Tr(r, Er),
            et = Q(),
            nt = tt(),
            it =
              ~i.indexOf("touch") &&
              !~i.indexOf("pointer") &&
              "pointerdown" === ar[0],
            rt = vr(r),
            st = r.ownerDocument || Qi,
            ot = [0, 0, 0],
            at = [0, 0, 0],
            lt = 0,
            ct = function () {
              return (lt = fr());
            },
            ut = function (t, e) {
              return (
                ((Z.event = t) && u && ~u.indexOf(t.target)) ||
                (e && it && "touch" !== t.pointerType) ||
                (P && P(t, e))
              );
            },
            ht = function () {
              var t = (Z.deltaX = Ar(ot)),
                n = (Z.deltaY = Ar(at)),
                i = Math.abs(t) >= e,
                r = Math.abs(n) >= e;
              M && (i || r) && M(Z, t, n, ot, at),
                i &&
                  (_ && Z.deltaX > 0 && _(Z),
                  y && Z.deltaX < 0 && y(Z),
                  S && S(Z),
                  T && Z.deltaX < 0 != J < 0 && T(Z),
                  (J = Z.deltaX),
                  (ot[0] = ot[1] = ot[2] = 0)),
                r &&
                  (b && Z.deltaY > 0 && b(Z),
                  x && Z.deltaY < 0 && x(Z),
                  E && E(Z),
                  w && Z.deltaY < 0 != $ < 0 && w(Z),
                  ($ = Z.deltaY),
                  (at[0] = at[1] = at[2] = 0)),
                (X || j) && (C && C(Z), j && (m(Z), (j = !1)), (X = !1)),
                Y && !(Y = !1) && V && V(Z),
                q && (I(Z), (q = !1)),
                (G = 0);
            },
            dt = function (t, e, n) {
              (ot[n] += t),
                (at[n] += e),
                Z._vx.update(t),
                Z._vy.update(e),
                o ? G || (G = requestAnimationFrame(ht)) : ht();
            },
            pt = function (t, e) {
              H &&
                !K &&
                ((Z.axis = K = Math.abs(t) > Math.abs(e) ? "x" : "y"),
                (Y = !0)),
                "y" !== K && ((ot[2] += t), Z._vx.update(t, !0)),
                "x" !== K && ((at[2] += e), Z._vy.update(e, !0)),
                o ? G || (G = requestAnimationFrame(ht)) : ht();
            },
            ft = function (t) {
              if (!ut(t, 1)) {
                var e = (t = Dr(t, a)).clientX,
                  i = t.clientY,
                  r = e - Z.x,
                  s = i - Z.y,
                  o = Z.isDragging;
                (Z.x = e),
                  (Z.y = i),
                  (o ||
                    Math.abs(Z.startX - e) >= n ||
                    Math.abs(Z.startY - i) >= n) &&
                    (m && (j = !0),
                    o || (Z.isDragging = !0),
                    pt(r, s),
                    o || (p && p(Z)));
              }
            },
            mt = (Z.onPress = function (t) {
              ut(t, 1) ||
                (t && t.button) ||
                ((Z.axis = K = null),
                W.pause(),
                (Z.isPressed = !0),
                (t = Dr(t)),
                (J = $ = 0),
                (Z.startX = Z.x = t.clientX),
                (Z.startY = Z.y = t.clientY),
                Z._vx.reset(),
                Z._vy.reset(),
                _r(R ? r : st, ar[1], ft, a, !0),
                (Z.deltaX = Z.deltaY = 0),
                g && g(Z));
            }),
            gt = (Z.onRelease = function (t) {
              if (!ut(t, 1)) {
                yr(R ? r : st, ar[1], ft, !0);
                var e = !isNaN(Z.y - Z.startY),
                  n =
                    Z.isDragging &&
                    (Math.abs(Z.x - Z.startX) > 3 ||
                      Math.abs(Z.y - Z.startY) > 3),
                  i = Dr(t);
                !n &&
                  e &&
                  (Z._vx.reset(),
                  Z._vy.reset(),
                  a &&
                    B &&
                    Zi.delayedCall(0.08, function () {
                      if (fr() - lt > 300 && !t.defaultPrevented)
                        if (t.target.click) t.target.click();
                        else if (st.createEvent) {
                          var e = st.createEvent("MouseEvents");
                          e.initMouseEvent(
                            "click",
                            !0,
                            !0,
                            $i,
                            1,
                            i.screenX,
                            i.screenY,
                            i.clientX,
                            i.clientY,
                            !1,
                            !1,
                            !1,
                            !1,
                            0,
                            null
                          ),
                            t.target.dispatchEvent(e);
                        }
                    })),
                  (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
                  l && !R && W.restart(!0),
                  f && n && f(Z),
                  v && v(Z, n);
              }
            }),
            vt = function (t) {
              return (
                t.touches &&
                t.touches.length > 1 &&
                (Z.isGesturing = !0) &&
                L(t, Z.isDragging)
              );
            },
            _t = function () {
              return (Z.isGesturing = !1) || O(Z);
            },
            yt = function (t) {
              if (!ut(t)) {
                var e = Q(),
                  n = tt();
                dt((e - et) * k, (n - nt) * k, 1),
                  (et = e),
                  (nt = n),
                  l && W.restart(!0);
              }
            },
            xt = function (t) {
              if (!ut(t)) {
                (t = Dr(t, a)), I && (q = !0);
                var e =
                  (1 === t.deltaMode
                    ? s
                    : 2 === t.deltaMode
                    ? $i.innerHeight
                    : 1) * h;
                dt(t.deltaX * e, t.deltaY * e, 0), l && !R && W.restart(!0);
              }
            },
            bt = function (t) {
              if (!ut(t)) {
                var e = t.clientX,
                  n = t.clientY,
                  i = e - Z.x,
                  r = n - Z.y;
                (Z.x = e), (Z.y = n), (X = !0), (i || r) && pt(i, r);
              }
            },
            St = function (t) {
              (Z.event = t), D(Z);
            },
            Et = function (t) {
              (Z.event = t), A(Z);
            },
            Mt = function (t) {
              return ut(t) || (Dr(t, a) && N(Z));
            };
          (W = Z._dc =
            Zi.delayedCall(c || 0.25, function () {
              Z._vx.reset(), Z._vy.reset(), W.pause(), l && l(Z);
            }).pause()),
            (Z.deltaX = Z.deltaY = 0),
            (Z._vx = wr(0, 50, !0)),
            (Z._vy = wr(0, 50, !0)),
            (Z.scrollX = Q),
            (Z.scrollY = tt),
            (Z.isDragging = Z.isGesturing = Z.isPressed = !1),
            lr(this),
            (Z.enable = function (t) {
              return (
                Z.isEnabled ||
                  (_r(rt ? st : r, "scroll", xr),
                  i.indexOf("scroll") >= 0 &&
                    _r(rt ? st : r, "scroll", yt, a, z),
                  i.indexOf("wheel") >= 0 && _r(r, "wheel", xt, a, z),
                  ((i.indexOf("touch") >= 0 && nr) ||
                    i.indexOf("pointer") >= 0) &&
                    (_r(r, ar[0], mt, a, z),
                    _r(st, ar[2], gt),
                    _r(st, ar[3], gt),
                    B && _r(r, "click", ct, !1, !0),
                    N && _r(r, "click", Mt),
                    L && _r(st, "gesturestart", vt),
                    O && _r(st, "gestureend", _t),
                    D && _r(r, ir + "enter", St),
                    A && _r(r, ir + "leave", Et),
                    C && _r(r, ir + "move", bt)),
                  (Z.isEnabled = !0),
                  t && t.type && mt(t),
                  F && F(Z)),
                Z
              );
            }),
            (Z.disable = function () {
              Z.isEnabled &&
                (hr.filter(function (t) {
                  return t !== Z && vr(t.target);
                }).length || yr(rt ? st : r, "scroll", xr),
                Z.isPressed &&
                  (Z._vx.reset(), Z._vy.reset(), yr(R ? r : st, ar[1], ft, !0)),
                yr(rt ? st : r, "scroll", yt, z),
                yr(r, "wheel", xt, z),
                yr(r, ar[0], mt, z),
                yr(st, ar[2], gt),
                yr(st, ar[3], gt),
                yr(r, "click", ct, !0),
                yr(r, "click", Mt),
                yr(st, "gesturestart", vt),
                yr(st, "gestureend", _t),
                yr(r, ir + "enter", St),
                yr(r, ir + "leave", Et),
                yr(r, ir + "move", bt),
                (Z.isEnabled = Z.isPressed = Z.isDragging = !1),
                U && U(Z));
            }),
            (Z.kill = Z.revert =
              function () {
                Z.disable();
                var t = hr.indexOf(Z);
                t >= 0 && hr.splice(t, 1), or === Z && (or = 0);
              }),
            hr.push(Z),
            R && vr(r) && (or = Z),
            Z.enable(d);
        }),
        (e = t),
        (n = [
          {
            key: "velocityX",
            get: function () {
              return this._vx.getVelocity();
            },
          },
          {
            key: "velocityY",
            get: function () {
              return this._vy.getVelocity();
            },
          },
        ]) && Ki(e.prototype, n),
        i && Ki(e, i),
        t
      );
    })();
    (Rr.version = "3.12.2"),
      (Rr.create = function (t) {
        return new Rr(t);
      }),
      (Rr.register = Pr),
      (Rr.getAll = function () {
        return hr.slice();
      }),
      (Rr.getById = function (t) {
        return hr.filter(function (e) {
          return e.vars.id === t;
        })[0];
      }),
      cr() && Zi.registerPlugin(Rr);
    /*!
     * ScrollTrigger 3.12.2
     * https://greensock.com
     *
     * @license Copyright 2008-2023, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var Lr,
      Or,
      Ir,
      Fr,
      Ur,
      Nr,
      kr,
      zr,
      Br,
      Hr,
      Vr,
      Gr,
      Wr,
      jr,
      Xr,
      qr,
      Yr,
      Kr,
      Zr,
      Jr,
      $r,
      Qr,
      ts,
      es,
      ns,
      is,
      rs,
      ss,
      os,
      as,
      ls,
      cs,
      us,
      hs,
      ds,
      ps,
      fs = 1,
      ms = Date.now,
      gs = ms(),
      vs = 0,
      _s = 0,
      ys = function (t, e, n) {
        var i = Ls(t) && ("clamp(" === t.substr(0, 6) || t.indexOf("max") > -1);
        return (n["_" + e + "Clamp"] = i), i ? t.substr(6, t.length - 7) : t;
      },
      xs = function (t, e) {
        return !e || (Ls(t) && "clamp(" === t.substr(0, 6))
          ? t
          : "clamp(" + t + ")";
      },
      bs = function () {
        return (jr = 1);
      },
      Ss = function () {
        return (jr = 0);
      },
      Es = function (t) {
        return t;
      },
      Ms = function (t) {
        return Math.round(1e5 * t) / 1e5 || 0;
      },
      Ts = function () {
        return "undefined" != typeof window;
      },
      ws = function () {
        return Lr || (Ts() && (Lr = window.gsap) && Lr.registerPlugin && Lr);
      },
      Ds = function (t) {
        return !!~kr.indexOf(t);
      },
      As = function (t) {
        return (
          ("Height" === t ? ls : Ir["inner" + t]) ||
          Ur["client" + t] ||
          Nr["client" + t]
        );
      },
      Cs = function (t) {
        return (
          gr(t, "getBoundingClientRect") ||
          (Ds(t)
            ? function () {
                return (Po.width = Ir.innerWidth), (Po.height = ls), Po;
              }
            : function () {
                return Gs(t);
              })
        );
      },
      Ps = function (t, e) {
        var n = e.s,
          i = e.d2,
          r = e.d,
          s = e.a;
        return Math.max(
          0,
          (n = "scroll" + i) && (s = gr(t, n))
            ? s() - Cs(t)()[r]
            : Ds(t)
            ? (Ur[n] || Nr[n]) - As(i)
            : t[n] - t["offset" + i]
        );
      },
      Rs = function (t, e) {
        for (var n = 0; n < Zr.length; n += 3)
          (!e || ~e.indexOf(Zr[n + 1])) && t(Zr[n], Zr[n + 1], Zr[n + 2]);
      },
      Ls = function (t) {
        return "string" == typeof t;
      },
      Os = function (t) {
        return "function" == typeof t;
      },
      Is = function (t) {
        return "number" == typeof t;
      },
      Fs = function (t) {
        return "object" == typeof t;
      },
      Us = function (t, e, n) {
        return t && t.progress(e ? 0 : 1) && n && t.pause();
      },
      Ns = function (t, e) {
        if (t.enabled) {
          var n = e(t);
          n && n.totalTime && (t.callbackAnimation = n);
        }
      },
      ks = Math.abs,
      zs = "padding",
      Bs = "px",
      Hs = function (t) {
        return Ir.getComputedStyle(t);
      },
      Vs = function (t, e) {
        for (var n in e) n in t || (t[n] = e[n]);
        return t;
      },
      Gs = function (t, e) {
        var n =
            e &&
            "matrix(1, 0, 0, 1, 0, 0)" !== Hs(t)[Xr] &&
            Lr.to(t, {
              x: 0,
              y: 0,
              xPercent: 0,
              yPercent: 0,
              rotation: 0,
              rotationX: 0,
              rotationY: 0,
              scale: 1,
              skewX: 0,
              skewY: 0,
            }).progress(1),
          i = t.getBoundingClientRect();
        return n && n.progress(0).kill(), i;
      },
      Ws = function (t, e) {
        var n = e.d2;
        return t["offset" + n] || t["client" + n] || 0;
      },
      js = function (t) {
        var e,
          n = [],
          i = t.labels,
          r = t.duration();
        for (e in i) n.push(i[e] / r);
        return n;
      },
      Xs = function (t) {
        var e = Lr.utils.snap(t),
          n =
            Array.isArray(t) &&
            t.slice(0).sort(function (t, e) {
              return t - e;
            });
        return n
          ? function (t, i, r) {
              var s;
              if ((void 0 === r && (r = 0.001), !i)) return e(t);
              if (i > 0) {
                for (t -= r, s = 0; s < n.length; s++)
                  if (n[s] >= t) return n[s];
                return n[s - 1];
              }
              for (s = n.length, t += r; s--; ) if (n[s] <= t) return n[s];
              return n[0];
            }
          : function (n, i, r) {
              void 0 === r && (r = 0.001);
              var s = e(n);
              return !i || Math.abs(s - n) < r || s - n < 0 == i < 0
                ? s
                : e(i < 0 ? n - t : n + t);
            };
      },
      qs = function (t, e, n, i) {
        return n.split(",").forEach(function (n) {
          return t(e, n, i);
        });
      },
      Ys = function (t, e, n, i, r) {
        return t.addEventListener(e, n, {
          passive: !i,
          capture: !!r,
        });
      },
      Ks = function (t, e, n, i) {
        return t.removeEventListener(e, n, !!i);
      },
      Zs = function (t, e, n) {
        (n = n && n.wheelHandler) && (t(e, "wheel", n), t(e, "touchmove", n));
      },
      Js = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal",
      },
      $s = {
        toggleActions: "play",
        anticipatePin: 0,
      },
      Qs = {
        top: 0,
        left: 0,
        center: 0.5,
        bottom: 1,
        right: 1,
      },
      to = function (t, e) {
        if (Ls(t)) {
          var n = t.indexOf("="),
            i = ~n ? +(t.charAt(n - 1) + 1) * parseFloat(t.substr(n + 1)) : 0;
          ~n &&
            (t.indexOf("%") > n && (i *= e / 100), (t = t.substr(0, n - 1))),
            (t =
              i +
              (t in Qs
                ? Qs[t] * e
                : ~t.indexOf("%")
                ? (parseFloat(t) * e) / 100
                : parseFloat(t) || 0));
        }
        return t;
      },
      eo = function (t, e, n, i, r, s, o, a) {
        var l = r.startColor,
          c = r.endColor,
          u = r.fontSize,
          h = r.indent,
          d = r.fontWeight,
          p = Fr.createElement("div"),
          f = Ds(n) || "fixed" === gr(n, "pinType"),
          m = -1 !== t.indexOf("scroller"),
          g = f ? Nr : n,
          v = -1 !== t.indexOf("start"),
          _ = v ? l : c,
          y =
            "border-color:" +
            _ +
            ";font-size:" +
            u +
            ";color:" +
            _ +
            ";font-weight:" +
            d +
            ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return (
          (y += "position:" + ((m || a) && f ? "fixed;" : "absolute;")),
          (m || a || !f) &&
            (y +=
              (i === Er ? "right" : "bottom") +
              ":" +
              (s + parseFloat(h)) +
              "px;"),
          o &&
            (y +=
              "box-sizing:border-box;text-align:left;width:" +
              o.offsetWidth +
              "px;"),
          (p._isStart = v),
          p.setAttribute(
            "class",
            "gsap-marker-" + t + (e ? " marker-" + e : "")
          ),
          (p.style.cssText = y),
          (p.innerText = e || 0 === e ? t + "-" + e : t),
          g.children[0] ? g.insertBefore(p, g.children[0]) : g.appendChild(p),
          (p._offset = p["offset" + i.op.d2]),
          no(p, 0, i, v),
          p
        );
      },
      no = function (t, e, n, i) {
        var r = {
            display: "block",
          },
          s = n[i ? "os2" : "p2"],
          o = n[i ? "p2" : "os2"];
        (t._isFlipped = i),
          (r[n.a + "Percent"] = i ? -100 : 0),
          (r[n.a] = i ? "1px" : 0),
          (r["border" + s + "Width"] = 1),
          (r["border" + o + "Width"] = 0),
          (r[n.p] = e + "px"),
          Lr.set(t, r);
      },
      io = [],
      ro = {},
      so = function () {
        return ms() - vs > 34 && (us || (us = requestAnimationFrame(Eo)));
      },
      oo = function () {
        (!ts || !ts.isPressed || ts.startX > Nr.clientWidth) &&
          (dr.cache++,
          ts ? us || (us = requestAnimationFrame(Eo)) : Eo(),
          vs || po("scrollStart"),
          (vs = ms()));
      },
      ao = function () {
        (is = Ir.innerWidth), (ns = Ir.innerHeight);
      },
      lo = function () {
        dr.cache++,
          !Wr &&
            !Qr &&
            !Fr.fullscreenElement &&
            !Fr.webkitFullscreenElement &&
            (!es ||
              is !== Ir.innerWidth ||
              Math.abs(Ir.innerHeight - ns) > 0.25 * Ir.innerHeight) &&
            zr.restart(!0);
      },
      co = {},
      uo = [],
      ho = function t() {
        return Ks(No, "scrollEnd", t) || xo(!0);
      },
      po = function (t) {
        return (
          (co[t] &&
            co[t].map(function (t) {
              return t();
            })) ||
          uo
        );
      },
      fo = [],
      mo = function (t) {
        for (var e = 0; e < fo.length; e += 5)
          (!t || (fo[e + 4] && fo[e + 4].query === t)) &&
            ((fo[e].style.cssText = fo[e + 1]),
            fo[e].getBBox && fo[e].setAttribute("transform", fo[e + 2] || ""),
            (fo[e + 3].uncache = 1));
      },
      go = function (t, e) {
        var n;
        for (qr = 0; qr < io.length; qr++)
          !(n = io[qr]) ||
            (e && n._ctx !== e) ||
            (t ? n.kill(1) : n.revert(!0, !0));
        e && mo(e), e || po("revert");
      },
      vo = function (t, e) {
        dr.cache++,
          (e || !hs) &&
            dr.forEach(function (t) {
              return Os(t) && t.cacheID++ && (t.rec = 0);
            }),
          Ls(t) && (Ir.history.scrollRestoration = os = t);
      },
      _o = 0,
      yo = function () {
        Nr.appendChild(as),
          (ls = as.offsetHeight || Ir.innerHeight),
          Nr.removeChild(as);
      },
      xo = function (t, e) {
        if (!vs || t) {
          yo(),
            (hs = No.isRefreshing = !0),
            dr.forEach(function (t) {
              return Os(t) && ++t.cacheID && (t.rec = t());
            });
          var n = po("refreshInit");
          Jr && No.sort(),
            e || go(),
            dr.forEach(function (t) {
              Os(t) &&
                (t.smooth && (t.target.style.scrollBehavior = "auto"), t(0));
            }),
            io.slice(0).forEach(function (t) {
              return t.refresh();
            }),
            io.forEach(function (t, e) {
              if (t._subPinOffset && t.pin) {
                var n = t.vars.horizontal ? "offsetWidth" : "offsetHeight",
                  i = t.pin[n];
                t.revert(!0, 1), t.adjustPinSpacing(t.pin[n] - i), t.refresh();
              }
            }),
            io.forEach(function (t) {
              var e = Ps(t.scroller, t._dir);
              ("max" === t.vars.end || (t._endClamp && t.end > e)) &&
                t.setPositions(t.start, Math.max(t.start + 1, e), !0);
            }),
            n.forEach(function (t) {
              return t && t.render && t.render(-1);
            }),
            dr.forEach(function (t) {
              Os(t) &&
                (t.smooth &&
                  requestAnimationFrame(function () {
                    return (t.target.style.scrollBehavior = "smooth");
                  }),
                t.rec && t(t.rec));
            }),
            vo(os, 1),
            zr.pause(),
            _o++,
            (hs = 2),
            Eo(2),
            io.forEach(function (t) {
              return Os(t.vars.onRefresh) && t.vars.onRefresh(t);
            }),
            (hs = No.isRefreshing = !1),
            po("refresh");
        } else Ys(No, "scrollEnd", ho);
      },
      bo = 0,
      So = 1,
      Eo = function (t) {
        if (!hs || 2 === t) {
          (No.isUpdating = !0), ps && ps.update(0);
          var e = io.length,
            n = ms(),
            i = n - gs >= 50,
            r = e && io[0].scroll();
          if (
            ((So = bo > r ? -1 : 1),
            hs || (bo = r),
            i &&
              (vs && !jr && n - vs > 200 && ((vs = 0), po("scrollEnd")),
              (Vr = gs),
              (gs = n)),
            So < 0)
          ) {
            for (qr = e; qr-- > 0; ) io[qr] && io[qr].update(0, i);
            So = 1;
          } else for (qr = 0; qr < e; qr++) io[qr] && io[qr].update(0, i);
          No.isUpdating = !1;
        }
        us = 0;
      },
      Mo = [
        "left",
        "top",
        "bottom",
        "right",
        "marginBottom",
        "marginRight",
        "marginTop",
        "marginLeft",
        "display",
        "flexShrink",
        "float",
        "zIndex",
        "gridColumnStart",
        "gridColumnEnd",
        "gridRowStart",
        "gridRowEnd",
        "gridArea",
        "justifySelf",
        "alignSelf",
        "placeSelf",
        "order",
      ],
      To = Mo.concat([
        "width",
        "height",
        "boxSizing",
        "maxWidth",
        "maxHeight",
        "position",
        "margin",
        zs,
        zs + "Top",
        zs + "Right",
        zs + "Bottom",
        zs + "Left",
      ]),
      wo = function (t, e, n, i) {
        if (!t._gsap.swappedIn) {
          for (var r, s = Mo.length, o = e.style, a = t.style; s--; )
            o[(r = Mo[s])] = n[r];
          (o.position = "absolute" === n.position ? "absolute" : "relative"),
            "inline" === n.display && (o.display = "inline-block"),
            (a.bottom = a.right = "auto"),
            (o.flexBasis = n.flexBasis || "auto"),
            (o.overflow = "visible"),
            (o.boxSizing = "border-box"),
            (o.width = Ws(t, Sr) + Bs),
            (o.height = Ws(t, Er) + Bs),
            (o[zs] = a.margin = a.top = a.left = "0"),
            Ao(i),
            (a.width = a.maxWidth = n.width),
            (a.height = a.maxHeight = n.height),
            (a[zs] = n[zs]),
            t.parentNode !== e &&
              (t.parentNode.insertBefore(e, t), e.appendChild(t)),
            (t._gsap.swappedIn = !0);
        }
      },
      Do = /([A-Z])/g,
      Ao = function (t) {
        if (t) {
          var e,
            n,
            i = t.t.style,
            r = t.length,
            s = 0;
          for ((t.t._gsap || Lr.core.getCache(t.t)).uncache = 1; s < r; s += 2)
            (n = t[s + 1]),
              (e = t[s]),
              n
                ? (i[e] = n)
                : i[e] && i.removeProperty(e.replace(Do, "-$1").toLowerCase());
        }
      },
      Co = function (t) {
        for (var e = To.length, n = t.style, i = [], r = 0; r < e; r++)
          i.push(To[r], n[To[r]]);
        return (i.t = t), i;
      },
      Po = {
        left: 0,
        top: 0,
      },
      Ro = function (t, e, n, i, r, s, o, a, l, c, u, h, d, p) {
        Os(t) && (t = t(a)),
          Ls(t) &&
            "max" === t.substr(0, 3) &&
            (t = h + ("=" === t.charAt(4) ? to("0" + t.substr(3), n) : 0));
        var f,
          m,
          g,
          v = d ? d.time() : 0;
        if ((d && d.seek(0), isNaN(t) || (t = +t), Is(t)))
          d &&
            (t = Lr.utils.mapRange(
              d.scrollTrigger.start,
              d.scrollTrigger.end,
              0,
              h,
              t
            )),
            o && no(o, n, i, !0);
        else {
          Os(e) && (e = e(a));
          var _,
            y,
            x,
            b,
            S = (t || "0").split(" ");
          (g = Mr(e, a) || Nr),
            ((_ = Gs(g) || {}) && (_.left || _.top)) ||
              "none" !== Hs(g).display ||
              ((b = g.style.display),
              (g.style.display = "block"),
              (_ = Gs(g)),
              b ? (g.style.display = b) : g.style.removeProperty("display")),
            (y = to(S[0], _[i.d])),
            (x = to(S[1] || "0", n)),
            (t = _[i.p] - l[i.p] - c + y + r - x),
            o && no(o, x, i, n - x < 20 || (o._isStart && x > 20)),
            (n -= n - x);
        }
        if ((p && ((a[p] = t || -0.001), t < 0 && (t = 0)), s)) {
          var E = t + n,
            M = s._isStart;
          (f = "scroll" + i.d2),
            no(
              s,
              E,
              i,
              (M && E > 20) ||
                (!M && (u ? Math.max(Nr[f], Ur[f]) : s.parentNode[f]) <= E + 1)
            ),
            u &&
              ((l = Gs(o)),
              u && (s.style[i.op.p] = l[i.op.p] - i.op.m - s._offset + Bs));
        }
        return (
          d &&
            g &&
            ((f = Gs(g)),
            d.seek(h),
            (m = Gs(g)),
            (d._caScrollDist = f[i.p] - m[i.p]),
            (t = (t / d._caScrollDist) * h)),
          d && d.seek(v),
          d ? t : Math.round(t)
        );
      },
      Lo = /(webkit|moz|length|cssText|inset)/i,
      Oo = function (t, e, n, i) {
        if (t.parentNode !== e) {
          var r,
            s,
            o = t.style;
          if (e === Nr) {
            for (r in ((t._stOrig = o.cssText), (s = Hs(t))))
              +r ||
                Lo.test(r) ||
                !s[r] ||
                "string" != typeof o[r] ||
                "0" === r ||
                (o[r] = s[r]);
            (o.top = n), (o.left = i);
          } else o.cssText = t._stOrig;
          (Lr.core.getCache(t).uncache = 1), e.appendChild(t);
        }
      },
      Io = function (t, e, n) {
        var i = e,
          r = i;
        return function (e) {
          var s = Math.round(t());
          return (
            s !== i &&
              s !== r &&
              Math.abs(s - i) > 3 &&
              Math.abs(s - r) > 3 &&
              ((e = s), n && n()),
            (r = i),
            (i = e),
            e
          );
        };
      },
      Fo = function (t, e, n) {
        var i = {};
        (i[e.p] = "+=" + n), Lr.set(t, i);
      },
      Uo = function (t, e) {
        var n = Tr(t, e),
          i = "_scroll" + e.p2,
          r = function e(r, s, o, a, l) {
            var c = e.tween,
              u = s.onComplete,
              h = {};
            o = o || n();
            var d = Io(n, o, function () {
              c.kill(), (e.tween = 0);
            });
            return (
              (l = (a && l) || 0),
              (a = a || r - o),
              c && c.kill(),
              (s[i] = r),
              (s.modifiers = h),
              (h[i] = function () {
                return d(o + a * c.ratio + l * c.ratio * c.ratio);
              }),
              (s.onUpdate = function () {
                dr.cache++, Eo();
              }),
              (s.onComplete = function () {
                (e.tween = 0), u && u.call(c);
              }),
              (c = e.tween = Lr.to(t, s))
            );
          };
        return (
          (t[i] = n),
          (n.wheelHandler = function () {
            return r.tween && r.tween.kill() && (r.tween = 0);
          }),
          Ys(t, "wheel", n.wheelHandler),
          No.isTouch && Ys(t, "touchmove", n.wheelHandler),
          r
        );
      },
      No = (function () {
        function t(e, n) {
          Or ||
            t.register(Lr) ||
            console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
            ss(this),
            this.init(e, n);
        }
        return (
          (t.prototype.init = function (e, n) {
            if (
              ((this.progress = this.start = 0),
              this.vars && this.kill(!0, !0),
              _s)
            ) {
              var i,
                r,
                s,
                o,
                a,
                l,
                c,
                u,
                h,
                d,
                p,
                f,
                m,
                g,
                v,
                _,
                y,
                x,
                b,
                S,
                E,
                M,
                T,
                w,
                D,
                A,
                C,
                P,
                R,
                L,
                O,
                I,
                F,
                U,
                N,
                k,
                z,
                B,
                H,
                V,
                G,
                W,
                j = (e = Vs(
                  Ls(e) || Is(e) || e.nodeType
                    ? {
                        trigger: e,
                      }
                    : e,
                  $s
                )),
                X = j.onUpdate,
                q = j.toggleClass,
                Y = j.id,
                K = j.onToggle,
                Z = j.onRefresh,
                J = j.scrub,
                $ = j.trigger,
                Q = j.pin,
                tt = j.pinSpacing,
                et = j.invalidateOnRefresh,
                nt = j.anticipatePin,
                it = j.onScrubComplete,
                rt = j.onSnapComplete,
                st = j.once,
                ot = j.snap,
                at = j.pinReparent,
                lt = j.pinSpacer,
                ct = j.containerAnimation,
                ut = j.fastScrollEnd,
                ht = j.preventOverlaps,
                dt =
                  e.horizontal || (e.containerAnimation && !1 !== e.horizontal)
                    ? Sr
                    : Er,
                pt = !J && 0 !== J,
                ft = Mr(e.scroller || Ir),
                mt = Lr.core.getCache(ft),
                gt = Ds(ft),
                vt =
                  "fixed" ===
                  ("pinType" in e
                    ? e.pinType
                    : gr(ft, "pinType") || (gt && "fixed")),
                _t = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
                yt = pt && e.toggleActions.split(" "),
                xt = "markers" in e ? e.markers : $s.markers,
                bt = gt
                  ? 0
                  : parseFloat(Hs(ft)["border" + dt.p2 + "Width"]) || 0,
                St = this,
                Et =
                  e.onRefreshInit &&
                  function () {
                    return e.onRefreshInit(St);
                  },
                Mt = (function (t, e, n) {
                  var i = n.d,
                    r = n.d2,
                    s = n.a;
                  return (s = gr(t, "getBoundingClientRect"))
                    ? function () {
                        return s()[i];
                      }
                    : function () {
                        return (e ? As(r) : t["client" + r]) || 0;
                      };
                })(ft, gt, dt),
                Tt = (function (t, e) {
                  return !e || ~pr.indexOf(t)
                    ? Cs(t)
                    : function () {
                        return Po;
                      };
                })(ft, gt),
                wt = 0,
                Dt = 0,
                At = 0,
                Ct = Tr(ft, dt);
              if (
                ((St._startClamp = St._endClamp = !1),
                (St._dir = dt),
                (nt *= 45),
                (St.scroller = ft),
                (St.scroll = ct ? ct.time.bind(ct) : Ct),
                (o = Ct()),
                (St.vars = e),
                (n = n || e.animation),
                "refreshPriority" in e &&
                  ((Jr = 1), -9999 === e.refreshPriority && (ps = St)),
                (mt.tweenScroll = mt.tweenScroll || {
                  top: Uo(ft, Er),
                  left: Uo(ft, Sr),
                }),
                (St.tweenTo = i = mt.tweenScroll[dt.p]),
                (St.scrubDuration = function (t) {
                  (F = Is(t) && t)
                    ? I
                      ? I.duration(t)
                      : (I = Lr.to(n, {
                          ease: "expo",
                          totalProgress: "+=0",
                          duration: F,
                          paused: !0,
                          onComplete: function () {
                            return it && it(St);
                          },
                        }))
                    : (I && I.progress(1).kill(), (I = 0));
                }),
                n &&
                  ((n.vars.lazy = !1),
                  (n._initted && !St.isReverted) ||
                    (!1 !== n.vars.immediateRender &&
                      !1 !== e.immediateRender &&
                      n.duration() &&
                      n.render(0, !0, !0)),
                  (St.animation = n.pause()),
                  (n.scrollTrigger = St),
                  St.scrubDuration(J),
                  (L = 0),
                  Y || (Y = n.vars.id)),
                ot &&
                  ((Fs(ot) && !ot.push) ||
                    (ot = {
                      snapTo: ot,
                    }),
                  "scrollBehavior" in Nr.style &&
                    Lr.set(gt ? [Nr, Ur] : ft, {
                      scrollBehavior: "auto",
                    }),
                  dr.forEach(function (t) {
                    return (
                      Os(t) &&
                      t.target === (gt ? Fr.scrollingElement || Ur : ft) &&
                      (t.smooth = !1)
                    );
                  }),
                  (s = Os(ot.snapTo)
                    ? ot.snapTo
                    : "labels" === ot.snapTo
                    ? (function (t) {
                        return function (e) {
                          return Lr.utils.snap(js(t), e);
                        };
                      })(n)
                    : "labelsDirectional" === ot.snapTo
                    ? ((V = n),
                      function (t, e) {
                        return Xs(js(V))(t, e.direction);
                      })
                    : !1 !== ot.directional
                    ? function (t, e) {
                        return Xs(ot.snapTo)(
                          t,
                          ms() - Dt < 500 ? 0 : e.direction
                        );
                      }
                    : Lr.utils.snap(ot.snapTo)),
                  (U = ot.duration || {
                    min: 0.1,
                    max: 2,
                  }),
                  (U = Fs(U) ? Hr(U.min, U.max) : Hr(U, U)),
                  (N = Lr.delayedCall(ot.delay || F / 2 || 0.1, function () {
                    var t = Ct(),
                      e = ms() - Dt < 500,
                      r = i.tween;
                    if (
                      !(e || Math.abs(St.getVelocity()) < 10) ||
                      r ||
                      jr ||
                      wt === t
                    )
                      St.isActive && wt !== t && N.restart(!0);
                    else {
                      var o = (t - l) / g,
                        a = n && !pt ? n.totalProgress() : o,
                        u = e ? 0 : ((a - O) / (ms() - Vr)) * 1e3 || 0,
                        h = Lr.utils.clamp(-o, 1 - o, (ks(u / 2) * u) / 0.185),
                        d = o + (!1 === ot.inertia ? 0 : h),
                        p = Hr(0, 1, s(d, St)),
                        f = Math.round(l + p * g),
                        m = ot,
                        v = m.onStart,
                        _ = m.onInterrupt,
                        y = m.onComplete;
                      if (t <= c && t >= l && f !== t) {
                        if (r && !r._initted && r.data <= ks(f - t)) return;
                        !1 === ot.inertia && (h = p - o),
                          i(
                            f,
                            {
                              duration: U(
                                ks(
                                  (0.185 * Math.max(ks(d - a), ks(p - a))) /
                                    u /
                                    0.05 || 0
                                )
                              ),
                              ease: ot.ease || "power3",
                              data: ks(f - t),
                              onInterrupt: function () {
                                return N.restart(!0) && _ && _(St);
                              },
                              onComplete: function () {
                                St.update(),
                                  (wt = Ct()),
                                  (L = O =
                                    n && !pt ? n.totalProgress() : St.progress),
                                  rt && rt(St),
                                  y && y(St);
                              },
                            },
                            t,
                            h * g,
                            f - t - h * g
                          ),
                          v && v(St, i.tween);
                      }
                    }
                  }).pause())),
                Y && (ro[Y] = St),
                (H =
                  ($ = St.trigger = Mr($ || (!0 !== Q && Q))) &&
                  $._gsap &&
                  $._gsap.stRevert) && (H = H(St)),
                (Q = !0 === Q ? $ : Mr(Q)),
                Ls(q) &&
                  (q = {
                    targets: $,
                    className: q,
                  }),
                Q &&
                  (!1 === tt ||
                    "margin" === tt ||
                    (tt =
                      !(
                        !tt &&
                        Q.parentNode &&
                        Q.parentNode.style &&
                        "flex" === Hs(Q.parentNode).display
                      ) && zs),
                  (St.pin = Q),
                  (r = Lr.core.getCache(Q)).spacer
                    ? (v = r.pinState)
                    : (lt &&
                        ((lt = Mr(lt)) &&
                          !lt.nodeType &&
                          (lt = lt.current || lt.nativeElement),
                        (r.spacerIsNative = !!lt),
                        lt && (r.spacerState = Co(lt))),
                      (r.spacer = x = lt || Fr.createElement("div")),
                      x.classList.add("pin-spacer"),
                      Y && x.classList.add("pin-spacer-" + Y),
                      (r.pinState = v = Co(Q))),
                  !1 !== e.force3D &&
                    Lr.set(Q, {
                      force3D: !0,
                    }),
                  (St.spacer = x = r.spacer),
                  (R = Hs(Q)),
                  (w = R[tt + dt.os2]),
                  (S = Lr.getProperty(Q)),
                  (E = Lr.quickSetter(Q, dt.a, Bs)),
                  wo(Q, x, R),
                  (y = Co(Q))),
                xt)
              ) {
                (f = Fs(xt) ? Vs(xt, Js) : Js),
                  (d = eo("scroller-start", Y, ft, dt, f, 0)),
                  (p = eo("scroller-end", Y, ft, dt, f, 0, d)),
                  (b = d["offset" + dt.op.d2]);
                var Pt = Mr(gr(ft, "content") || ft);
                (u = this.markerStart = eo("start", Y, Pt, dt, f, b, 0, ct)),
                  (h = this.markerEnd = eo("end", Y, Pt, dt, f, b, 0, ct)),
                  ct && (B = Lr.quickSetter([u, h], dt.a, Bs)),
                  vt ||
                    (pr.length && !0 === gr(ft, "fixedMarkers")) ||
                    ((W = Hs((G = gt ? Nr : ft)).position),
                    (G.style.position =
                      "absolute" === W || "fixed" === W ? W : "relative"),
                    Lr.set([d, p], {
                      force3D: !0,
                    }),
                    (A = Lr.quickSetter(d, dt.a, Bs)),
                    (P = Lr.quickSetter(p, dt.a, Bs)));
              }
              if (ct) {
                var Rt = ct.vars.onUpdate,
                  Lt = ct.vars.onUpdateParams;
                ct.eventCallback("onUpdate", function () {
                  St.update(0, 0, 1), Rt && Rt.apply(ct, Lt || []);
                });
              }
              if (
                ((St.previous = function () {
                  return io[io.indexOf(St) - 1];
                }),
                (St.next = function () {
                  return io[io.indexOf(St) + 1];
                }),
                (St.revert = function (t, e) {
                  if (!e) return St.kill(!0);
                  var i = !1 !== t || !St.enabled,
                    r = Wr;
                  i !== St.isReverted &&
                    (i &&
                      ((k = Math.max(Ct(), St.scroll.rec || 0)),
                      (At = St.progress),
                      (z = n && n.progress())),
                    u &&
                      [u, h, d, p].forEach(function (t) {
                        return (t.style.display = i ? "none" : "block");
                      }),
                    i && ((Wr = St), St.update(i)),
                    !Q ||
                      (at && St.isActive) ||
                      (i
                        ? (function (t, e, n) {
                            Ao(n);
                            var i = t._gsap;
                            if (i.spacerIsNative) Ao(i.spacerState);
                            else if (t._gsap.swappedIn) {
                              var r = e.parentNode;
                              r && (r.insertBefore(t, e), r.removeChild(e));
                            }
                            t._gsap.swappedIn = !1;
                          })(Q, x, v)
                        : wo(Q, x, Hs(Q), D)),
                    i || St.update(i),
                    (Wr = r),
                    (St.isReverted = i));
                }),
                (St.refresh = function (r, s, f, b) {
                  if ((!Wr && St.enabled) || s)
                    if (Q && r && vs) Ys(t, "scrollEnd", ho);
                    else {
                      !hs && Et && Et(St),
                        (Wr = St),
                        i.tween && !f && (i.tween.kill(), (i.tween = 0)),
                        I && I.pause(),
                        et &&
                          n &&
                          n
                            .revert({
                              kill: !1,
                            })
                            .invalidate(),
                        St.isReverted || St.revert(!0, !0),
                        (St._subPinOffset = !1);
                      var E,
                        w,
                        A,
                        P,
                        R,
                        L,
                        O,
                        F,
                        U,
                        B,
                        H,
                        V,
                        G,
                        W = Mt(),
                        j = Tt(),
                        X = ct ? ct.duration() : Ps(ft, dt),
                        q = g <= 0.01,
                        Y = 0,
                        K = b || 0,
                        J = Fs(f) ? f.end : e.end,
                        nt = e.endTrigger || $,
                        it = Fs(f)
                          ? f.start
                          : e.start ||
                            (0 !== e.start && $ ? (Q ? "0 0" : "0 100%") : 0),
                        rt = (St.pinnedContainer =
                          e.pinnedContainer && Mr(e.pinnedContainer, St)),
                        st = ($ && Math.max(0, io.indexOf(St))) || 0,
                        ot = st;
                      for (
                        xt &&
                        Fs(f) &&
                        ((V = Lr.getProperty(d, dt.p)),
                        (G = Lr.getProperty(p, dt.p)));
                        ot--;

                      )
                        (L = io[ot]).end || L.refresh(0, 1) || (Wr = St),
                          !(O = L.pin) ||
                            (O !== $ && O !== Q && O !== rt) ||
                            L.isReverted ||
                            (B || (B = []), B.unshift(L), L.revert(!0, !0)),
                          L !== io[ot] && (st--, ot--);
                      for (
                        Os(it) && (it = it(St)),
                          it = ys(it, "start", St),
                          l =
                            Ro(
                              it,
                              $,
                              W,
                              dt,
                              Ct(),
                              u,
                              d,
                              St,
                              j,
                              bt,
                              vt,
                              X,
                              ct,
                              St._startClamp && "_startClamp"
                            ) || (Q ? -0.001 : 0),
                          Os(J) && (J = J(St)),
                          Ls(J) &&
                            !J.indexOf("+=") &&
                            (~J.indexOf(" ")
                              ? (J = (Ls(it) ? it.split(" ")[0] : "") + J)
                              : ((Y = to(J.substr(2), W)),
                                (J = Ls(it)
                                  ? it
                                  : (ct
                                      ? Lr.utils.mapRange(
                                          0,
                                          ct.duration(),
                                          ct.scrollTrigger.start,
                                          ct.scrollTrigger.end,
                                          l
                                        )
                                      : l) + Y),
                                (nt = $))),
                          J = ys(J, "end", St),
                          c =
                            Math.max(
                              l,
                              Ro(
                                J || (nt ? "100% 0" : X),
                                nt,
                                W,
                                dt,
                                Ct() + Y,
                                h,
                                p,
                                St,
                                j,
                                bt,
                                vt,
                                X,
                                ct,
                                St._endClamp && "_endClamp"
                              )
                            ) || -0.001,
                          Y = 0,
                          ot = st;
                        ot--;

                      )
                        (O = (L = io[ot]).pin) &&
                          L.start - L._pinPush <= l &&
                          !ct &&
                          L.end > 0 &&
                          ((E =
                            L.end -
                            (St._startClamp ? Math.max(0, L.start) : L.start)),
                          ((O === $ && L.start - L._pinPush < l) || O === rt) &&
                            isNaN(it) &&
                            (Y += E * (1 - L.progress)),
                          O === Q && (K += E));
                      if (
                        ((l += Y),
                        (c += Y),
                        St._startClamp && (St._startClamp += Y),
                        St._endClamp &&
                          !hs &&
                          ((St._endClamp = c || -0.001),
                          (c = Math.min(c, Ps(ft, dt)))),
                        (g = c - l || ((l -= 0.01) && 0.001)),
                        q &&
                          (At = Lr.utils.clamp(
                            0,
                            1,
                            Lr.utils.normalize(l, c, k)
                          )),
                        (St._pinPush = K),
                        u &&
                          Y &&
                          (((E = {})[dt.a] = "+=" + Y),
                          rt && (E[dt.p] = "-=" + Ct()),
                          Lr.set([u, h], E)),
                        Q)
                      )
                        (E = Hs(Q)),
                          (P = dt === Er),
                          (A = Ct()),
                          (M = parseFloat(S(dt.a)) + K),
                          !X &&
                            c > 1 &&
                            ((H = {
                              style: (H = (gt ? Fr.scrollingElement || Ur : ft)
                                .style),
                              value: H["overflow" + dt.a.toUpperCase()],
                            }),
                            gt &&
                              "scroll" !==
                                Hs(Nr)["overflow" + dt.a.toUpperCase()] &&
                              (H.style["overflow" + dt.a.toUpperCase()] =
                                "scroll")),
                          wo(Q, x, E),
                          (y = Co(Q)),
                          (w = Gs(Q, !0)),
                          (F = vt && Tr(ft, P ? Sr : Er)()),
                          tt &&
                            (((D = [tt + dt.os2, g + K + Bs]).t = x),
                            (ot = tt === zs ? Ws(Q, dt) + g + K : 0) &&
                              D.push(dt.d, ot + Bs),
                            Ao(D),
                            rt &&
                              io.forEach(function (t) {
                                t.pin === rt &&
                                  !1 !== t.vars.pinSpacing &&
                                  (t._subPinOffset = !0);
                              }),
                            vt && Ct(k)),
                          vt &&
                            (((R = {
                              top: w.top + (P ? A - l : F) + Bs,
                              left: w.left + (P ? F : A - l) + Bs,
                              boxSizing: "border-box",
                              position: "fixed",
                            }).width = R.maxWidth =
                              Math.ceil(w.width) + Bs),
                            (R.height = R.maxHeight = Math.ceil(w.height) + Bs),
                            (R.margin =
                              R.marginTop =
                              R.marginRight =
                              R.marginBottom =
                              R.marginLeft =
                                "0"),
                            (R[zs] = E[zs]),
                            (R[zs + "Top"] = E[zs + "Top"]),
                            (R[zs + "Right"] = E[zs + "Right"]),
                            (R[zs + "Bottom"] = E[zs + "Bottom"]),
                            (R[zs + "Left"] = E[zs + "Left"]),
                            (_ = (function (t, e, n) {
                              for (
                                var i, r = [], s = t.length, o = n ? 8 : 0;
                                o < s;
                                o += 2
                              )
                                (i = t[o]), r.push(i, i in e ? e[i] : t[o + 1]);
                              return (r.t = t.t), r;
                            })(v, R, at)),
                            hs && Ct(0)),
                          n
                            ? ((U = n._initted),
                              $r(1),
                              n.render(n.duration(), !0, !0),
                              (T = S(dt.a) - M + g + K),
                              (C = Math.abs(g - T) > 1),
                              vt && C && _.splice(_.length - 2, 2),
                              n.render(0, !0, !0),
                              U || n.invalidate(!0),
                              n.parent || n.totalTime(n.totalTime()),
                              $r(0))
                            : (T = g),
                          H &&
                            (H.value
                              ? (H.style["overflow" + dt.a.toUpperCase()] =
                                  H.value)
                              : H.style.removeProperty("overflow-" + dt.a));
                      else if ($ && Ct() && !ct)
                        for (w = $.parentNode; w && w !== Nr; )
                          w._pinOffset &&
                            ((l -= w._pinOffset), (c -= w._pinOffset)),
                            (w = w.parentNode);
                      B &&
                        B.forEach(function (t) {
                          return t.revert(!1, !0);
                        }),
                        (St.start = l),
                        (St.end = c),
                        (o = a = hs ? k : Ct()),
                        ct || hs || (o < k && Ct(k), (St.scroll.rec = 0)),
                        St.revert(!1, !0),
                        (Dt = ms()),
                        N && ((wt = -1), N.restart(!0)),
                        (Wr = 0),
                        n &&
                          pt &&
                          (n._initted || z) &&
                          n.progress() !== z &&
                          n.progress(z || 0, !0).render(n.time(), !0, !0),
                        (q || At !== St.progress || ct) &&
                          (n &&
                            !pt &&
                            n.totalProgress(
                              ct && l < -0.001 && !At
                                ? Lr.utils.normalize(l, c, 0)
                                : At,
                              !0
                            ),
                          (St.progress = q || (o - l) / g === At ? 0 : At)),
                        Q && tt && (x._pinOffset = Math.round(St.progress * T)),
                        I && I.invalidate(),
                        isNaN(V) ||
                          ((V -= Lr.getProperty(d, dt.p)),
                          (G -= Lr.getProperty(p, dt.p)),
                          Fo(d, dt, V),
                          Fo(u, dt, V - (b || 0)),
                          Fo(p, dt, G),
                          Fo(h, dt, G - (b || 0))),
                        q && !hs && St.update(),
                        !Z || hs || m || ((m = !0), Z(St), (m = !1));
                    }
                }),
                (St.getVelocity = function () {
                  return ((Ct() - a) / (ms() - Vr)) * 1e3 || 0;
                }),
                (St.endAnimation = function () {
                  Us(St.callbackAnimation),
                    n &&
                      (I
                        ? I.progress(1)
                        : n.paused()
                        ? pt || Us(n, St.direction < 0, 1)
                        : Us(n, n.reversed()));
                }),
                (St.labelToScroll = function (t) {
                  return (
                    (n &&
                      n.labels &&
                      (l || St.refresh() || l) +
                        (n.labels[t] / n.duration()) * g) ||
                    0
                  );
                }),
                (St.getTrailing = function (t) {
                  var e = io.indexOf(St),
                    n =
                      St.direction > 0
                        ? io.slice(0, e).reverse()
                        : io.slice(e + 1);
                  return (
                    Ls(t)
                      ? n.filter(function (e) {
                          return e.vars.preventOverlaps === t;
                        })
                      : n
                  ).filter(function (t) {
                    return St.direction > 0 ? t.end <= l : t.start >= c;
                  });
                }),
                (St.update = function (t, e, r) {
                  if (!ct || r || t) {
                    var s,
                      u,
                      h,
                      p,
                      f,
                      m,
                      v,
                      b = !0 === hs ? k : St.scroll(),
                      S = t ? 0 : (b - l) / g,
                      D = S < 0 ? 0 : S > 1 ? 1 : S || 0,
                      R = St.progress;
                    if (
                      (e &&
                        ((a = o),
                        (o = ct ? Ct() : b),
                        ot &&
                          ((O = L), (L = n && !pt ? n.totalProgress() : D))),
                      nt &&
                        !D &&
                        Q &&
                        !Wr &&
                        !fs &&
                        vs &&
                        l < b + ((b - a) / (ms() - Vr)) * nt &&
                        (D = 1e-4),
                      D !== R && St.enabled)
                    ) {
                      if (
                        ((p =
                          (f =
                            (s = St.isActive = !!D && D < 1) !==
                            (!!R && R < 1)) || !!D != !!R),
                        (St.direction = D > R ? 1 : -1),
                        (St.progress = D),
                        p &&
                          !Wr &&
                          ((u = D && !R ? 0 : 1 === D ? 1 : 1 === R ? 2 : 3),
                          pt &&
                            ((h =
                              (!f && "none" !== yt[u + 1] && yt[u + 1]) ||
                              yt[u]),
                            (v =
                              n &&
                              ("complete" === h || "reset" === h || h in n)))),
                        ht &&
                          (f || v) &&
                          (v || J || !n) &&
                          (Os(ht)
                            ? ht(St)
                            : St.getTrailing(ht).forEach(function (t) {
                                return t.endAnimation();
                              })),
                        pt ||
                          (!I || Wr || fs
                            ? n && n.totalProgress(D, !(!Wr || (!Dt && !t)))
                            : (I._dp._time - I._start !== I._time &&
                                I.render(I._dp._time - I._start),
                              I.resetTo
                                ? I.resetTo(
                                    "totalProgress",
                                    D,
                                    n._tTime / n._tDur
                                  )
                                : ((I.vars.totalProgress = D),
                                  I.invalidate().restart()))),
                        Q)
                      )
                        if ((t && tt && (x.style[tt + dt.os2] = w), vt)) {
                          if (p) {
                            if (
                              ((m =
                                !t &&
                                D > R &&
                                c + 1 > b &&
                                b + 1 >= Ps(ft, dt)),
                              at)
                            )
                              if (t || (!s && !m)) Oo(Q, x);
                              else {
                                var F = Gs(Q, !0),
                                  U = b - l;
                                Oo(
                                  Q,
                                  Nr,
                                  F.top + (dt === Er ? U : 0) + Bs,
                                  F.left + (dt === Er ? 0 : U) + Bs
                                );
                              }
                            Ao(s || m ? _ : y),
                              (C && D < 1 && s) ||
                                E(M + (1 !== D || m ? 0 : T));
                          }
                        } else E(Ms(M + T * D));
                      ot && !i.tween && !Wr && !fs && N.restart(!0),
                        q &&
                          (f || (st && D && (D < 1 || !cs))) &&
                          Br(q.targets).forEach(function (t) {
                            return t.classList[s || st ? "add" : "remove"](
                              q.className
                            );
                          }),
                        X && !pt && !t && X(St),
                        p && !Wr
                          ? (pt &&
                              (v &&
                                ("complete" === h
                                  ? n.pause().totalProgress(1)
                                  : "reset" === h
                                  ? n.restart(!0).pause()
                                  : "restart" === h
                                  ? n.restart(!0)
                                  : n[h]()),
                              X && X(St)),
                            (!f && cs) ||
                              (K && f && Ns(St, K),
                              _t[u] && Ns(St, _t[u]),
                              st && (1 === D ? St.kill(!1, 1) : (_t[u] = 0)),
                              f ||
                                (_t[(u = 1 === D ? 1 : 3)] && Ns(St, _t[u]))),
                            ut &&
                              !s &&
                              Math.abs(St.getVelocity()) >
                                (Is(ut) ? ut : 2500) &&
                              (Us(St.callbackAnimation),
                              I
                                ? I.progress(1)
                                : Us(n, "reverse" === h ? 1 : !D, 1)))
                          : pt && X && !Wr && X(St);
                    }
                    if (P) {
                      var z = ct
                        ? (b / ct.duration()) * (ct._caScrollDist || 0)
                        : b;
                      A(z + (d._isFlipped ? 1 : 0)), P(z);
                    }
                    B && B((-b / ct.duration()) * (ct._caScrollDist || 0));
                  }
                }),
                (St.enable = function (e, n) {
                  St.enabled ||
                    ((St.enabled = !0),
                    Ys(ft, "resize", lo),
                    gt || Ys(ft, "scroll", oo),
                    Et && Ys(t, "refreshInit", Et),
                    !1 !== e && ((St.progress = At = 0), (o = a = wt = Ct())),
                    !1 !== n && St.refresh());
                }),
                (St.getTween = function (t) {
                  return t && i ? i.tween : I;
                }),
                (St.setPositions = function (t, e, n, i) {
                  if (ct) {
                    var r = ct.scrollTrigger,
                      s = ct.duration(),
                      o = r.end - r.start;
                    (t = r.start + (o * t) / s), (e = r.start + (o * e) / s);
                  }
                  St.refresh(
                    !1,
                    !1,
                    {
                      start: xs(t, n && !!St._startClamp),
                      end: xs(e, n && !!St._endClamp),
                    },
                    i
                  ),
                    St.update();
                }),
                (St.adjustPinSpacing = function (t) {
                  if (D && t) {
                    var e = D.indexOf(dt.d) + 1;
                    (D[e] = parseFloat(D[e]) + t + Bs),
                      (D[1] = parseFloat(D[1]) + t + Bs),
                      Ao(D);
                  }
                }),
                (St.disable = function (e, n) {
                  if (
                    St.enabled &&
                    (!1 !== e && St.revert(!0, !0),
                    (St.enabled = St.isActive = !1),
                    n || (I && I.pause()),
                    (k = 0),
                    r && (r.uncache = 1),
                    Et && Ks(t, "refreshInit", Et),
                    N &&
                      (N.pause(), i.tween && i.tween.kill() && (i.tween = 0)),
                    !gt)
                  ) {
                    for (var s = io.length; s--; )
                      if (io[s].scroller === ft && io[s] !== St) return;
                    Ks(ft, "resize", lo), gt || Ks(ft, "scroll", oo);
                  }
                }),
                (St.kill = function (t, i) {
                  St.disable(t, i), I && !i && I.kill(), Y && delete ro[Y];
                  var s = io.indexOf(St);
                  s >= 0 && io.splice(s, 1),
                    s === qr && So > 0 && qr--,
                    (s = 0),
                    io.forEach(function (t) {
                      return t.scroller === St.scroller && (s = 1);
                    }),
                    s || hs || (St.scroll.rec = 0),
                    n &&
                      ((n.scrollTrigger = null),
                      t &&
                        n.revert({
                          kill: !1,
                        }),
                      i || n.kill()),
                    u &&
                      [u, h, d, p].forEach(function (t) {
                        return t.parentNode && t.parentNode.removeChild(t);
                      }),
                    ps === St && (ps = 0),
                    Q &&
                      (r && (r.uncache = 1),
                      (s = 0),
                      io.forEach(function (t) {
                        return t.pin === Q && s++;
                      }),
                      s || (r.spacer = 0)),
                    e.onKill && e.onKill(St);
                }),
                io.push(St),
                St.enable(!1, !1),
                H && H(St),
                n && n.add && !g)
              ) {
                var Ot = St.update;
                (St.update = function () {
                  (St.update = Ot), l || c || St.refresh();
                }),
                  Lr.delayedCall(0.01, St.update),
                  (g = 0.01),
                  (l = c = 0);
              } else St.refresh();
              Q &&
                (function () {
                  if (ds !== _o) {
                    var t = (ds = _o);
                    requestAnimationFrame(function () {
                      return t === _o && xo(!0);
                    });
                  }
                })();
            } else this.update = this.refresh = this.kill = Es;
          }),
          (t.register = function (e) {
            return (
              Or ||
                ((Lr = e || ws()),
                Ts() && window.document && t.enable(),
                (Or = _s)),
              Or
            );
          }),
          (t.defaults = function (t) {
            if (t) for (var e in t) $s[e] = t[e];
            return $s;
          }),
          (t.disable = function (t, e) {
            (_s = 0),
              io.forEach(function (n) {
                return n[e ? "kill" : "disable"](t);
              }),
              Ks(Ir, "wheel", oo),
              Ks(Fr, "scroll", oo),
              clearInterval(Gr),
              Ks(Fr, "touchcancel", Es),
              Ks(Nr, "touchstart", Es),
              qs(Ks, Fr, "pointerdown,touchstart,mousedown", bs),
              qs(Ks, Fr, "pointerup,touchend,mouseup", Ss),
              zr.kill(),
              Rs(Ks);
            for (var n = 0; n < dr.length; n += 3)
              Zs(Ks, dr[n], dr[n + 1]), Zs(Ks, dr[n], dr[n + 2]);
          }),
          (t.enable = function () {
            if (
              ((Ir = window),
              (Fr = document),
              (Ur = Fr.documentElement),
              (Nr = Fr.body),
              Lr &&
                ((Br = Lr.utils.toArray),
                (Hr = Lr.utils.clamp),
                (ss = Lr.core.context || Es),
                ($r = Lr.core.suppressOverwrites || Es),
                (os = Ir.history.scrollRestoration || "auto"),
                (bo = Ir.pageYOffset),
                Lr.core.globals("ScrollTrigger", t),
                Nr))
            ) {
              (_s = 1),
                ((as = document.createElement("div")).style.height = "100vh"),
                (as.style.position = "absolute"),
                yo(),
                (function t() {
                  return _s && requestAnimationFrame(t);
                })(),
                Rr.register(Lr),
                (t.isTouch = Rr.isTouch),
                (rs =
                  Rr.isTouch &&
                  /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
                Ys(Ir, "wheel", oo),
                (kr = [Ir, Fr, Ur, Nr]),
                Lr.matchMedia
                  ? ((t.matchMedia = function (t) {
                      var e,
                        n = Lr.matchMedia();
                      for (e in t) n.add(e, t[e]);
                      return n;
                    }),
                    Lr.addEventListener("matchMediaInit", function () {
                      return go();
                    }),
                    Lr.addEventListener("matchMediaRevert", function () {
                      return mo();
                    }),
                    Lr.addEventListener("matchMedia", function () {
                      xo(0, 1), po("matchMedia");
                    }),
                    Lr.matchMedia("(orientation: portrait)", function () {
                      return ao(), ao;
                    }))
                  : console.warn("Requires GSAP 3.11.0 or later"),
                ao(),
                Ys(Fr, "scroll", oo);
              var e,
                n,
                i = Nr.style,
                r = i.borderTopStyle,
                s = Lr.core.Animation.prototype;
              for (
                s.revert ||
                  Object.defineProperty(s, "revert", {
                    value: function () {
                      return this.time(-0.01, !0);
                    },
                  }),
                  i.borderTopStyle = "solid",
                  e = Gs(Nr),
                  Er.m = Math.round(e.top + Er.sc()) || 0,
                  Sr.m = Math.round(e.left + Sr.sc()) || 0,
                  r
                    ? (i.borderTopStyle = r)
                    : i.removeProperty("border-top-style"),
                  Gr = setInterval(so, 250),
                  Lr.delayedCall(0.5, function () {
                    return (fs = 0);
                  }),
                  Ys(Fr, "touchcancel", Es),
                  Ys(Nr, "touchstart", Es),
                  qs(Ys, Fr, "pointerdown,touchstart,mousedown", bs),
                  qs(Ys, Fr, "pointerup,touchend,mouseup", Ss),
                  Xr = Lr.utils.checkPrefix("transform"),
                  To.push(Xr),
                  Or = ms(),
                  zr = Lr.delayedCall(0.2, xo).pause(),
                  Zr = [
                    Fr,
                    "visibilitychange",
                    function () {
                      var t = Ir.innerWidth,
                        e = Ir.innerHeight;
                      Fr.hidden
                        ? ((Yr = t), (Kr = e))
                        : (Yr === t && Kr === e) || lo();
                    },
                    Fr,
                    "DOMContentLoaded",
                    xo,
                    Ir,
                    "load",
                    xo,
                    Ir,
                    "resize",
                    lo,
                  ],
                  Rs(Ys),
                  io.forEach(function (t) {
                    return t.enable(0, 1);
                  }),
                  n = 0;
                n < dr.length;
                n += 3
              )
                Zs(Ks, dr[n], dr[n + 1]), Zs(Ks, dr[n], dr[n + 2]);
            }
          }),
          (t.config = function (e) {
            "limitCallbacks" in e && (cs = !!e.limitCallbacks);
            var n = e.syncInterval;
            (n && clearInterval(Gr)) || ((Gr = n) && setInterval(so, n)),
              "ignoreMobileResize" in e &&
                (es = 1 === t.isTouch && e.ignoreMobileResize),
              "autoRefreshEvents" in e &&
                (Rs(Ks) || Rs(Ys, e.autoRefreshEvents || "none"),
                (Qr = -1 === (e.autoRefreshEvents + "").indexOf("resize")));
          }),
          (t.scrollerProxy = function (t, e) {
            var n = Mr(t),
              i = dr.indexOf(n),
              r = Ds(n);
            ~i && dr.splice(i, r ? 6 : 2),
              e && (r ? pr.unshift(Ir, e, Nr, e, Ur, e) : pr.unshift(n, e));
          }),
          (t.clearMatchMedia = function (t) {
            io.forEach(function (e) {
              return e._ctx && e._ctx.query === t && e._ctx.kill(!0, !0);
            });
          }),
          (t.isInViewport = function (t, e, n) {
            var i = (Ls(t) ? Mr(t) : t).getBoundingClientRect(),
              r = i[n ? "width" : "height"] * e || 0;
            return n
              ? i.right - r > 0 && i.left + r < Ir.innerWidth
              : i.bottom - r > 0 && i.top + r < Ir.innerHeight;
          }),
          (t.positionInViewport = function (t, e, n) {
            Ls(t) && (t = Mr(t));
            var i = t.getBoundingClientRect(),
              r = i[n ? "width" : "height"],
              s =
                null == e
                  ? r / 2
                  : e in Qs
                  ? Qs[e] * r
                  : ~e.indexOf("%")
                  ? (parseFloat(e) * r) / 100
                  : parseFloat(e) || 0;
            return n
              ? (i.left + s) / Ir.innerWidth
              : (i.top + s) / Ir.innerHeight;
          }),
          (t.killAll = function (t) {
            if (
              (io.slice(0).forEach(function (t) {
                return "ScrollSmoother" !== t.vars.id && t.kill();
              }),
              !0 !== t)
            ) {
              var e = co.killAll || [];
              (co = {}),
                e.forEach(function (t) {
                  return t();
                });
            }
          }),
          t
        );
      })();
    (No.version = "3.12.2"),
      (No.saveStyles = function (t) {
        return t
          ? Br(t).forEach(function (t) {
              if (t && t.style) {
                var e = fo.indexOf(t);
                e >= 0 && fo.splice(e, 5),
                  fo.push(
                    t,
                    t.style.cssText,
                    t.getBBox && t.getAttribute("transform"),
                    Lr.core.getCache(t),
                    ss()
                  );
              }
            })
          : fo;
      }),
      (No.revert = function (t, e) {
        return go(!t, e);
      }),
      (No.create = function (t, e) {
        return new No(t, e);
      }),
      (No.refresh = function (t) {
        return t ? lo() : (Or || No.register()) && xo(!0);
      }),
      (No.update = function (t) {
        return ++dr.cache && Eo(!0 === t ? 2 : 0);
      }),
      (No.clearScrollMemory = vo),
      (No.maxScroll = function (t, e) {
        return Ps(t, e ? Sr : Er);
      }),
      (No.getScrollFunc = function (t, e) {
        return Tr(Mr(t), e ? Sr : Er);
      }),
      (No.getById = function (t) {
        return ro[t];
      }),
      (No.getAll = function () {
        return io.filter(function (t) {
          return "ScrollSmoother" !== t.vars.id;
        });
      }),
      (No.isScrolling = function () {
        return !!vs;
      }),
      (No.snapDirectional = Xs),
      (No.addEventListener = function (t, e) {
        var n = co[t] || (co[t] = []);
        ~n.indexOf(e) || n.push(e);
      }),
      (No.removeEventListener = function (t, e) {
        var n = co[t],
          i = n && n.indexOf(e);
        i >= 0 && n.splice(i, 1);
      }),
      (No.batch = function (t, e) {
        var n,
          i = [],
          r = {},
          s = e.interval || 0.016,
          o = e.batchMax || 1e9,
          a = function (t, e) {
            var n = [],
              i = [],
              r = Lr.delayedCall(s, function () {
                e(n, i), (n = []), (i = []);
              }).pause();
            return function (t) {
              n.length || r.restart(!0),
                n.push(t.trigger),
                i.push(t),
                o <= n.length && r.progress(1);
            };
          };
        for (n in e)
          r[n] =
            "on" === n.substr(0, 2) && Os(e[n]) && "onRefreshInit" !== n
              ? a(0, e[n])
              : e[n];
        return (
          Os(o) &&
            ((o = o()),
            Ys(No, "refresh", function () {
              return (o = e.batchMax());
            })),
          Br(t).forEach(function (t) {
            var e = {};
            for (n in r) e[n] = r[n];
            (e.trigger = t), i.push(No.create(e));
          }),
          i
        );
      });
    var ko,
      zo = function (t, e, n, i) {
        return (
          e > i ? t(i) : e < 0 && t(0),
          n > i ? (i - e) / (n - e) : n < 0 ? e / (e - n) : 1
        );
      },
      Bo = function t(e, n) {
        !0 === n
          ? e.style.removeProperty("touch-action")
          : (e.style.touchAction =
              !0 === n
                ? "auto"
                : n
                ? "pan-" + n + (Rr.isTouch ? " pinch-zoom" : "")
                : "none"),
          e === Ur && t(Nr, n);
      },
      Ho = {
        auto: 1,
        scroll: 1,
      },
      Vo = function (t) {
        var e,
          n = t.event,
          i = t.target,
          r = t.axis,
          s = (n.changedTouches ? n.changedTouches[0] : n).target,
          o = s._gsap || Lr.core.getCache(s),
          a = ms();
        if (!o._isScrollT || a - o._isScrollT > 2e3) {
          for (
            ;
            s &&
            s !== Nr &&
            ((s.scrollHeight <= s.clientHeight &&
              s.scrollWidth <= s.clientWidth) ||
              (!Ho[(e = Hs(s)).overflowY] && !Ho[e.overflowX]));

          )
            s = s.parentNode;
          (o._isScroll =
            s &&
            s !== i &&
            !Ds(s) &&
            (Ho[(e = Hs(s)).overflowY] || Ho[e.overflowX])),
            (o._isScrollT = a);
        }
        (o._isScroll || "x" === r) &&
          (n.stopPropagation(), (n._gsapAllow = !0));
      },
      Go = function (t, e, n, i) {
        return Rr.create({
          target: t,
          capture: !0,
          debounce: !1,
          lockAxis: !0,
          type: e,
          onWheel: (i = i && Vo),
          onPress: i,
          onDrag: i,
          onScroll: i,
          onEnable: function () {
            return n && Ys(Fr, Rr.eventTypes[0], jo, !1, !0);
          },
          onDisable: function () {
            return Ks(Fr, Rr.eventTypes[0], jo, !0);
          },
        });
      },
      Wo = /(input|label|select|textarea)/i,
      jo = function (t) {
        var e = Wo.test(t.target.tagName);
        (e || ko) && ((t._gsapAllow = !0), (ko = e));
      },
      Xo = function (t) {
        Fs(t) || (t = {}),
          (t.preventDefault = t.isNormalizer = t.allowClicks = !0),
          t.type || (t.type = "wheel,touch"),
          (t.debounce = !!t.debounce),
          (t.id = t.id || "normalizer");
        var e,
          n,
          i,
          r,
          s,
          o,
          a,
          l,
          c = t,
          u = c.normalizeScrollX,
          h = c.momentum,
          d = c.allowNestedScroll,
          p = c.onRelease,
          f = Mr(t.target) || Ur,
          m = Lr.core.globals().ScrollSmoother,
          g = m && m.get(),
          v =
            rs &&
            ((t.content && Mr(t.content)) ||
              (g && !1 !== t.content && !g.smooth() && g.content())),
          _ = Tr(f, Er),
          y = Tr(f, Sr),
          x = 1,
          b =
            (Rr.isTouch && Ir.visualViewport
              ? Ir.visualViewport.scale * Ir.visualViewport.width
              : Ir.outerWidth) / Ir.innerWidth,
          S = 0,
          E = Os(h)
            ? function () {
                return h(e);
              }
            : function () {
                return h || 2.8;
              },
          M = Go(f, t.type, !0, d),
          T = function () {
            return (r = !1);
          },
          w = Es,
          D = Es,
          A = function () {
            (n = Ps(f, Er)),
              (D = Hr(rs ? 1 : 0, n)),
              u && (w = Hr(0, Ps(f, Sr))),
              (i = _o);
          },
          C = function () {
            (v._gsap.y = Ms(parseFloat(v._gsap.y) + _.offset) + "px"),
              (v.style.transform =
                "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                parseFloat(v._gsap.y) +
                ", 0, 1)"),
              (_.offset = _.cacheID = 0);
          },
          P = function () {
            A(),
              s.isActive() &&
                s.vars.scrollY > n &&
                (_() > n ? s.progress(1) && _(n) : s.resetTo("scrollY", n));
          };
        return (
          v &&
            Lr.set(v, {
              y: "+=0",
            }),
          (t.ignoreCheck = function (t) {
            return (
              (rs &&
                "touchmove" === t.type &&
                (function () {
                  if (r) {
                    requestAnimationFrame(T);
                    var t = Ms(e.deltaY / 2),
                      n = D(_.v - t);
                    if (v && n !== _.v + _.offset) {
                      _.offset = n - _.v;
                      var i = Ms((parseFloat(v && v._gsap.y) || 0) - _.offset);
                      (v.style.transform =
                        "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
                        i +
                        ", 0, 1)"),
                        (v._gsap.y = i + "px"),
                        (_.cacheID = dr.cache),
                        Eo();
                    }
                    return !0;
                  }
                  _.offset && C(), (r = !0);
                })()) ||
              (x > 1.05 && "touchstart" !== t.type) ||
              e.isGesturing ||
              (t.touches && t.touches.length > 1)
            );
          }),
          (t.onPress = function () {
            r = !1;
            var t = x;
            (x = Ms(((Ir.visualViewport && Ir.visualViewport.scale) || 1) / b)),
              s.pause(),
              t !== x && Bo(f, x > 1.01 || (!u && "x")),
              (o = y()),
              (a = _()),
              A(),
              (i = _o);
          }),
          (t.onRelease = t.onGestureStart =
            function (t, e) {
              if ((_.offset && C(), e)) {
                dr.cache++;
                var i,
                  r,
                  o = E();
                u &&
                  ((r = (i = y()) + (0.05 * o * -t.velocityX) / 0.227),
                  (o *= zo(y, i, r, Ps(f, Sr))),
                  (s.vars.scrollX = w(r))),
                  (r = (i = _()) + (0.05 * o * -t.velocityY) / 0.227),
                  (o *= zo(_, i, r, Ps(f, Er))),
                  (s.vars.scrollY = D(r)),
                  s.invalidate().duration(o).play(0.01),
                  ((rs && s.vars.scrollY >= n) || i >= n - 1) &&
                    Lr.to(
                      {},
                      {
                        onUpdate: P,
                        duration: o,
                      }
                    );
              } else l.restart(!0);
              p && p(t);
            }),
          (t.onWheel = function () {
            s._ts && s.pause(), ms() - S > 1e3 && ((i = 0), (S = ms()));
          }),
          (t.onChange = function (t, e, n, r, s) {
            if (
              (_o !== i && A(),
              e &&
                u &&
                y(w(r[2] === e ? o + (t.startX - t.x) : y() + e - r[1])),
              n)
            ) {
              _.offset && C();
              var l = s[2] === n,
                c = l ? a + t.startY - t.y : _() + n - s[1],
                h = D(c);
              l && c !== h && (a += h - c), _(h);
            }
            (n || e) && Eo();
          }),
          (t.onEnable = function () {
            Bo(f, !u && "x"),
              No.addEventListener("refresh", P),
              Ys(Ir, "resize", P),
              _.smooth &&
                ((_.target.style.scrollBehavior = "auto"),
                (_.smooth = y.smooth = !1)),
              M.enable();
          }),
          (t.onDisable = function () {
            Bo(f, !0),
              Ks(Ir, "resize", P),
              No.removeEventListener("refresh", P),
              M.kill();
          }),
          (t.lockAxis = !1 !== t.lockAxis),
          ((e = new Rr(t)).iOS = rs),
          rs && !_() && _(1),
          rs && Lr.ticker.add(Es),
          (l = e._dc),
          (s = Lr.to(e, {
            ease: "power4",
            paused: !0,
            scrollX: u ? "+=0.1" : "+=0",
            scrollY: "+=0.1",
            modifiers: {
              scrollY: Io(_, _(), function () {
                return s.pause();
              }),
            },
            onUpdate: Eo,
            onComplete: l.vars.onComplete,
          })),
          e
        );
      };
    (No.sort = function (t) {
      return io.sort(
        t ||
          function (t, e) {
            return (
              -1e6 * (t.vars.refreshPriority || 0) +
              t.start -
              (e.start + -1e6 * (e.vars.refreshPriority || 0))
            );
          }
      );
    }),
      (No.observe = function (t) {
        return new Rr(t);
      }),
      (No.normalizeScroll = function (t) {
        if (void 0 === t) return ts;
        if (!0 === t && ts) return ts.enable();
        if (!1 === t) return ts && ts.kill();
        var e = t instanceof Rr ? t : Xo(t);
        return (
          ts && ts.target === e.target && ts.kill(), Ds(e.target) && (ts = e), e
        );
      }),
      (No.core = {
        _getVelocityProp: wr,
        _inputObserver: Go,
        _scrollers: dr,
        _proxies: pr,
        bridge: {
          ss: function () {
            vs || po("scrollStart"), (vs = ms());
          },
          ref: function () {
            return Wr;
          },
        },
      }),
      ws() && Lr.registerPlugin(No);
    /*!
     * ScrollToPlugin 3.12.2
     * https://greensock.com
     *
     * @license Copyright 2008-2023, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var qo,
      Yo,
      Ko,
      Zo,
      Jo,
      $o,
      Qo,
      ta,
      ea = function () {
        return "undefined" != typeof window;
      },
      na = function () {
        return qo || (ea() && (qo = window.gsap) && qo.registerPlugin && qo);
      },
      ia = function (t) {
        return "string" == typeof t;
      },
      ra = function (t) {
        return "function" == typeof t;
      },
      sa = function (t, e) {
        var n = "x" === e ? "Width" : "Height",
          i = "scroll" + n,
          r = "client" + n;
        return t === Ko || t === Zo || t === Jo
          ? Math.max(Zo[i], Jo[i]) - (Ko["inner" + n] || Zo[r] || Jo[r])
          : t[i] - t["offset" + n];
      },
      oa = function (t, e) {
        var n = "scroll" + ("x" === e ? "Left" : "Top");
        return (
          t === Ko &&
            (null != t.pageXOffset
              ? (n = "page" + e.toUpperCase() + "Offset")
              : (t = null != Zo[n] ? Zo : Jo)),
          function () {
            return t[n];
          }
        );
      },
      aa = function (t, e) {
        if (!(t = $o(t)[0]) || !t.getBoundingClientRect)
          return (
            console.warn("scrollTo target doesn't exist. Using 0") || {
              x: 0,
              y: 0,
            }
          );
        var n = t.getBoundingClientRect(),
          i = !e || e === Ko || e === Jo,
          r = i
            ? {
                top:
                  Zo.clientTop -
                  (Ko.pageYOffset || Zo.scrollTop || Jo.scrollTop || 0),
                left:
                  Zo.clientLeft -
                  (Ko.pageXOffset || Zo.scrollLeft || Jo.scrollLeft || 0),
              }
            : e.getBoundingClientRect(),
          s = {
            x: n.left - r.left,
            y: n.top - r.top,
          };
        return !i && e && ((s.x += oa(e, "x")()), (s.y += oa(e, "y")())), s;
      },
      la = function (t, e, n, i, r) {
        return isNaN(t) || "object" == typeof t
          ? ia(t) && "=" === t.charAt(1)
            ? parseFloat(t.substr(2)) * ("-" === t.charAt(0) ? -1 : 1) + i - r
            : "max" === t
            ? sa(e, n) - r
            : Math.min(sa(e, n), aa(t, e)[n] - r)
          : parseFloat(t) - r;
      },
      ca = function () {
        (qo = na()),
          ea() &&
            qo &&
            "undefined" != typeof document &&
            document.body &&
            ((Ko = window),
            (Jo = document.body),
            (Zo = document.documentElement),
            ($o = qo.utils.toArray),
            qo.config({
              autoKillThreshold: 7,
            }),
            (Qo = qo.config()),
            (Yo = 1));
      },
      ua = {
        version: "3.12.2",
        name: "scrollTo",
        rawVars: 1,
        register: function (t) {
          (qo = t), ca();
        },
        init: function (t, e, n, i, r) {
          Yo || ca();
          var s = qo.getProperty(t, "scrollSnapType");
          (this.isWin = t === Ko),
            (this.target = t),
            (this.tween = n),
            (e = (function (t, e, n, i) {
              if ((ra(t) && (t = t(e, n, i)), "object" != typeof t))
                return ia(t) && "max" !== t && "=" !== t.charAt(1)
                  ? {
                      x: t,
                      y: t,
                    }
                  : {
                      y: t,
                    };
              if (t.nodeType)
                return {
                  y: t,
                  x: t,
                };
              var r,
                s = {};
              for (r in t)
                s[r] = "onAutoKill" !== r && ra(t[r]) ? t[r](e, n, i) : t[r];
              return s;
            })(e, i, t, r)),
            (this.vars = e),
            (this.autoKill = !!e.autoKill),
            (this.getX = oa(t, "x")),
            (this.getY = oa(t, "y")),
            (this.x = this.xPrev = this.getX()),
            (this.y = this.yPrev = this.getY()),
            ta || (ta = qo.core.globals().ScrollTrigger),
            "smooth" === qo.getProperty(t, "scrollBehavior") &&
              qo.set(t, {
                scrollBehavior: "auto",
              }),
            s &&
              "none" !== s &&
              ((this.snap = 1),
              (this.snapInline = t.style.scrollSnapType),
              (t.style.scrollSnapType = "none")),
            null != e.x
              ? (this.add(
                  this,
                  "x",
                  this.x,
                  la(e.x, t, "x", this.x, e.offsetX || 0),
                  i,
                  r
                ),
                this._props.push("scrollTo_x"))
              : (this.skipX = 1),
            null != e.y
              ? (this.add(
                  this,
                  "y",
                  this.y,
                  la(e.y, t, "y", this.y, e.offsetY || 0),
                  i,
                  r
                ),
                this._props.push("scrollTo_y"))
              : (this.skipY = 1);
        },
        render: function (t, e) {
          for (
            var n,
              i,
              r,
              s,
              o,
              a = e._pt,
              l = e.target,
              c = e.tween,
              u = e.autoKill,
              h = e.xPrev,
              d = e.yPrev,
              p = e.isWin,
              f = e.snap,
              m = e.snapInline;
            a;

          )
            a.r(t, a.d), (a = a._next);
          (n = p || !e.skipX ? e.getX() : h),
            (r = (i = p || !e.skipY ? e.getY() : d) - d),
            (s = n - h),
            (o = Qo.autoKillThreshold),
            e.x < 0 && (e.x = 0),
            e.y < 0 && (e.y = 0),
            u &&
              (!e.skipX && (s > o || s < -o) && n < sa(l, "x") && (e.skipX = 1),
              !e.skipY && (r > o || r < -o) && i < sa(l, "y") && (e.skipY = 1),
              e.skipX &&
                e.skipY &&
                (c.kill(),
                e.vars.onAutoKill &&
                  e.vars.onAutoKill.apply(c, e.vars.onAutoKillParams || []))),
            p
              ? Ko.scrollTo(e.skipX ? n : e.x, e.skipY ? i : e.y)
              : (e.skipY || (l.scrollTop = e.y),
                e.skipX || (l.scrollLeft = e.x)),
            !f ||
              (1 !== t && 0 !== t) ||
              ((i = l.scrollTop),
              (n = l.scrollLeft),
              m
                ? (l.style.scrollSnapType = m)
                : l.style.removeProperty("scroll-snap-type"),
              (l.scrollTop = i + 1),
              (l.scrollLeft = n + 1),
              (l.scrollTop = i),
              (l.scrollLeft = n)),
            (e.xPrev = e.x),
            (e.yPrev = e.y),
            ta && ta.update();
        },
        kill: function (t) {
          var e = "scrollTo" === t;
          (e || "scrollTo_x" === t) && (this.skipX = 1),
            (e || "scrollTo_y" === t) && (this.skipY = 1);
        },
      };
    (ua.max = sa),
      (ua.getOffset = aa),
      (ua.buildGetter = oa),
      na() && qo.registerPlugin(ua);
    /*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
    var ha = function (t, e) {
      return (ha =
        Object.setPrototypeOf ||
        ({
          __proto__: [],
        } instanceof Array &&
          function (t, e) {
            t.__proto__ = e;
          }) ||
        function (t, e) {
          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        })(t, e);
    };
    var da = function () {
      return (da =
        Object.assign ||
        function (t) {
          for (var e, n = 1, i = arguments.length; n < i; n++)
            for (var r in (e = arguments[n]))
              Object.prototype.hasOwnProperty.call(e, r) && (t[r] = e[r]);
          return t;
        }).apply(this, arguments);
    };
    function pa(t, e, n, i) {
      var r,
        s = arguments.length,
        o =
          s < 3
            ? e
            : null === i
            ? (i = Object.getOwnPropertyDescriptor(e, n))
            : i;
      if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
        o = Reflect.decorate(t, e, n, i);
      else
        for (var a = t.length - 1; a >= 0; a--)
          (r = t[a]) &&
            (o = (s < 3 ? r(o) : s > 3 ? r(e, n, o) : r(e, n)) || o);
      return s > 3 && o && Object.defineProperty(e, n, o), o;
    }
    function fa() {
      for (var t = 0, e = 0, n = arguments.length; e < n; e++)
        t += arguments[e].length;
      var i = Array(t),
        r = 0;
      for (e = 0; e < n; e++)
        for (var s = arguments[e], o = 0, a = s.length; o < a; o++, r++)
          i[r] = s[o];
      return i;
    }
    n(91), n(119), n(122), n(130), n(134);
    var ma,
      ga = new WeakMap();
    function va() {
      if (void 0 !== ma) return ma;
      var t = !1;
      try {
        var e = function () {},
          n = Object.defineProperty({}, "passive", {
            enumerable: !0,
            get: function () {
              return (t = !0), !0;
            },
          });
        window.addEventListener("testPassive", e, n),
          window.removeEventListener("testPassive", e, n);
      } catch (t) {}
      return (ma = !!t && {
        passive: !1,
      });
    }
    function _a(t) {
      var e = ga.get(t) || [];
      return (
        ga.set(t, e),
        function (t, n, i) {
          function r(t) {
            t.defaultPrevented || i(t);
          }
          n.split(/\s+/g).forEach(function (n) {
            e.push({
              elem: t,
              eventName: n,
              handler: r,
            }),
              t.addEventListener(n, r, va());
          });
        }
      );
    }
    function ya(t) {
      var e = (function (t) {
        return t.touches ? t.touches[t.touches.length - 1] : t;
      })(t);
      return {
        x: e.clientX,
        y: e.clientY,
      };
    }
    function xa(t, e) {
      return (
        void 0 === e && (e = []),
        e.some(function (e) {
          return t === e;
        })
      );
    }
    var ba = ["webkit", "moz", "ms", "o"],
      Sa = new RegExp("^-(?!(?:" + ba.join("|") + ")-)");
    function Ea(t, e) {
      (e = (function (t) {
        var e = {};
        return (
          Object.keys(t).forEach(function (n) {
            if (Sa.test(n)) {
              var i = t[n];
              (n = n.replace(/^-/, "")),
                (e[n] = i),
                ba.forEach(function (t) {
                  e["-" + t + "-" + n] = i;
                });
            } else e[n] = t[n];
          }),
          e
        );
      })(e)),
        Object.keys(e).forEach(function (n) {
          var i = n.replace(/^-/, "").replace(/-([a-z])/g, function (t, e) {
            return e.toUpperCase();
          });
          t.style[i] = e[n];
        });
    }
    var Ma = (function () {
        function t(t) {
          (this.velocityMultiplier = window.devicePixelRatio),
            (this.updateTime = Date.now()),
            (this.delta = {
              x: 0,
              y: 0,
            }),
            (this.velocity = {
              x: 0,
              y: 0,
            }),
            (this.lastPosition = {
              x: 0,
              y: 0,
            }),
            (this.lastPosition = ya(t));
        }
        return (
          (t.prototype.update = function (t) {
            var e = this.velocity,
              n = this.updateTime,
              i = this.lastPosition,
              r = Date.now(),
              s = ya(t),
              o = {
                x: -(s.x - i.x),
                y: -(s.y - i.y),
              },
              a = r - n || 16.7,
              l = (o.x / a) * 16.7,
              c = (o.y / a) * 16.7;
            (e.x = l * this.velocityMultiplier),
              (e.y = c * this.velocityMultiplier),
              (this.delta = o),
              (this.updateTime = r),
              (this.lastPosition = s);
          }),
          t
        );
      })(),
      Ta = (function () {
        function t() {
          this._touchList = {};
        }
        return (
          Object.defineProperty(t.prototype, "_primitiveValue", {
            get: function () {
              return {
                x: 0,
                y: 0,
              };
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.isActive = function () {
            return void 0 !== this._activeTouchID;
          }),
          (t.prototype.getDelta = function () {
            var t = this._getActiveTracker();
            return t ? da({}, t.delta) : this._primitiveValue;
          }),
          (t.prototype.getVelocity = function () {
            var t = this._getActiveTracker();
            return t ? da({}, t.velocity) : this._primitiveValue;
          }),
          (t.prototype.getEasingDistance = function (t) {
            var e = 1 - t,
              n = {
                x: 0,
                y: 0,
              },
              i = this.getVelocity();
            return (
              Object.keys(i).forEach(function (t) {
                for (var r = Math.abs(i[t]) <= 10 ? 0 : i[t]; 0 !== r; )
                  (n[t] += r), (r = (r * e) | 0);
              }),
              n
            );
          }),
          (t.prototype.track = function (t) {
            var e = this,
              n = t.targetTouches;
            return (
              Array.from(n).forEach(function (t) {
                e._add(t);
              }),
              this._touchList
            );
          }),
          (t.prototype.update = function (t) {
            var e = this,
              n = t.touches,
              i = t.changedTouches;
            return (
              Array.from(n).forEach(function (t) {
                e._renew(t);
              }),
              this._setActiveID(i),
              this._touchList
            );
          }),
          (t.prototype.release = function (t) {
            var e = this;
            delete this._activeTouchID,
              Array.from(t.changedTouches).forEach(function (t) {
                e._delete(t);
              });
          }),
          (t.prototype._add = function (t) {
            this._has(t) && this._delete(t);
            var e = new Ma(t);
            this._touchList[t.identifier] = e;
          }),
          (t.prototype._renew = function (t) {
            this._has(t) && this._touchList[t.identifier].update(t);
          }),
          (t.prototype._delete = function (t) {
            delete this._touchList[t.identifier];
          }),
          (t.prototype._has = function (t) {
            return this._touchList.hasOwnProperty(t.identifier);
          }),
          (t.prototype._setActiveID = function (t) {
            this._activeTouchID = t[t.length - 1].identifier;
          }),
          (t.prototype._getActiveTracker = function () {
            return this._touchList[this._activeTouchID];
          }),
          t
        );
      })();
    function wa(t, e, n) {
      return Math.max(e, Math.min(n, t));
    }
    function Da(t, e, n) {
      var i;
      void 0 === e && (e = 0);
      var r = -1 / 0;
      return function () {
        for (var s = this, o = [], a = 0; a < arguments.length; a++)
          o[a] = arguments[a];
        if (n) {
          var l = Date.now(),
            c = l - r;
          (r = l), c >= e && t.apply(this, o);
        }
        clearTimeout(i),
          (i = setTimeout(function () {
            t.apply(s, o);
          }, e));
      };
    }
    function Aa(t, e) {
      return (
        void 0 === t && (t = -1 / 0),
        void 0 === e && (e = 1 / 0),
        function (n, i) {
          var r = "_" + i;
          Object.defineProperty(n, i, {
            get: function () {
              return this[r];
            },
            set: function (n) {
              Object.defineProperty(this, r, {
                value: wa(n, t, e),
                enumerable: !1,
                writable: !0,
                configurable: !0,
              });
            },
            enumerable: !0,
            configurable: !0,
          });
        }
      );
    }
    function Ca(t, e) {
      var n = "_" + e;
      Object.defineProperty(t, e, {
        get: function () {
          return this[n];
        },
        set: function (t) {
          Object.defineProperty(this, n, {
            value: !!t,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          });
        },
        enumerable: !0,
        configurable: !0,
      });
    }
    function Pa() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      return function (e, n, i) {
        var r = i.value;
        return {
          get: function () {
            return (
              this.hasOwnProperty(n) ||
                Object.defineProperty(this, n, {
                  value: Da.apply(void 0, fa([r], t)),
                }),
              this[n]
            );
          },
        };
      };
    }
    var Ra,
      La = (function () {
        function t(t) {
          var e = this;
          void 0 === t && (t = {}),
            (this.damping = 0.1),
            (this.thumbMinSize = 20),
            (this.renderByPixels = !0),
            (this.alwaysShowTracks = !1),
            (this.continuousScrolling = !0),
            (this.delegateTo = null),
            (this.plugins = {}),
            Object.keys(t).forEach(function (n) {
              e[n] = t[n];
            });
        }
        return (
          Object.defineProperty(t.prototype, "wheelEventTarget", {
            get: function () {
              return this.delegateTo;
            },
            set: function (t) {
              console.warn(
                "[smooth-scrollbar]: `options.wheelEventTarget` is deprecated and will be removed in the future, use `options.delegateTo` instead."
              ),
                (this.delegateTo = t);
            },
            enumerable: !0,
            configurable: !0,
          }),
          pa([Aa(0, 1)], t.prototype, "damping", void 0),
          pa([Aa(0, 1 / 0)], t.prototype, "thumbMinSize", void 0),
          pa([Ca], t.prototype, "renderByPixels", void 0),
          pa([Ca], t.prototype, "alwaysShowTracks", void 0),
          pa([Ca], t.prototype, "continuousScrolling", void 0),
          t
        );
      })();
    !(function (t) {
      (t.X = "x"), (t.Y = "y");
    })(Ra || (Ra = {}));
    var Oa = (function () {
        function t(t, e) {
          void 0 === e && (e = 0),
            (this._direction = t),
            (this._minSize = e),
            (this.element = document.createElement("div")),
            (this.displaySize = 0),
            (this.realSize = 0),
            (this.offset = 0),
            (this.element.className = "scrollbar-thumb scrollbar-thumb-" + t);
        }
        return (
          (t.prototype.attachTo = function (t) {
            t.appendChild(this.element);
          }),
          (t.prototype.update = function (t, e, n) {
            (this.realSize = Math.min(e / n, 1) * e),
              (this.displaySize = Math.max(this.realSize, this._minSize)),
              (this.offset =
                (t / n) * (e + (this.realSize - this.displaySize))),
              Ea(this.element, this._getStyle());
          }),
          (t.prototype._getStyle = function () {
            switch (this._direction) {
              case Ra.X:
                return {
                  width: this.displaySize + "px",
                  "-transform": "translate3d(" + this.offset + "px, 0, 0)",
                };
              case Ra.Y:
                return {
                  height: this.displaySize + "px",
                  "-transform": "translate3d(0, " + this.offset + "px, 0)",
                };
              default:
                return null;
            }
          }),
          t
        );
      })(),
      Ia = (function () {
        function t(t, e) {
          void 0 === e && (e = 0),
            (this.element = document.createElement("div")),
            (this._isShown = !1),
            (this.element.className = "scrollbar-track scrollbar-track-" + t),
            (this.thumb = new Oa(t, e)),
            this.thumb.attachTo(this.element);
        }
        return (
          (t.prototype.attachTo = function (t) {
            t.appendChild(this.element);
          }),
          (t.prototype.show = function () {
            this._isShown ||
              ((this._isShown = !0), this.element.classList.add("show"));
          }),
          (t.prototype.hide = function () {
            this._isShown &&
              ((this._isShown = !1), this.element.classList.remove("show"));
          }),
          (t.prototype.update = function (t, e, n) {
            Ea(this.element, {
              display: n <= e ? "none" : "block",
            }),
              this.thumb.update(t, e, n);
          }),
          t
        );
      })(),
      Fa = (function () {
        function t(t) {
          this._scrollbar = t;
          var e = t.options.thumbMinSize;
          (this.xAxis = new Ia(Ra.X, e)),
            (this.yAxis = new Ia(Ra.Y, e)),
            this.xAxis.attachTo(t.containerEl),
            this.yAxis.attachTo(t.containerEl),
            t.options.alwaysShowTracks &&
              (this.xAxis.show(), this.yAxis.show());
        }
        return (
          (t.prototype.update = function () {
            var t = this._scrollbar,
              e = t.size,
              n = t.offset;
            this.xAxis.update(n.x, e.container.width, e.content.width),
              this.yAxis.update(n.y, e.container.height, e.content.height);
          }),
          (t.prototype.autoHideOnIdle = function () {
            this._scrollbar.options.alwaysShowTracks ||
              (this.xAxis.hide(), this.yAxis.hide());
          }),
          pa([Pa(300)], t.prototype, "autoHideOnIdle", null),
          t
        );
      })();
    var Ua = new WeakMap();
    function Na(t) {
      return Math.pow(t - 1, 3) + 1;
    }
    var ka,
      za,
      Ba,
      Ha = (function () {
        function t(t, e) {
          var n = this.constructor;
          (this.scrollbar = t),
            (this.name = n.pluginName),
            (this.options = da(da({}, n.defaultOptions), e));
        }
        return (
          (t.prototype.onInit = function () {}),
          (t.prototype.onDestroy = function () {}),
          (t.prototype.onUpdate = function () {}),
          (t.prototype.onRender = function (t) {}),
          (t.prototype.transformDelta = function (t, e) {
            return da({}, t);
          }),
          (t.pluginName = ""),
          (t.defaultOptions = {}),
          t
        );
      })(),
      Va = {
        order: new Set(),
        constructors: {},
      };
    function Ga() {
      for (var t = [], e = 0; e < arguments.length; e++) t[e] = arguments[e];
      t.forEach(function (t) {
        var e = t.pluginName;
        if (!e) throw new TypeError("plugin name is required");
        Va.order.add(e), (Va.constructors[e] = t);
      });
    }
    function Wa(t) {
      var e = _a(t),
        n = t.containerEl;
      e(n, "keydown", function (e) {
        var i = document.activeElement;
        if (
          (i === n || n.contains(i)) &&
          !(function (t) {
            if (
              "INPUT" === t.tagName ||
              "SELECT" === t.tagName ||
              "TEXTAREA" === t.tagName ||
              t.isContentEditable
            )
              return !t.disabled;
            return !1;
          })(i)
        ) {
          var r = (function (t, e) {
            var n = t.size,
              i = t.limit,
              r = t.offset;
            switch (e) {
              case ka.TAB:
                return (function (t) {
                  requestAnimationFrame(function () {
                    t.scrollIntoView(document.activeElement, {
                      offsetTop: t.size.container.height / 2,
                      offsetLeft: t.size.container.width / 2,
                      onlyScrollIfNeeded: !0,
                    });
                  });
                })(t);
              case ka.SPACE:
                return [0, 200];
              case ka.PAGE_UP:
                return [0, 40 - n.container.height];
              case ka.PAGE_DOWN:
                return [0, n.container.height - 40];
              case ka.END:
                return [0, i.y - r.y];
              case ka.HOME:
                return [0, -r.y];
              case ka.LEFT:
                return [-40, 0];
              case ka.UP:
                return [0, -40];
              case ka.RIGHT:
                return [40, 0];
              case ka.DOWN:
                return [0, 40];
              default:
                return null;
            }
          })(t, e.keyCode || e.which);
          if (r) {
            var s = r[0],
              o = r[1];
            t.addTransformableMomentum(s, o, e, function (n) {
              n
                ? e.preventDefault()
                : (t.containerEl.blur(),
                  t.parent && t.parent.containerEl.focus());
            });
          }
        }
      });
    }
    function ja(t) {
      var e,
        n,
        i,
        r,
        s,
        o = _a(t),
        a = t.containerEl,
        l = t.track,
        c = l.xAxis,
        u = l.yAxis;
      function h(e, n) {
        var i = t.size,
          r = t.limit,
          s = t.offset;
        return e === za.X
          ? wa(
              (n /
                (i.container.width +
                  (c.thumb.realSize - c.thumb.displaySize))) *
                i.content.width,
              0,
              r.x
            ) - s.x
          : e === za.Y
          ? wa(
              (n /
                (i.container.height +
                  (u.thumb.realSize - u.thumb.displaySize))) *
                i.content.height,
              0,
              r.y
            ) - s.y
          : 0;
      }
      function d(t) {
        return xa(t, [c.element, c.thumb.element])
          ? za.X
          : xa(t, [u.element, u.thumb.element])
          ? za.Y
          : void 0;
      }
      o(a, "click", function (e) {
        if (!n && xa(e.target, [c.element, u.element])) {
          var i = e.target,
            r = d(i),
            s = i.getBoundingClientRect(),
            o = ya(e);
          if (r === za.X) {
            var a = o.x - s.left - c.thumb.displaySize / 2;
            t.setMomentum(h(r, a), 0);
          }
          if (r === za.Y) {
            a = o.y - s.top - u.thumb.displaySize / 2;
            t.setMomentum(0, h(r, a));
          }
        }
      }),
        o(a, "mousedown", function (n) {
          if (xa(n.target, [c.thumb.element, u.thumb.element])) {
            e = !0;
            var o = n.target,
              l = ya(n),
              h = o.getBoundingClientRect();
            (r = d(o)),
              (i = {
                x: l.x - h.left,
                y: l.y - h.top,
              }),
              (s = a.getBoundingClientRect()),
              Ea(t.containerEl, {
                "-user-select": "none",
              });
          }
        }),
        o(window, "mousemove", function (o) {
          if (e) {
            n = !0;
            var a = ya(o);
            if (r === za.X) {
              var l = a.x - i.x - s.left;
              t.setMomentum(h(r, l), 0);
            }
            if (r === za.Y) {
              l = a.y - i.y - s.top;
              t.setMomentum(0, h(r, l));
            }
          }
        }),
        o(window, "mouseup blur", function () {
          (e = n = !1),
            Ea(t.containerEl, {
              "-user-select": "",
            });
        });
    }
    function Xa(t) {
      _a(t)(window, "resize", Da(t.update.bind(t), 300));
    }
    function qa(t) {
      var e,
        n = _a(t),
        i = t.containerEl,
        r = t.contentEl,
        s = !1,
        o = !1;
      n(window, "mousemove", function (n) {
        s &&
          (cancelAnimationFrame(e),
          (function n(i) {
            var r = i.x,
              s = i.y;
            if (r || s) {
              var o = t.offset,
                a = t.limit;
              t.setMomentum(
                wa(o.x + r, 0, a.x) - o.x,
                wa(o.y + s, 0, a.y) - o.y
              ),
                (e = requestAnimationFrame(function () {
                  n({
                    x: r,
                    y: s,
                  });
                }));
            }
          })(
            (function (t, e) {
              var n = t.bounding,
                i = n.top,
                r = n.right,
                s = n.bottom,
                o = n.left,
                a = ya(e),
                l = a.x,
                c = a.y,
                u = {
                  x: 0,
                  y: 0,
                };
              if (0 === l && 0 === c) return u;
              l > r - 20
                ? (u.x = l - r + 20)
                : l < o + 20 && (u.x = l - o - 20);
              c > s - 20
                ? (u.y = c - s + 20)
                : c < i + 20 && (u.y = c - i - 20);
              return (u.x *= 2), (u.y *= 2), u;
            })(t, n)
          ));
      }),
        n(r, "contextmenu", function () {
          (o = !0), cancelAnimationFrame(e), (s = !1);
        }),
        n(r, "mousedown", function () {
          o = !1;
        }),
        n(r, "selectstart", function () {
          o || (cancelAnimationFrame(e), (s = !0));
        }),
        n(window, "mouseup blur", function () {
          cancelAnimationFrame(e), (s = !1), (o = !1);
        }),
        n(i, "scroll", function (t) {
          t.preventDefault(), (i.scrollTop = i.scrollLeft = 0);
        });
    }
    function Ya(t) {
      var e,
        n = t.options.delegateTo || t.containerEl,
        i = new Ta(),
        r = _a(t),
        s = 0;
      r(n, "touchstart", function (n) {
        i.track(n),
          t.setMomentum(0, 0),
          0 === s &&
            ((e = t.options.damping), (t.options.damping = Math.max(e, 0.5))),
          s++;
      }),
        r(n, "touchmove", function (e) {
          if (!Ba || Ba === t) {
            i.update(e);
            var n = i.getDelta(),
              r = n.x,
              s = n.y;
            t.addTransformableMomentum(r, s, e, function (n) {
              n && e.cancelable && (e.preventDefault(), (Ba = t));
            });
          }
        }),
        r(n, "touchcancel touchend", function (n) {
          var r = i.getEasingDistance(e);
          t.addTransformableMomentum(r.x, r.y, n),
            0 === --s && (t.options.damping = e),
            i.release(n),
            (Ba = null);
        });
    }
    function Ka(t) {
      _a(t)(
        t.options.delegateTo || t.containerEl,
        "onwheel" in window ||
          document.implementation.hasFeature("Events.wheel", "3.0")
          ? "wheel"
          : "mousewheel",
        function (e) {
          var n = (function (t) {
              if ("deltaX" in t) {
                var e = (function (t) {
                  return $a[t] || $a[0];
                })(t.deltaMode);
                return {
                  x: (t.deltaX / Za) * e,
                  y: (t.deltaY / Za) * e,
                };
              }
              if ("wheelDeltaX" in t)
                return {
                  x: t.wheelDeltaX / Ja,
                  y: t.wheelDeltaY / Ja,
                };
              return {
                x: 0,
                y: t.wheelDelta / Ja,
              };
            })(e),
            i = n.x,
            r = n.y;
          t.addTransformableMomentum(i, r, e, function (t) {
            t && e.preventDefault();
          });
        }
      );
    }
    !(function (t) {
      (t[(t.TAB = 9)] = "TAB"),
        (t[(t.SPACE = 32)] = "SPACE"),
        (t[(t.PAGE_UP = 33)] = "PAGE_UP"),
        (t[(t.PAGE_DOWN = 34)] = "PAGE_DOWN"),
        (t[(t.END = 35)] = "END"),
        (t[(t.HOME = 36)] = "HOME"),
        (t[(t.LEFT = 37)] = "LEFT"),
        (t[(t.UP = 38)] = "UP"),
        (t[(t.RIGHT = 39)] = "RIGHT"),
        (t[(t.DOWN = 40)] = "DOWN");
    })(ka || (ka = {})),
      (function (t) {
        (t[(t.X = 0)] = "X"), (t[(t.Y = 1)] = "Y");
      })(za || (za = {}));
    var Za = 1,
      Ja = -3,
      $a = [1, 28, 500];
    var Qa = new Map(),
      tl = (function () {
        function t(t, e) {
          var n = this;
          (this.offset = {
            x: 0,
            y: 0,
          }),
            (this.limit = {
              x: 1 / 0,
              y: 1 / 0,
            }),
            (this.bounding = {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0,
            }),
            (this._plugins = []),
            (this._momentum = {
              x: 0,
              y: 0,
            }),
            (this._listeners = new Set()),
            (this.containerEl = t);
          var i = (this.contentEl = document.createElement("div"));
          (this.options = new La(e)),
            t.setAttribute("data-scrollbar", "true"),
            t.setAttribute("tabindex", "-1"),
            Ea(t, {
              overflow: "hidden",
              outline: "none",
            }),
            window.navigator.msPointerEnabled &&
              (t.style.msTouchAction = "none"),
            (i.className = "scroll-content"),
            Array.from(t.childNodes).forEach(function (t) {
              i.appendChild(t);
            }),
            t.appendChild(i),
            (this.track = new Fa(this)),
            (this.size = this.getSize()),
            (this._plugins = (function (t, e) {
              return Array.from(Va.order)
                .filter(function (t) {
                  return !1 !== e[t];
                })
                .map(function (n) {
                  var i = new (0, Va.constructors[n])(t, e[n]);
                  return (e[n] = i.options), i;
                });
            })(this, this.options.plugins));
          var r = t.scrollLeft,
            s = t.scrollTop;
          (t.scrollLeft = t.scrollTop = 0),
            this.setPosition(r, s, {
              withoutCallbacks: !0,
            });
          var o = window.ResizeObserver;
          "function" == typeof o &&
            ((this._observer = new o(function () {
              n.update();
            })),
            this._observer.observe(i)),
            Qa.set(t, this),
            requestAnimationFrame(function () {
              n._init();
            });
        }
        return (
          Object.defineProperty(t.prototype, "parent", {
            get: function () {
              for (var t = this.containerEl.parentElement; t; ) {
                var e = Qa.get(t);
                if (e) return e;
                t = t.parentElement;
              }
              return null;
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "scrollTop", {
            get: function () {
              return this.offset.y;
            },
            set: function (t) {
              this.setPosition(this.scrollLeft, t);
            },
            enumerable: !0,
            configurable: !0,
          }),
          Object.defineProperty(t.prototype, "scrollLeft", {
            get: function () {
              return this.offset.x;
            },
            set: function (t) {
              this.setPosition(t, this.scrollTop);
            },
            enumerable: !0,
            configurable: !0,
          }),
          (t.prototype.getSize = function () {
            return (
              (e = (t = this).containerEl),
              (n = t.contentEl),
              (i = getComputedStyle(e)),
              (r = [
                "paddingTop",
                "paddingBottom",
                "paddingLeft",
                "paddingRight",
              ].map(function (t) {
                return i[t] ? parseFloat(i[t]) : 0;
              })),
              (s = r[0] + r[1]),
              (o = r[2] + r[3]),
              {
                container: {
                  width: e.clientWidth,
                  height: e.clientHeight,
                },
                content: {
                  width: n.offsetWidth - n.clientWidth + n.scrollWidth + o,
                  height: n.offsetHeight - n.clientHeight + n.scrollHeight + s,
                },
              }
            );
            var t, e, n, i, r, s, o;
          }),
          (t.prototype.update = function () {
            var t, e, n, i, r;
            (e = (t = this).getSize()),
              (n = {
                x: Math.max(e.content.width - e.container.width, 0),
                y: Math.max(e.content.height - e.container.height, 0),
              }),
              (i = t.containerEl.getBoundingClientRect()),
              (r = {
                top: Math.max(i.top, 0),
                right: Math.min(i.right, window.innerWidth),
                bottom: Math.min(i.bottom, window.innerHeight),
                left: Math.max(i.left, 0),
              }),
              (t.size = e),
              (t.limit = n),
              (t.bounding = r),
              t.track.update(),
              t.setPosition(),
              this._plugins.forEach(function (t) {
                t.onUpdate();
              });
          }),
          (t.prototype.isVisible = function (t) {
            return (function (t, e) {
              var n = t.bounding,
                i = e.getBoundingClientRect(),
                r = Math.max(n.top, i.top),
                s = Math.max(n.left, i.left),
                o = Math.min(n.right, i.right);
              return r < Math.min(n.bottom, i.bottom) && s < o;
            })(this, t);
          }),
          (t.prototype.setPosition = function (t, e, n) {
            var i = this;
            void 0 === t && (t = this.offset.x),
              void 0 === e && (e = this.offset.y),
              void 0 === n && (n = {});
            var r = (function (t, e, n) {
              var i = t.options,
                r = t.offset,
                s = t.limit,
                o = t.track,
                a = t.contentEl;
              return (
                i.renderByPixels && ((e = Math.round(e)), (n = Math.round(n))),
                (e = wa(e, 0, s.x)),
                (n = wa(n, 0, s.y)),
                e !== r.x && o.xAxis.show(),
                n !== r.y && o.yAxis.show(),
                i.alwaysShowTracks || o.autoHideOnIdle(),
                e === r.x && n === r.y
                  ? null
                  : ((r.x = e),
                    (r.y = n),
                    Ea(a, {
                      "-transform":
                        "translate3d(" + -e + "px, " + -n + "px, 0)",
                    }),
                    o.update(),
                    {
                      offset: da({}, r),
                      limit: da({}, s),
                    })
              );
            })(this, t, e);
            r &&
              !n.withoutCallbacks &&
              this._listeners.forEach(function (t) {
                t.call(i, r);
              });
          }),
          (t.prototype.scrollTo = function (t, e, n, i) {
            void 0 === t && (t = this.offset.x),
              void 0 === e && (e = this.offset.y),
              void 0 === n && (n = 0),
              void 0 === i && (i = {}),
              (function (t, e, n, i, r) {
                void 0 === i && (i = 0);
                var s = void 0 === r ? {} : r,
                  o = s.easing,
                  a = void 0 === o ? Na : o,
                  l = s.callback,
                  c = t.options,
                  u = t.offset,
                  h = t.limit;
                c.renderByPixels && ((e = Math.round(e)), (n = Math.round(n)));
                var d = u.x,
                  p = u.y,
                  f = wa(e, 0, h.x) - d,
                  m = wa(n, 0, h.y) - p,
                  g = Date.now();
                cancelAnimationFrame(Ua.get(t)),
                  (function e() {
                    var n = Date.now() - g,
                      r = i ? a(Math.min(n / i, 1)) : 1;
                    if ((t.setPosition(d + f * r, p + m * r), n >= i))
                      "function" == typeof l && l.call(t);
                    else {
                      var s = requestAnimationFrame(e);
                      Ua.set(t, s);
                    }
                  })();
              })(this, t, e, n, i);
          }),
          (t.prototype.scrollIntoView = function (t, e) {
            void 0 === e && (e = {}),
              (function (t, e, n) {
                var i = void 0 === n ? {} : n,
                  r = i.alignToTop,
                  s = void 0 === r || r,
                  o = i.onlyScrollIfNeeded,
                  a = void 0 !== o && o,
                  l = i.offsetTop,
                  c = void 0 === l ? 0 : l,
                  u = i.offsetLeft,
                  h = void 0 === u ? 0 : u,
                  d = i.offsetBottom,
                  p = void 0 === d ? 0 : d,
                  f = t.containerEl,
                  m = t.bounding,
                  g = t.offset,
                  v = t.limit;
                if (e && f.contains(e)) {
                  var _ = e.getBoundingClientRect();
                  if (!a || !t.isVisible(e)) {
                    var y = s ? _.top - m.top - c : _.bottom - m.bottom + p;
                    t.setMomentum(_.left - m.left - h, wa(y, -g.y, v.y - g.y));
                  }
                }
              })(this, t, e);
          }),
          (t.prototype.addListener = function (t) {
            if ("function" != typeof t)
              throw new TypeError(
                "[smooth-scrollbar] scrolling listener should be a function"
              );
            this._listeners.add(t);
          }),
          (t.prototype.removeListener = function (t) {
            this._listeners.delete(t);
          }),
          (t.prototype.addTransformableMomentum = function (t, e, n, i) {
            this._updateDebounced();
            var r = this._plugins.reduce(
                function (t, e) {
                  return e.transformDelta(t, n) || t;
                },
                {
                  x: t,
                  y: e,
                }
              ),
              s = !this._shouldPropagateMomentum(r.x, r.y);
            s && this.addMomentum(r.x, r.y), i && i.call(this, s);
          }),
          (t.prototype.addMomentum = function (t, e) {
            this.setMomentum(this._momentum.x + t, this._momentum.y + e);
          }),
          (t.prototype.setMomentum = function (t, e) {
            0 === this.limit.x && (t = 0),
              0 === this.limit.y && (e = 0),
              this.options.renderByPixels &&
                ((t = Math.round(t)), (e = Math.round(e))),
              (this._momentum.x = t),
              (this._momentum.y = e);
          }),
          (t.prototype.updatePluginOptions = function (t, e) {
            this._plugins.forEach(function (n) {
              n.name === t && Object.assign(n.options, e);
            });
          }),
          (t.prototype.destroy = function () {
            var t,
              e,
              n = this.containerEl,
              i = this.contentEl;
            (t = this),
              (e = ga.get(t)) &&
                (e.forEach(function (t) {
                  var e = t.elem,
                    n = t.eventName,
                    i = t.handler;
                  e.removeEventListener(n, i, va());
                }),
                ga.delete(t)),
              this._listeners.clear(),
              this.setMomentum(0, 0),
              cancelAnimationFrame(this._renderID),
              this._observer && this._observer.disconnect(),
              Qa.delete(this.containerEl);
            for (var r = Array.from(i.childNodes); n.firstChild; )
              n.removeChild(n.firstChild);
            r.forEach(function (t) {
              n.appendChild(t);
            }),
              Ea(n, {
                overflow: "",
              }),
              (n.scrollTop = this.scrollTop),
              (n.scrollLeft = this.scrollLeft),
              this._plugins.forEach(function (t) {
                t.onDestroy();
              }),
              (this._plugins.length = 0);
          }),
          (t.prototype._init = function () {
            var t = this;
            this.update(),
              Object.keys(i).forEach(function (e) {
                i[e](t);
              }),
              this._plugins.forEach(function (t) {
                t.onInit();
              }),
              this._render();
          }),
          (t.prototype._updateDebounced = function () {
            this.update();
          }),
          (t.prototype._shouldPropagateMomentum = function (t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = 0);
            var n = this.options,
              i = this.offset,
              r = this.limit;
            if (!n.continuousScrolling) return !1;
            0 === r.x && 0 === r.y && this._updateDebounced();
            var s = wa(t + i.x, 0, r.x),
              o = wa(e + i.y, 0, r.y),
              a = !0;
            return (a =
              (a = (a = a && s === i.x) && o === i.y) &&
              (i.x === r.x || 0 === i.x || i.y === r.y || 0 === i.y));
          }),
          (t.prototype._render = function () {
            var t = this._momentum;
            if (t.x || t.y) {
              var e = this._nextTick("x"),
                n = this._nextTick("y");
              (t.x = e.momentum),
                (t.y = n.momentum),
                this.setPosition(e.position, n.position);
            }
            var i = da({}, this._momentum);
            this._plugins.forEach(function (t) {
              t.onRender(i);
            }),
              (this._renderID = requestAnimationFrame(this._render.bind(this)));
          }),
          (t.prototype._nextTick = function (t) {
            var e = this.options,
              n = this.offset,
              i = this._momentum,
              r = n[t],
              s = i[t];
            if (Math.abs(s) <= 0.1)
              return {
                momentum: 0,
                position: r + s,
              };
            var o = s * (1 - e.damping);
            return (
              e.renderByPixels && (o |= 0),
              {
                momentum: o,
                position: r + s - o,
              }
            );
          }),
          pa([Pa(100, !0)], t.prototype, "_updateDebounced", null),
          t
        );
      })(),
      el = !1;
    function nl() {
      if (!el && "undefined" != typeof window) {
        var t = document.createElement("style");
        (t.id = "smooth-scrollbar-style"),
          (t.textContent =
            "\n[data-scrollbar] {\n  display: block;\n  position: relative;\n}\n\n.scroll-content {\n  display: flow-root;\n  -webkit-transform: translate3d(0, 0, 0);\n          transform: translate3d(0, 0, 0);\n}\n\n.scrollbar-track {\n  position: absolute;\n  opacity: 0;\n  z-index: 1;\n  background: rgba(222, 222, 222, .75);\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-transition: opacity 0.5s 0.5s ease-out;\n          transition: opacity 0.5s 0.5s ease-out;\n}\n.scrollbar-track.show,\n.scrollbar-track:hover {\n  opacity: 1;\n  -webkit-transition-delay: 0s;\n          transition-delay: 0s;\n}\n\n.scrollbar-track-x {\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  height: 8px;\n}\n.scrollbar-track-y {\n  top: 0;\n  right: 0;\n  width: 8px;\n  height: 100%;\n}\n.scrollbar-thumb {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 8px;\n  height: 8px;\n  background: rgba(0, 0, 0, .5);\n  border-radius: 4px;\n}\n"),
          document.head && document.head.appendChild(t),
          (el = !0);
      }
    }
    var il = (function (t) {
      function e() {
        return (null !== t && t.apply(this, arguments)) || this;
      }
      return (
        (function (t, e) {
          function n() {
            this.constructor = t;
          }
          ha(t, e),
            (t.prototype =
              null === e
                ? Object.create(e)
                : ((n.prototype = e.prototype), new n()));
        })(e, t),
        (e.init = function (t, e) {
          if (!t || 1 !== t.nodeType)
            throw new TypeError(
              "expect element to be DOM Element, but got " + t
            );
          return nl(), Qa.has(t) ? Qa.get(t) : new tl(t, e);
        }),
        (e.initAll = function (t) {
          return Array.from(
            document.querySelectorAll("[data-scrollbar]"),
            function (n) {
              return e.init(n, t);
            }
          );
        }),
        (e.has = function (t) {
          return Qa.has(t);
        }),
        (e.get = function (t) {
          return Qa.get(t);
        }),
        (e.getAll = function () {
          return Array.from(Qa.values());
        }),
        (e.destroy = function (t) {
          var e = Qa.get(t);
          e && e.destroy();
        }),
        (e.destroyAll = function () {
          Qa.forEach(function (t) {
            t.destroy();
          });
        }),
        (e.use = function () {
          for (var t = [], e = 0; e < arguments.length; e++)
            t[e] = arguments[e];
          return Ga.apply(void 0, t);
        }),
        (e.attachStyle = function () {
          return nl();
        }),
        (e.detachStyle = function () {
          return (function () {
            if (el && "undefined" != typeof window) {
              var t = document.getElementById("smooth-scrollbar-style");
              t && t.parentNode && (t.parentNode.removeChild(t), (el = !1));
            }
          })();
        }),
        (e.version = "8.8.4"),
        (e.ScrollbarPlugin = Ha),
        e
      );
    })(tl);
    function rl(t, e) {
      return (rl = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    /*!
     * SmoothScrollbar Disable Plugin
     *
     * @version 1.0.1
     * @author Artem Dordzhiev (Draft)
     */
    var sl = (function (t) {
      var e, n;
      function i() {
        return t.apply(this, arguments) || this;
      }
      return (
        (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        rl(e, n),
        (i.prototype.transformDelta = function (t, e) {
          return this.options.disable
            ? {
                x: 0,
                y: 0,
              }
            : t;
        }),
        i
      );
    })(il.ScrollbarPlugin);
    (sl.pluginName = "Disable"),
      (sl.defaultOptions = {
        disable: !1,
      });
    var ol = sl;
    function al(t, e) {
      return (al = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    /*!
     * SmoothScrollbar SoftScroll Plugin
     *
     * @version 1.0.2
     * @author Artem Dordzhiev (Draft)
     */
    var ll = (function (t) {
      var e, n;
      function i() {
        return t.apply(this, arguments) || this;
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        al(e, n);
      var r = i.prototype;
      return (
        (r.transformDelta = function (t, e) {
          var n = t.x > 0 ? 1 : -1,
            i = t.y > 0 ? 1 : -1;
          return n === this.lockX || i === this.lockY
            ? {
                x: 0,
                y: 0,
              }
            : ((this.lockX = null), (this.lockY = null), t);
        }),
        (r.onRender = function (t) {
          var e = t.x,
            n = t.y;
          n < 0 &&
            !this.lockY &&
            Math.abs(n) >= this.scrollbar.scrollTop &&
            (this.scrollbar.setMomentum(0, -this.scrollbar.scrollTop),
            (this.lockY = -1)),
            e < 0 &&
              !this.lockX &&
              Math.abs(e) >= this.scrollbar.scrollLeft &&
              (this.scrollbar.setMomentum(-this.scrollbar.scrollLeft, 0),
              (this.lockX = -1)),
            e > 0 &&
              !this.lockX &&
              Math.abs(e) >=
                this.scrollbar.limit.x - this.scrollbar.scrollLeft &&
              (this.scrollbar.setMomentum(
                this.scrollbar.limit.x - this.scrollbar.scrollLeft,
                0
              ),
              (this.lockX = 1)),
            n > 0 &&
              !this.lockY &&
              Math.abs(n) >=
                this.scrollbar.limit.y - this.scrollbar.scrollTop &&
              (this.scrollbar.setMomentum(
                0,
                this.scrollbar.limit.y - this.scrollbar.scrollTop
              ),
              (this.lockY = 1)),
            0 === n && (this.lockY = null),
            0 === e && (this.lockX = null);
        }),
        i
      );
    })(il.ScrollbarPlugin);
    ll.pluginName = "SoftScroll";
    var cl = ll;
    function ul(t, e) {
      return (ul = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    /*!
     * SmoothScrollbar GSAP ScrollTrigger Plugin
     *
     * @version 1.0.5
     * @author Artem Dordzhiev (Draft)
     */
    Yi.registerPlugin(No);
    var hl = {
        el: document.body,
        vars: {
          scrollTop: function (t) {
            return (
              arguments.length && (hl.scrollbar.scrollTop = t),
              hl.scrollbar.scrollTop
            );
          },
          scrollLeft: function (t) {
            return (
              arguments.length && (hl.scrollbar.scrollLeft = t),
              hl.scrollbar.scrollLeft
            );
          },
          getBoundingClientRect: function () {
            return {
              top: 0,
              left: 0,
              width: window.innerWidth,
              height: window.innerHeight,
            };
          },
          pinType: "transform",
        },
      },
      dl = (function (t) {
        var e, n;
        function i(e, n) {
          var i;
          return (
            (i = t.call(this, e, n) || this),
            (hl.scrollbar = e),
            No.scrollerProxy(hl.el, hl.vars),
            No.defaults({
              pinType: "transform",
            }),
            e.addListener(No.update),
            i
          );
        }
        return (
          (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          ul(e, n),
          i
        );
      })(il.ScrollbarPlugin);
    dl.pluginName = "ScrollTrigger";
    var pl = dl;
    function fl(t, e) {
      return (fl = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    Yi.registerPlugin(ua), il.use(ol, cl, pl);
    var ml = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            (e = t.apply(this, arguments) || this).bindNativeScrolling(),
            e.initSmoothScrolling(),
            (e.hideTl = e.tlHide()),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          fl(e, n);
        var r = i.prototype;
        return (
          (r.onEnter = function () {
            try {
              return this.scrollToHash(), Promise.resolve();
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onComplete = function () {
            try {
              var t = this;
              return (
                setTimeout(function () {
                  return t.loadLazyImages();
                }, 3e3),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onLeave = function () {
            try {
              return (
                this.hideTl.play(0),
                No && (No.killAll(), No.clearScrollMemory()),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.onDestroy = function () {
            try {
              return (
                this.ssb && this.destroySmoothScrolling(),
                window.removeEventListener("scroll", this.nativeScrollEvent),
                Promise.resolve()
              );
            } catch (t) {
              return Promise.reject(t);
            }
          }),
          (r.tlHide = function () {
            var t = new Yi.timeline({
              paused: !0,
            });
            return (
              this.ssb
                ? (t.set(this.el, {
                    willChange: "transform",
                    transformOrigin: "bottom center",
                    immediateRender: !1,
                  }),
                  t.to(this.el, {
                    scale: this.ssb ? 0.96 : 1,
                    opacity: this.ssb ? 0.94 : 0.8,
                    duration: 0.6,
                    ease: "expo.out",
                    immediateRender: !1,
                  }))
                : t.to(this.el, {
                    opacity: 0.7,
                    duration: 0.4,
                    immediateRender: !1,
                  }),
              t
            );
          }),
          (r.bindNativeScrolling = function () {
            var t = this;
            (this.nativeScrollEvent = function () {
              return t.app.trigger(
                "scrolling",
                window.pageYOffset,
                window.pageXOffset
              );
            }),
              window.addEventListener("scroll", this.nativeScrollEvent);
          }),
          (r.initSmoothScrolling = function () {
            var t = this;
            window.matchMedia("(pointer:fine)").matches &&
              ((this.ssb = il.init(this.el, {
                continuousScrolling: !1,
                renderByPixels: !0,
                damping: 0.08,
              })),
              this.ssb.addListener(function (e) {
                return t.app.trigger("scrolling", e.offset.y, e.offset.x);
              }),
              document.documentElement.classList.add("smooth"));
          }),
          (r.destroySmoothScrolling = function () {
            this.ssb.destroy(),
              (this.ssb = null),
              document.documentElement.classList.remove("smooth");
          }),
          (r.scrollEnable = function () {
            document.documentElement.classList.remove("no-scroll"),
              this.ssb &&
                this.ssb.updatePluginOptions("Disable", {
                  disable: !1,
                });
          }),
          (r.scrollDisable = function () {
            document.documentElement.classList.add("no-scroll"),
              this.ssb &&
                this.ssb.updatePluginOptions("Disable", {
                  disable: !0,
                });
          }),
          (r.scrollTop = function () {
            return this.ssb ? this.ssb.scrollTop : window.pageYOffset;
          }),
          (r.scrollLeft = function () {
            return this.ssb ? this.ssb.scrollLeft : window.pageXOffset;
          }),
          (r.scrollHeight = function () {
            return this.ssb
              ? this.ssb.limit.y
              : document.documentElement.scrollHeight;
          }),
          (r.scrollWidth = function () {
            return this.ssb
              ? this.ssb.limit.x
              : document.documentElement.scrollWidth;
          }),
          (r.scrollTo = function (t, e, n) {
            void 0 === e && (e = 0),
              void 0 === n && (n = {}),
              (t += (n = Object.assign(
                {},
                {
                  offsetY: 0,
                  offsetX: 0,
                  duration: 0.3,
                  callback: null,
                  ease: null,
                },
                n
              )).offsetY),
              (e += n.offsetX),
              this.ssb
                ? this.ssb.scrollTo(e, t, 1e3 * n.duration, {
                    callback: n.callback,
                    easing: n.ease,
                  })
                : ua
                ? Yi.to(window, {
                    scrollTo: {
                      y: t,
                      x: e,
                      autoKill: !1,
                    },
                    ease: n.ease,
                    duration: n.duration,
                    onComplete: n.callback,
                  })
                : window.scrollTo({
                    top: t,
                    left: e,
                    behavior: n.duration ? "smooth" : "instant",
                  });
          }),
          (r.scrollToTarget = function (t, e) {
            var n = this.app.query(t);
            if (n) {
              var i = n.getBoundingClientRect(),
                r = i.top + this.scrollTop(),
                s = i.left + this.scrollLeft();
              this.scrollTo(r, s, e);
            }
          }),
          (r.scrollToHash = function () {
            window.location.hash &&
              (this.ssb && this.ssb.update(),
              this.scrollToTarget(
                "#section-" + window.location.hash.substr(1),
                {
                  duration: 0,
                }
              ));
          }),
          (r.loadLazyImages = function () {
            this.el.querySelectorAll("img[loading=lazy]").forEach(function (t) {
              t.setAttribute("loading", "eager");
            });
          }),
          i
        );
      })(l),
      gl = (function () {
        function t(e) {
          void 0 === e && (e = {}),
            (this.options = Object.assign(
              {},
              {
                el: null,
                container: document.body,
                className: "mf-cursor",
                innerClassName: "mf-cursor-inner",
                textClassName: "mf-cursor-text",
                mediaClassName: "mf-cursor-media",
                mediaBoxClassName: "mf-cursor-media-box",
                iconSvgClassName: "mf-svgsprite",
                iconSvgNamePrefix: "-",
                iconSvgSrc: "",
                dataAttr: "cursor",
                hiddenState: "-hidden",
                textState: "-text",
                iconState: "-icon",
                activeState: "-active",
                mediaState: "-media",
                stateDetection: {
                  "-pointer": "a,button",
                },
                visible: !0,
                visibleOnState: !1,
                speed: 0.55,
                ease: "expo.out",
                overwrite: !0,
                skewing: 0,
                skewingText: 2,
                skewingIcon: 2,
                skewingMedia: 2,
                skewingDelta: 0.001,
                skewingDeltaMax: 0.15,
                stickDelta: 0.15,
                showTimeout: 0,
                hideOnLeave: !0,
                hideTimeout: 300,
                hideMediaTimeout: 300,
                initialPos: [-window.innerWidth, -window.innerHeight],
              },
              e
            )),
            this.options.visible &&
              null == e.stateDetection &&
              (this.options.stateDetection["-hidden"] = "iframe"),
            (this.gsap = t.gsap || window.gsap),
            (this.el =
              "string" == typeof this.options.el
                ? document.querySelector(this.options.el)
                : this.options.el),
            (this.container =
              "string" == typeof this.options.container
                ? document.querySelector(this.options.container)
                : this.options.container),
            (this.skewing = this.options.skewing),
            (this.pos = {
              x: this.options.initialPos[0],
              y: this.options.initialPos[1],
            }),
            (this.vel = {
              x: 0,
              y: 0,
            }),
            (this.event = {}),
            (this.events = []),
            this.init();
        }
        t.registerGSAP = function (e) {
          t.gsap = e;
        };
        var e = t.prototype;
        return (
          (e.init = function () {
            this.el || this.create(),
              this.createSetter(),
              this.bind(),
              this.render(!0),
              (this.ticker = this.render.bind(this, !1)),
              this.gsap.ticker.add(this.ticker);
          }),
          (e.create = function () {
            (this.el = document.createElement("div")),
              (this.el.className = this.options.className),
              this.el.classList.add(this.options.hiddenState),
              (this.inner = document.createElement("div")),
              (this.inner.className = this.options.innerClassName),
              (this.text = document.createElement("div")),
              (this.text.className = this.options.textClassName),
              (this.media = document.createElement("div")),
              (this.media.className = this.options.mediaClassName),
              (this.mediaBox = document.createElement("div")),
              (this.mediaBox.className = this.options.mediaBoxClassName),
              this.media.appendChild(this.mediaBox),
              this.inner.appendChild(this.media),
              this.inner.appendChild(this.text),
              this.el.appendChild(this.inner),
              this.container.appendChild(this.el);
          }),
          (e.createSetter = function () {
            this.setter = {
              x: this.gsap.quickSetter(this.el, "x", "px"),
              y: this.gsap.quickSetter(this.el, "y", "px"),
              rotation: this.gsap.quickSetter(this.el, "rotation", "deg"),
              scaleX: this.gsap.quickSetter(this.el, "scaleX"),
              scaleY: this.gsap.quickSetter(this.el, "scaleY"),
              wc: this.gsap.quickSetter(this.el, "willChange"),
              inner: {
                rotation: this.gsap.quickSetter(this.inner, "rotation", "deg"),
              },
            };
          }),
          (e.bind = function () {
            var t = this;
            (this.event.mouseleave = function () {
              return t.hide();
            }),
              (this.event.mouseenter = function () {
                return t.show();
              }),
              (this.event.mousedown = function () {
                return t.addState(t.options.activeState);
              }),
              (this.event.mouseup = function () {
                return t.removeState(t.options.activeState);
              }),
              (this.event.mousemoveOnce = function () {
                return t.show();
              }),
              (this.event.mousemove = function (e) {
                t.gsap.to(t.pos, {
                  x: t.stick
                    ? t.stick.x - (t.stick.x - e.clientX) * t.options.stickDelta
                    : e.clientX,
                  y: t.stick
                    ? t.stick.y - (t.stick.y - e.clientY) * t.options.stickDelta
                    : e.clientY,
                  overwrite: t.options.overwrite,
                  ease: t.options.ease,
                  duration: t.visible ? t.options.speed : 0,
                  onUpdate: function () {
                    return (t.vel = {
                      x: e.clientX - t.pos.x,
                      y: e.clientY - t.pos.y,
                    });
                  },
                });
              }),
              (this.event.mouseover = function (e) {
                for (
                  var n = e.target;
                  n &&
                  n !== t.container &&
                  (!e.relatedTarget || !n.contains(e.relatedTarget));
                  n = n.parentNode
                ) {
                  for (var i in t.options.stateDetection)
                    n.matches(t.options.stateDetection[i]) && t.addState(i);
                  if (t.options.dataAttr) {
                    var r = t.getFromDataset(n);
                    r.state && t.addState(r.state),
                      r.text && t.setText(r.text),
                      r.icon && t.setIcon(r.icon),
                      r.img && t.setImg(r.img),
                      r.video && t.setVideo(r.video),
                      void 0 !== r.show && t.show(),
                      void 0 !== r.stick && t.setStick(r.stick || n);
                  }
                }
              }),
              (this.event.mouseout = function (e) {
                for (
                  var n = e.target;
                  n &&
                  n !== t.container &&
                  (!e.relatedTarget || !n.contains(e.relatedTarget));
                  n = n.parentNode
                ) {
                  for (var i in t.options.stateDetection)
                    n.matches(t.options.stateDetection[i]) && t.removeState(i);
                  if (t.options.dataAttr) {
                    var r = t.getFromDataset(n);
                    r.state && t.removeState(r.state),
                      r.text && t.removeText(),
                      r.icon && t.removeIcon(),
                      r.img && t.removeImg(),
                      r.video && t.removeVideo(),
                      void 0 !== r.show && t.hide(),
                      void 0 !== r.stick && t.removeStick();
                  }
                }
              }),
              this.options.hideOnLeave &&
                this.container.addEventListener(
                  "mouseleave",
                  this.event.mouseleave,
                  {
                    passive: !0,
                  }
                ),
              this.options.visible &&
                this.container.addEventListener(
                  "mouseenter",
                  this.event.mouseenter,
                  {
                    passive: !0,
                  }
                ),
              this.options.activeState &&
                (this.container.addEventListener(
                  "mousedown",
                  this.event.mousedown,
                  {
                    passive: !0,
                  }
                ),
                this.container.addEventListener("mouseup", this.event.mouseup, {
                  passive: !0,
                })),
              this.container.addEventListener(
                "mousemove",
                this.event.mousemove,
                {
                  passive: !0,
                }
              ),
              this.options.visible &&
                this.container.addEventListener(
                  "mousemove",
                  this.event.mousemoveOnce,
                  {
                    passive: !0,
                    once: !0,
                  }
                ),
              (this.options.stateDetection || this.options.dataAttr) &&
                (this.container.addEventListener(
                  "mouseover",
                  this.event.mouseover,
                  {
                    passive: !0,
                  }
                ),
                this.container.addEventListener(
                  "mouseout",
                  this.event.mouseout,
                  {
                    passive: !0,
                  }
                ));
          }),
          (e.render = function (t) {
            if (!0 === t || (0 !== this.vel.y && 0 !== this.vel.x)) {
              if (
                (this.trigger("render"),
                this.setter.wc("transform"),
                this.setter.x(this.pos.x),
                this.setter.y(this.pos.y),
                this.skewing)
              ) {
                var e = Math.sqrt(
                    Math.pow(this.vel.x, 2) + Math.pow(this.vel.y, 2)
                  ),
                  n =
                    Math.min(
                      e * this.options.skewingDelta,
                      this.options.skewingDeltaMax
                    ) * this.skewing,
                  i = (180 * Math.atan2(this.vel.y, this.vel.x)) / Math.PI;
                this.setter.rotation(i),
                  this.setter.scaleX(1 + n),
                  this.setter.scaleY(1 - n),
                  this.setter.inner.rotation(-i);
              }
            } else this.setter.wc("auto");
          }),
          (e.show = function () {
            var t = this;
            this.trigger("show"),
              clearInterval(this.visibleInt),
              (this.visibleInt = setTimeout(function () {
                t.el.classList.remove(t.options.hiddenState),
                  (t.visible = !0),
                  t.render(!0);
              }, this.options.showTimeout));
          }),
          (e.hide = function () {
            var t = this;
            this.trigger("hide"),
              clearInterval(this.visibleInt),
              this.el.classList.add(this.options.hiddenState),
              (this.visibleInt = setTimeout(function () {
                return (t.visible = !1);
              }, this.options.hideTimeout));
          }),
          (e.toggle = function (t) {
            !0 === t || (!1 !== t && !this.visible) ? this.show() : this.hide();
          }),
          (e.addState = function (t) {
            var e;
            if ((this.trigger("addState", t), t === this.options.hiddenState))
              return this.hide();
            (e = this.el.classList).add.apply(e, t.split(" ")),
              this.options.visibleOnState && this.show();
          }),
          (e.removeState = function (t) {
            var e;
            if (
              (this.trigger("removeState", t), t === this.options.hiddenState)
            )
              return this.show();
            (e = this.el.classList).remove.apply(e, t.split(" ")),
              this.options.visibleOnState &&
                this.el.className === this.options.className &&
                this.hide();
          }),
          (e.toggleState = function (t, e) {
            !0 === e || (!1 !== e && !this.el.classList.contains(t))
              ? this.addState(t)
              : this.removeState(t);
          }),
          (e.setSkewing = function (t) {
            this.gsap.to(this, {
              skewing: t,
            });
          }),
          (e.removeSkewing = function () {
            this.gsap.to(this, {
              skewing: this.options.skewing,
            });
          }),
          (e.setStick = function (t) {
            var e = (
              "string" == typeof t ? document.querySelector(t) : t
            ).getBoundingClientRect();
            this.stick = {
              y: e.top + e.height / 2,
              x: e.left + e.width / 2,
            };
          }),
          (e.removeStick = function () {
            this.stick = !1;
          }),
          (e.setText = function (t) {
            (this.text.innerHTML = t),
              this.addState(this.options.textState),
              this.setSkewing(this.options.skewingText);
          }),
          (e.removeText = function () {
            this.removeState(this.options.textState), this.removeSkewing();
          }),
          (e.setIcon = function (t, e) {
            void 0 === e && (e = ""),
              (this.text.innerHTML =
                "<svg class='" +
                this.options.iconSvgClassName +
                " " +
                this.options.iconSvgNamePrefix +
                t +
                "' style='" +
                e +
                "'><use xlink:href='" +
                this.options.iconSvgSrc +
                "#" +
                t +
                "'></use></svg>"),
              this.addState(this.options.iconState),
              this.setSkewing(this.options.skewingIcon);
          }),
          (e.removeIcon = function () {
            this.removeState(this.options.iconState), this.removeSkewing();
          }),
          (e.setMedia = function (t) {
            var e = this;
            clearTimeout(this.mediaInt),
              t &&
                ((this.mediaBox.innerHTML = ""), this.mediaBox.appendChild(t)),
              (this.mediaInt = setTimeout(function () {
                return e.addState(e.options.mediaState);
              }, 20)),
              this.setSkewing(this.options.skewingMedia);
          }),
          (e.removeMedia = function () {
            var t = this;
            clearTimeout(this.mediaInt),
              this.removeState(this.options.mediaState),
              (this.mediaInt = setTimeout(function () {
                return (t.mediaBox.innerHTML = "");
              }, this.options.hideMediaTimeout)),
              this.removeSkewing();
          }),
          (e.setImg = function (t) {
            this.mediaImg || (this.mediaImg = new Image()),
              this.mediaImg.src !== t && (this.mediaImg.src = t),
              this.setMedia(this.mediaImg);
          }),
          (e.removeImg = function () {
            this.removeMedia();
          }),
          (e.setVideo = function (t) {
            this.mediaVideo ||
              ((this.mediaVideo = document.createElement("video")),
              (this.mediaVideo.muted = !0),
              (this.mediaVideo.loop = !0),
              (this.mediaVideo.autoplay = !0)),
              this.mediaVideo.src !== t &&
                ((this.mediaVideo.src = t), this.mediaVideo.load()),
              this.mediaVideo.play(),
              this.setMedia(this.mediaVideo);
          }),
          (e.removeVideo = function () {
            this.mediaVideo &&
              this.mediaVideo.readyState > 2 &&
              this.mediaVideo.pause(),
              this.removeMedia();
          }),
          (e.on = function (t, e) {
            this.events[t] instanceof Array || this.off(t),
              this.events[t].push(e);
          }),
          (e.off = function (t, e) {
            this.events[t] = e
              ? this.events[t].filter(function (t) {
                  return t !== e;
                })
              : [];
          }),
          (e.trigger = function (t) {
            var e = arguments,
              n = this;
            this.events[t] &&
              this.events[t].forEach(function (t) {
                return t.call.apply(t, [n, n].concat([].slice.call(e, 1)));
              });
          }),
          (e.getFromDataset = function (t) {
            var e = t.dataset;
            return {
              state: e[this.options.dataAttr],
              show: e[this.options.dataAttr + "Show"],
              text: e[this.options.dataAttr + "Text"],
              icon: e[this.options.dataAttr + "Icon"],
              img: e[this.options.dataAttr + "Img"],
              video: e[this.options.dataAttr + "Video"],
              stick: e[this.options.dataAttr + "Stick"],
            };
          }),
          (e.destroy = function () {
            this.trigger("destroy"),
              this.gsap.ticker.remove(this.ticker),
              this.container.removeEventListener(
                "mouseleave",
                this.event.mouseleave
              ),
              this.container.removeEventListener(
                "mouseenter",
                this.event.mouseenter
              ),
              this.container.removeEventListener(
                "mousedown",
                this.event.mousedown
              ),
              this.container.removeEventListener("mouseup", this.event.mouseup),
              this.container.removeEventListener(
                "mousemove",
                this.event.mousemove
              ),
              this.container.removeEventListener(
                "mousemove",
                this.event.mousemoveOnce
              ),
              this.container.removeEventListener(
                "mouseover",
                this.event.mouseover
              ),
              this.container.removeEventListener(
                "mouseout",
                this.event.mouseout
              ),
              this.el &&
                (this.container.removeChild(this.el),
                (this.el = null),
                (this.mediaImg = null),
                (this.mediaVideo = null));
          }),
          t
        );
      })();
    /*!
     * Cuberto Mouse Follower
     * https://cuberto.com/
     *
     * @version 1.1.2
     * @author Cuberto, Artem Dordzhiev (Draft)
     */
    function vl(t, e) {
      return (vl = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    gl.registerGSAP(Yi);
    var _l = (function (t) {
      var e, n;
      function i() {
        var e;
        return (e = t.apply(this, arguments) || this).initFollower(), e;
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        vl(e, n);
      var r = i.prototype;
      return (
        (r.onLeave = function () {
          try {
            return this.follower
              ? (this.follower.removeIcon(),
                this.follower.removeText(),
                this.follower.removeImg(),
                this.follower.removeVideo(),
                this.follower.removeState("-pointer"),
                this.follower.removeState("-inverse"),
                this.follower.removeState("-opaque"),
                Promise.resolve())
              : Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.initFollower = function () {
          window.matchMedia("(pointer:fine)").matches &&
            (this.follower = new gl({
              className: "cb-cursor",
              innerClassName: "cb-cursor-inner",
              textClassName: "cb-cursor-text",
              mediaClassName: "cb-cursor-media",
              mediaBoxClassName: "cb-cursor-media-box",
              iconSvgClassName: "cb-svgsprite",
              iconSvgSrc: "/assets/sprites/svgsprites.svg",
              skewing: 1.5,
              skewingMedia: 0.5,
            }));
        }),
        i
      );
    })(l);
    function yl(t, e) {
      return (yl = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var xl = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).showTl = e.tlShow()),
          (e.hideTl = e.tlHide()),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        yl(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return Promise.resolve(
              new Promise(function (t) {
                return setTimeout(t, 300);
              })
            ).then(function () {});
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onEnter = function () {
          try {
            var t = this;
            return Promise.resolve(
              new Promise(function (t) {
                return setTimeout(t, 100);
              })
            ).then(function () {
              return Promise.resolve(t.hide()).then(function () {});
            });
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onRefresh = function () {
          return Promise.resolve();
        }),
        (r.onLeave = function () {
          try {
            return Promise.resolve(this.show()).then(function () {});
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.show = function () {
          try {
            return (
              document.documentElement.classList.add("loader"),
              Promise.resolve(this.showTl.play(0)).then(function () {})
            );
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.hide = function () {
          try {
            return (
              document.documentElement.classList.remove("loader"),
              Promise.resolve(this.hideTl.play(0)).then(function () {})
            );
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.tlShow = function () {
          var t = new Yi.timeline({
            paused: !0,
          });
          return (
            t.set(this.el, {
              opacity: 1,
              transformOrigin: "bottom center",
              display: "block",
              pointerEvents: "auto",
              willChange: "transform",
              immediateRender: !1,
            }),
            t.fromTo(
              this.el,
              {
                scaleY: 0,
              },
              {
                scaleY: 1,
                duration: 0.6,
                ease: "power4.inOut",
                immediateRender: !1,
              }
            ),
            t
          );
        }),
        (r.tlHide = function () {
          var t = new Yi.timeline({
            paused: !0,
          });
          return (
            t.set(this.el, {
              scaleY: 1,
              pointerEvents: "none",
              willChange: "transform",
            }),
            t.to(this.el, {
              opacity: 0,
              duration: 0.7,
              display: "none",
            }),
            t.set(this.el, {
              willChange: "auto",
            }),
            t
          );
        }),
        i
      );
    })(l);
    var bl = function (t) {
        var e = typeof t;
        return null != t && ("object" == e || "function" == e);
      },
      Sl = n(90),
      El = "object" == typeof self && self && self.Object === Object && self,
      Ml = Sl.a || El || Function("return this")(),
      Tl = function () {
        return Ml.Date.now();
      },
      wl = /\s/;
    var Dl = function (t) {
        for (var e = t.length; e-- && wl.test(t.charAt(e)); );
        return e;
      },
      Al = /^\s+/;
    var Cl = function (t) {
        return t ? t.slice(0, Dl(t) + 1).replace(Al, "") : t;
      },
      Pl = Ml.Symbol,
      Rl = Object.prototype,
      Ll = Rl.hasOwnProperty,
      Ol = Rl.toString,
      Il = Pl ? Pl.toStringTag : void 0;
    var Fl = function (t) {
        var e = Ll.call(t, Il),
          n = t[Il];
        try {
          t[Il] = void 0;
          var i = !0;
        } catch (t) {}
        var r = Ol.call(t);
        return i && (e ? (t[Il] = n) : delete t[Il]), r;
      },
      Ul = Object.prototype.toString;
    var Nl = function (t) {
        return Ul.call(t);
      },
      kl = Pl ? Pl.toStringTag : void 0;
    var zl = function (t) {
      return null == t
        ? void 0 === t
          ? "[object Undefined]"
          : "[object Null]"
        : kl && kl in Object(t)
        ? Fl(t)
        : Nl(t);
    };
    var Bl = function (t) {
      return null != t && "object" == typeof t;
    };
    var Hl = function (t) {
        return "symbol" == typeof t || (Bl(t) && "[object Symbol]" == zl(t));
      },
      Vl = /^[-+]0x[0-9a-f]+$/i,
      Gl = /^0b[01]+$/i,
      Wl = /^0o[0-7]+$/i,
      jl = parseInt;
    var Xl = function (t) {
        if ("number" == typeof t) return t;
        if (Hl(t)) return NaN;
        if (bl(t)) {
          var e = "function" == typeof t.valueOf ? t.valueOf() : t;
          t = bl(e) ? e + "" : e;
        }
        if ("string" != typeof t) return 0 === t ? t : +t;
        t = Cl(t);
        var n = Gl.test(t);
        return n || Wl.test(t)
          ? jl(t.slice(2), n ? 2 : 8)
          : Vl.test(t)
          ? NaN
          : +t;
      },
      ql = Math.max,
      Yl = Math.min;
    var Kl = function (t, e, n) {
      var i,
        r,
        s,
        o,
        a,
        l,
        c = 0,
        u = !1,
        h = !1,
        d = !0;
      if ("function" != typeof t) throw new TypeError("Expected a function");
      function p(e) {
        var n = i,
          s = r;
        return (i = r = void 0), (c = e), (o = t.apply(s, n));
      }
      function f(t) {
        return (c = t), (a = setTimeout(g, e)), u ? p(t) : o;
      }
      function m(t) {
        var n = t - l;
        return void 0 === l || n >= e || n < 0 || (h && t - c >= s);
      }
      function g() {
        var t = Tl();
        if (m(t)) return v(t);
        a = setTimeout(
          g,
          (function (t) {
            var n = e - (t - l);
            return h ? Yl(n, s - (t - c)) : n;
          })(t)
        );
      }
      function v(t) {
        return (a = void 0), d && i ? p(t) : ((i = r = void 0), o);
      }
      function _() {
        var t = Tl(),
          n = m(t);
        if (((i = arguments), (r = this), (l = t), n)) {
          if (void 0 === a) return f(l);
          if (h) return clearTimeout(a), (a = setTimeout(g, e)), p(l);
        }
        return void 0 === a && (a = setTimeout(g, e)), o;
      }
      return (
        (e = Xl(e) || 0),
        bl(n) &&
          ((u = !!n.leading),
          (s = (h = "maxWait" in n) ? ql(Xl(n.maxWait) || 0, e) : s),
          (d = "trailing" in n ? !!n.trailing : d)),
        (_.cancel = function () {
          void 0 !== a && clearTimeout(a), (c = 0), (i = l = r = a = void 0);
        }),
        (_.flush = function () {
          return void 0 === a ? o : v(Tl());
        }),
        _
      );
    };
    function Zl(t, e) {
      return (Zl = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Jl = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          (e = t.apply(this, arguments) || this).injectSvg(),
          e.bindMouseMove(),
          e.bindResizeObserver(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        Zl(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            var t = this;
            return Promise.resolve(t.app.wait("loader")).then(function () {
              t.magicShow();
            });
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.magicShow = function () {
          No.create({
            trigger: this.el,
            animation: this.tlShow(),
          });
        }),
        (r.tlShow = function () {
          var t = new Yi.timeline();
          return (
            t.set(this.svg, {
              transformOrigin: "left center",
            }),
            t.from(this.svg, {
              scaleX: 0,
              duration: 3,
              ease: "expo.out",
            }),
            t
          );
        }),
        (r.getPathD = function (t, e, n) {
          return (
            t || (t = this.el.offsetWidth / 2),
            e || (e = 100),
            void 0 === n && (n = this.el.offsetWidth),
            "M0,100 Q" + t + "," + e + " " + n + ",100"
          );
        }),
        (r.injectSvg = function () {
          (this.el.innerHTML =
            "<svg><path d='" + this.getPathD() + "'/></svg>"),
            (this.svg = this.el.querySelector("svg")),
            (this.path = this.el.querySelector("path"));
        }),
        (r.update = function () {
          Yi.killTweensOf(this.path),
            this.path.setAttribute("d", this.getPathD());
        }),
        (r.bindMouseMove = function () {
          var t = this;
          if (!No.isTouch) {
            var e = 0;
            this.el.addEventListener("mousemove", function (n) {
              var i = t.svg.getBoundingClientRect(),
                r = n.pageX - i.left,
                s = n.pageY - i.top;
              e || (e = s < 100 ? 50 : -50);
              var o = r,
                a = 2 * s - 100 + e;
              Yi.to(t.path, {
                attr: {
                  d: t.getPathD(o, a),
                },
                duration: 0.2,
                overwrite: !0,
              });
            }),
              this.el.addEventListener("mouseleave", function () {
                (e = 0),
                  Yi.to(t.path, {
                    attr: {
                      d: t.getPathD(),
                    },
                    duration: 2,
                    ease: "elastic.out(1, 0.2)",
                  });
              });
          }
        }),
        (r.bindResizeObserver = function () {
          var t = this;
          (this.updateDebounced = Kl(this.update.bind(this), 30)),
            (this.resizeObserver = new ResizeObserver(function () {
              return t.updateDebounced();
            })),
            this.resizeObserver.observe(this.el);
        }),
        i
      );
    })(l);
    function $l(t, e) {
      return ($l = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Ql = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).layout =
              e.app.get("layout")),
            e
          );
        }
        (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          $l(e, n);
        var r = i.prototype;
        return (
          (r.bindModalOpen = function () {
            var t = this;
            this.el.dataset.modalOpen &&
              this.el.addEventListener("click", function (e) {
                var n = t.app.find(t.el.dataset.modalOpen, "modal");
                n && (e.preventDefault(), e.stopPropagation(), n.open());
              });
          }),
          (r.bindScrollTo = function () {
            var t = this;
            this.el.dataset.scrollTo ||
              this.el.addEventListener("click", function (e) {
                e.preventDefault(),
                  e.stopPropagation(),
                  t.layout.scrollToTarget(t.el.dataset.scrollTo);
              });
          }),
          i
        );
      })(l),
      tc =
        /([\uD800-\uDBFF][\uDC00-\uDFFF](?:[\u200D\uFE0F][\uD800-\uDBFF][\uDC00-\uDFFF]){2,}|\uD83D\uDC69(?:\u200D(?:(?:\uD83D\uDC69\u200D)?\uD83D\uDC67|(?:\uD83D\uDC69\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D(?:\uD83D\uDC69\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]\uFE0F|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC6F\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3C-\uDD3E\uDDD6-\uDDDF])\u200D[\u2640\u2642]\uFE0F|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F\u200D[\u2640\u2642]|(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642])\uFE0F|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\uD83D\uDC69\u200D[\u2695\u2696\u2708]|\uD83D\uDC68(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708]))\uFE0F|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83D\uDC69\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|\uD83D\uDC68(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66\u200D\uD83D\uDC66|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92])|(?:\uD83C[\uDFFB-\uDFFF])\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]))|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDD1-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\u200D(?:(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC67|(?:(?:\uD83D[\uDC68\uDC69])\u200D)?\uD83D\uDC66)|\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC69\uDC6E\uDC70-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD18-\uDD1C\uDD1E\uDD1F\uDD26\uDD30-\uDD39\uDD3D\uDD3E\uDDD1-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])?|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDEEB\uDEEC\uDEF4-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267B\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEF8]|\uD83E[\uDD10-\uDD3A\uDD3C-\uDD3E\uDD40-\uDD45\uDD47-\uDD4C\uDD50-\uDD6B\uDD80-\uDD97\uDDC0\uDDD0-\uDDE6])\uFE0F)/;
    /*!
     * strings: 3.11.1
     * https://greensock.com
     *
     * Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    /*!
     * SplitText: 3.11.1
     * https://greensock.com
     *
     * @license Copyright 2008-2022, GreenSock. All rights reserved.
     * Subject to the terms at https://greensock.com/standard-license or for
     * Club GreenSock members, the agreement issued with that membership.
     * @author: Jack Doyle, jack@greensock.com
     */
    var ec,
      nc,
      ic,
      rc = /(?:\r|\n|\t\t)/g,
      sc = /(?:\s\s+)/g,
      oc = function (t) {
        return nc.getComputedStyle(t);
      },
      ac = Array.isArray,
      lc = [].slice,
      cc = function (t, e) {
        var n;
        return ac(t)
          ? t
          : "string" == (n = typeof t) && !e && t
          ? lc.call(ec.querySelectorAll(t), 0)
          : t && "object" === n && "length" in t
          ? lc.call(t, 0)
          : t
          ? [t]
          : [];
      },
      uc = function (t) {
        return "absolute" === t.position || !0 === t.absolute;
      },
      hc = function (t, e) {
        for (var n, i = e.length; --i > -1; )
          if (((n = e[i]), t.substr(0, n.length) === n)) return n.length;
      },
      dc = function (t, e) {
        void 0 === t && (t = "");
        var n = ~t.indexOf("++"),
          i = 1;
        return (
          n && (t = t.split("++").join("")),
          function () {
            return (
              "<" +
              e +
              " style='position:relative;display:inline-block;'" +
              (t ? " class='" + t + (n ? i++ : "") + "'>" : ">")
            );
          }
        );
      },
      pc = function t(e, n, i) {
        var r = e.nodeType;
        if (1 === r || 9 === r || 11 === r)
          for (e = e.firstChild; e; e = e.nextSibling) t(e, n, i);
        else
          (3 !== r && 4 !== r) || (e.nodeValue = e.nodeValue.split(n).join(i));
      },
      fc = function (t, e) {
        for (var n = e.length; --n > -1; ) t.push(e[n]);
      },
      mc = function (t, e, n) {
        for (var i; t && t !== e; ) {
          if ((i = t._next || t.nextSibling))
            return i.textContent.charAt(0) === n;
          t = t.parentNode || t._parent;
        }
      },
      gc = function t(e) {
        var n,
          i,
          r = cc(e.childNodes),
          s = r.length;
        for (n = 0; n < s; n++)
          (i = r[n])._isSplit
            ? t(i)
            : n && i.previousSibling && 3 === i.previousSibling.nodeType
            ? ((i.previousSibling.nodeValue +=
                3 === i.nodeType ? i.nodeValue : i.firstChild.nodeValue),
              e.removeChild(i))
            : 3 !== i.nodeType &&
              (e.insertBefore(i.firstChild, i), e.removeChild(i));
      },
      vc = function (t, e) {
        return parseFloat(e[t]) || 0;
      },
      _c = function (t, e, n, i, r, s, o) {
        var a,
          l,
          c,
          u,
          h,
          d,
          p,
          f,
          m,
          g,
          v,
          _,
          y = oc(t),
          x = vc("paddingLeft", y),
          b = -999,
          S = vc("borderBottomWidth", y) + vc("borderTopWidth", y),
          E = vc("borderLeftWidth", y) + vc("borderRightWidth", y),
          M = vc("paddingTop", y) + vc("paddingBottom", y),
          T = vc("paddingLeft", y) + vc("paddingRight", y),
          w = vc("fontSize", y) * (e.lineThreshold || 0.2),
          D = y.textAlign,
          A = [],
          C = [],
          P = [],
          R = e.wordDelimiter || " ",
          L = e.tag ? e.tag : e.span ? "span" : "div",
          O = e.type || e.split || "chars,words,lines",
          I = r && ~O.indexOf("lines") ? [] : null,
          F = ~O.indexOf("words"),
          U = ~O.indexOf("chars"),
          N = uc(e),
          k = e.linesClass,
          z = ~(k || "").indexOf("++"),
          B = [],
          H = "flex" === y.display,
          V = t.style.display;
        for (
          z && (k = k.split("++").join("")),
            H && (t.style.display = "block"),
            c = (l = t.getElementsByTagName("*")).length,
            h = [],
            a = 0;
          a < c;
          a++
        )
          h[a] = l[a];
        if (I || N)
          for (a = 0; a < c; a++)
            ((d = (u = h[a]).parentNode === t) || N || (U && !F)) &&
              ((_ = u.offsetTop),
              I &&
                d &&
                Math.abs(_ - b) > w &&
                ("BR" !== u.nodeName || 0 === a) &&
                ((p = []), I.push(p), (b = _)),
              N &&
                ((u._x = u.offsetLeft),
                (u._y = _),
                (u._w = u.offsetWidth),
                (u._h = u.offsetHeight)),
              I &&
                (((u._isSplit && d) ||
                  (!U && d) ||
                  (F && d) ||
                  (!F &&
                    u.parentNode.parentNode === t &&
                    !u.parentNode._isSplit)) &&
                  (p.push(u), (u._x -= x), mc(u, t, R) && (u._wordEnd = !0)),
                "BR" === u.nodeName &&
                  ((u.nextSibling && "BR" === u.nextSibling.nodeName) ||
                    0 === a) &&
                  I.push([])));
        for (a = 0; a < c; a++)
          if (((d = (u = h[a]).parentNode === t), "BR" !== u.nodeName))
            if (
              (N &&
                ((m = u.style),
                F ||
                  d ||
                  ((u._x += u.parentNode._x), (u._y += u.parentNode._y)),
                (m.left = u._x + "px"),
                (m.top = u._y + "px"),
                (m.position = "absolute"),
                (m.display = "block"),
                (m.width = u._w + 1 + "px"),
                (m.height = u._h + "px")),
              !F && U)
            )
              if (u._isSplit)
                for (
                  u._next = l = u.nextSibling, u.parentNode.appendChild(u);
                  l && 3 === l.nodeType && " " === l.textContent;

                )
                  (u._next = l.nextSibling),
                    u.parentNode.appendChild(l),
                    (l = l.nextSibling);
              else
                u.parentNode._isSplit
                  ? ((u._parent = u.parentNode),
                    !u.previousSibling &&
                      u.firstChild &&
                      (u.firstChild._isFirst = !0),
                    u.nextSibling &&
                      " " === u.nextSibling.textContent &&
                      !u.nextSibling.nextSibling &&
                      B.push(u.nextSibling),
                    (u._next =
                      u.nextSibling && u.nextSibling._isFirst
                        ? null
                        : u.nextSibling),
                    u.parentNode.removeChild(u),
                    h.splice(a--, 1),
                    c--)
                  : d ||
                    ((_ = !u.nextSibling && mc(u.parentNode, t, R)),
                    u.parentNode._parent && u.parentNode._parent.appendChild(u),
                    _ && u.parentNode.appendChild(ec.createTextNode(" ")),
                    "span" === L && (u.style.display = "inline"),
                    A.push(u));
            else
              u.parentNode._isSplit && !u._isSplit && "" !== u.innerHTML
                ? C.push(u)
                : U &&
                  !u._isSplit &&
                  ("span" === L && (u.style.display = "inline"), A.push(u));
          else
            I || N
              ? (u.parentNode && u.parentNode.removeChild(u),
                h.splice(a--, 1),
                c--)
              : F || t.appendChild(u);
        for (a = B.length; --a > -1; ) B[a].parentNode.removeChild(B[a]);
        if (I) {
          for (
            N &&
              ((g = ec.createElement(L)),
              t.appendChild(g),
              (v = g.offsetWidth + "px"),
              (_ = g.offsetParent === t ? 0 : t.offsetLeft),
              t.removeChild(g)),
              m = t.style.cssText,
              t.style.cssText = "display:none;";
            t.firstChild;

          )
            t.removeChild(t.firstChild);
          for (f = " " === R && (!N || (!F && !U)), a = 0; a < I.length; a++) {
            for (
              p = I[a],
                (g = ec.createElement(L)).style.cssText =
                  "display:block;text-align:" +
                  D +
                  ";position:" +
                  (N ? "absolute;" : "relative;"),
                k && (g.className = k + (z ? a + 1 : "")),
                P.push(g),
                c = p.length,
                l = 0;
              l < c;
              l++
            )
              "BR" !== p[l].nodeName &&
                ((u = p[l]),
                g.appendChild(u),
                f && u._wordEnd && g.appendChild(ec.createTextNode(" ")),
                N &&
                  (0 === l &&
                    ((g.style.top = u._y + "px"),
                    (g.style.left = x + _ + "px")),
                  (u.style.top = "0px"),
                  _ && (u.style.left = u._x - _ + "px")));
            0 === c
              ? (g.innerHTML = "&nbsp;")
              : F || U || (gc(g), pc(g, String.fromCharCode(160), " ")),
              N && ((g.style.width = v), (g.style.height = u._h + "px")),
              t.appendChild(g);
          }
          t.style.cssText = m;
        }
        N &&
          (o > t.clientHeight &&
            ((t.style.height = o - M + "px"),
            t.clientHeight < o && (t.style.height = o + S + "px")),
          s > t.clientWidth &&
            ((t.style.width = s - T + "px"),
            t.clientWidth < s && (t.style.width = s + E + "px"))),
          H && (V ? (t.style.display = V) : t.style.removeProperty("display")),
          fc(n, A),
          F && fc(i, C),
          fc(r, P);
      },
      yc = function (t, e, n, i) {
        var r,
          s,
          o,
          a,
          l,
          c,
          u,
          h,
          d = e.tag ? e.tag : e.span ? "span" : "div",
          p = ~(e.type || e.split || "chars,words,lines").indexOf("chars"),
          f = uc(e),
          m = e.wordDelimiter || " ",
          g = " " !== m ? "" : f ? "&#173; " : " ",
          v = "</" + d + ">",
          _ = 1,
          y = e.specialChars
            ? "function" == typeof e.specialChars
              ? e.specialChars
              : hc
            : null,
          x = ec.createElement("div"),
          b = t.parentNode;
        for (
          b.insertBefore(x, t),
            x.textContent = t.nodeValue,
            b.removeChild(t),
            u =
              -1 !==
              (r = (function t(e) {
                var n = e.nodeType,
                  i = "";
                if (1 === n || 9 === n || 11 === n) {
                  if ("string" == typeof e.textContent) return e.textContent;
                  for (e = e.firstChild; e; e = e.nextSibling) i += t(e);
                } else if (3 === n || 4 === n) return e.nodeValue;
                return i;
              })((t = x))).indexOf("<"),
            !1 !== e.reduceWhiteSpace &&
              (r = r.replace(sc, " ").replace(rc, "")),
            u && (r = r.split("<").join("{{LT}}")),
            l = r.length,
            s = (" " === r.charAt(0) ? g : "") + n(),
            o = 0;
          o < l;
          o++
        )
          if (((c = r.charAt(o)), y && (h = y(r.substr(o), e.specialChars))))
            (c = r.substr(o, h || 1)),
              (s += p && " " !== c ? i() + c + "</" + d + ">" : c),
              (o += h - 1);
          else if (c === m && r.charAt(o - 1) !== m && o) {
            for (s += _ ? v : "", _ = 0; r.charAt(o + 1) === m; ) (s += g), o++;
            o === l - 1
              ? (s += g)
              : ")" !== r.charAt(o + 1) && ((s += g + n()), (_ = 1));
          } else
            "{" === c && "{{LT}}" === r.substr(o, 6)
              ? ((s += p ? i() + "{{LT}}</" + d + ">" : "{{LT}}"), (o += 5))
              : (c.charCodeAt(0) >= 55296 && c.charCodeAt(0) <= 56319) ||
                (r.charCodeAt(o + 1) >= 65024 && r.charCodeAt(o + 1) <= 65039)
              ? ((a = ((r.substr(o, 12).split(tc) || [])[1] || "").length || 2),
                (s +=
                  p && " " !== c
                    ? i() + r.substr(o, a) + "</" + d + ">"
                    : r.substr(o, a)),
                (o += a - 1))
              : (s += p && " " !== c ? i() + c + "</" + d + ">" : c);
        (t.outerHTML = s + (_ ? v : "")), u && pc(b, "{{LT}}", "<");
      },
      xc = function t(e, n, i, r) {
        var s,
          o,
          a = cc(e.childNodes),
          l = a.length,
          c = uc(n);
        if (3 !== e.nodeType || l > 1) {
          for (n.absolute = !1, s = 0; s < l; s++)
            ((o = a[s])._next = o._isFirst = o._parent = o._wordEnd = null),
              (3 !== o.nodeType || /\S+/.test(o.nodeValue)) &&
                (c &&
                  3 !== o.nodeType &&
                  "inline" === oc(o).display &&
                  ((o.style.display = "inline-block"),
                  (o.style.position = "relative")),
                (o._isSplit = !0),
                t(o, n, i, r));
          return (n.absolute = c), void (e._isSplit = !0);
        }
        yc(e, n, i, r);
      },
      bc = (function () {
        function t(t, e) {
          ic || ((ec = document), (nc = window), (ic = 1)),
            (this.elements = cc(t)),
            (this.chars = []),
            (this.words = []),
            (this.lines = []),
            (this._originals = []),
            (this.vars = e || {}),
            this.split(e);
        }
        var e = t.prototype;
        return (
          (e.split = function (t) {
            this.isSplit && this.revert(),
              (this.vars = t = t || this.vars),
              (this._originals.length =
                this.chars.length =
                this.words.length =
                this.lines.length =
                  0);
            for (
              var e,
                n,
                i,
                r = this.elements.length,
                s = t.tag ? t.tag : t.span ? "span" : "div",
                o = dc(t.wordsClass, s),
                a = dc(t.charsClass, s);
              --r > -1;

            )
              (i = this.elements[r]),
                (this._originals[r] = i.innerHTML),
                (e = i.clientHeight),
                (n = i.clientWidth),
                xc(i, t, o, a),
                _c(i, t, this.chars, this.words, this.lines, n, e);
            return (
              this.chars.reverse(),
              this.words.reverse(),
              this.lines.reverse(),
              (this.isSplit = !0),
              this
            );
          }),
          (e.revert = function () {
            var t = this._originals;
            if (!t) throw "revert() call wasn't scoped properly.";
            return (
              this.elements.forEach(function (e, n) {
                return (e.innerHTML = t[n]);
              }),
              (this.chars = []),
              (this.words = []),
              (this.lines = []),
              (this.isSplit = !1),
              this
            );
          }),
          (t.create = function (e, n) {
            return new t(e, n);
          }),
          t
        );
      })();
    function Sc() {
      return (Sc = Object.assign
        ? Object.assign.bind()
        : function (t) {
            for (var e = 1; e < arguments.length; e++) {
              var n = arguments[e];
              for (var i in n)
                Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
            }
            return t;
          }).apply(this, arguments);
    }
    bc.version = "3.11.1";
    var Ec = function (t, e) {
        var n,
          i = Sc(
            {
              box: t,
              xDelta: 0.1,
              yDelta: 0.1,
              moveSpeed: 0.3,
              leaveSpeed: 0.3,
              moveEase: "power1.out",
              leaveEase: "power1.out",
              overwrite: !0,
            },
            e
          ),
          r = function (e, n, r) {
            Yi.to(
              t,
              Sc(
                {
                  x: e,
                  y: n,
                  overwrite: i.overwrite,
                  onStart: function () {
                    return Yi.set(t, {
                      willChange: "transform",
                    });
                  },
                  onComplete: function () {
                    return Yi.set(t, {
                      willChange: "auto",
                    });
                  },
                },
                r
              )
            );
          };
        i.box.addEventListener("mouseenter", function () {
          n = t.getBoundingClientRect();
        }),
          i.box.addEventListener("mousemove", function (t) {
            var e = (t.clientY - n.top - n.height / 2) * i.yDelta,
              s = (t.clientX - n.left - n.width / 2) * i.xDelta;
            r(s, e, {
              duration: i.moveSpeed,
              ease: i.moveEase,
            });
          }),
          i.box.addEventListener("mouseleave", function () {
            r(0, 0, {
              duration: i.leaveSpeed,
              ease: i.leaveEase,
            });
          });
      },
      Mc = function (t, e) {
        void 0 === e && (e = {});
        var n = Sc(
            {
              type: "words",
              duration: 1.7,
              stagger: {
                amount: 0.6,
              },
              ease: "expo.out",
            },
            e
          ),
          i = new Yi.timeline(),
          r = t.querySelectorAll(".cb-coin, img, video"),
          s = new bc(t, {
            type: n.type,
          }),
          o = new bc(s[n.type], {
            type: n.type,
          });
        return (
          Yi.set(s[n.type], {
            overflow: "hidden",
            verticalAlign: "top",
            padding: "0.15em",
            margin: "-0.15em",
          }),
          Yi.set(o[n.type], {
            y: "120%",
          }),
          i.set(
            o[n.type],
            {
              willChange: "transform",
            },
            0
          ),
          i.fromTo(
            o[n.type],
            {
              y: "120%",
            },
            {
              y: "0%",
              duration: n.duration,
              stagger: n.stagger,
              ease: n.ease,
            },
            0
          ),
          r.length &&
            (Yi.set(r, {
              scale: 0,
            }),
            i.fromTo(
              r,
              {
                scale: 0,
              },
              {
                scale: 1,
                duration: n.duration,
                stagger: n.stagger,
                ease: n.ease,
              },
              0.2
            )),
          i.set(o[n.type], {
            willChange: "auto",
          }),
          i
        );
      },
      Tc = function (t, e) {
        return (
          void 0 === e && (e = {}),
          No.create({
            trigger: t,
            animation: Mc(t, e),
            once: !0,
          })
        );
      },
      wc = function (t, e) {
        void 0 === e && (e = {});
        var n = Sc(
          {
            from: 0,
            fromOpacity: 1,
            to: 1,
            toOpacity: 1,
            duration: 2,
            stagger: 0.1,
            ease: "expo.out",
          },
          e
        );
        return (
          Yi.set(t, {
            scale: n.from,
            opacity: n.fromOpacity,
          }),
          Yi.fromTo(
            t,
            {
              scale: n.from,
              opacity: n.fromOpacity,
            },
            {
              scale: n.to,
              opacity: n.toOpacity,
              duration: n.duration,
              stagger: n.stagger,
              ease: n.ease,
            }
          )
        );
      },
      Dc = function (t, e) {
        return (
          void 0 === e && (e = {}),
          No.create({
            trigger: t,
            animation: wc(t, e),
            once: !0,
          })
        );
      },
      Ac = function (t, e) {
        void 0 === e && (e = {});
        var n = Sc(
            {
              fromY: 70,
              toY: 0,
              fromX: 0,
              toX: 0,
              duration: 2,
              opacityDuration: 1,
              stagger: 0.1,
              ease: "expo.out",
            },
            e
          ),
          i = new Yi.timeline();
        return (
          Yi.set(t, {
            opacity: 0,
            y: n.fromY,
          }),
          i.set(t, {
            willChange: "transform",
          }),
          i.fromTo(
            t,
            {
              opacity: 0,
            },
            {
              opacity: 1,
              duration: n.opacityDuration,
              stagger: n.stagger,
            },
            0
          ),
          i.fromTo(
            t,
            {
              y: n.fromY,
              x: n.fromX,
            },
            {
              y: n.toY,
              x: n.toX,
              duration: n.duration,
              stagger: n.stagger,
              ease: n.ease,
            },
            0
          ),
          i.set(t, {
            willChange: "auto",
          }),
          i
        );
      },
      Cc = function (t, e) {
        return (
          void 0 === e && (e = {}),
          No.create({
            trigger: t,
            animation: Ac(t, e),
            once: !0,
          })
        );
      },
      Pc = function (t, e, n) {
        return (
          void 0 === e && (e = {}),
          void 0 === n && (n = {}),
          Yi.set(t, {
            opacity: 0,
          }),
          No.batch(
            t,
            Sc(
              {
                onEnter: function (t) {
                  return Ac(t, e);
                },
                once: !0,
              },
              n
            )
          )
        );
      },
      Rc = function (t, e) {
        void 0 === e && (e = {});
        var n = Sc(
            {
              from: 0,
              to: 1,
              duration: 2,
              stagger: 0.1,
              ease: "expo.out",
            },
            e
          ),
          i = new Yi.timeline();
        return (
          Yi.set(t, {
            opacity: 0,
          }),
          i.fromTo(
            t,
            {
              opacity: n.from,
            },
            {
              opacity: n.to,
              duration: n.duration,
              stagger: n.stagger,
            },
            0
          ),
          i
        );
      },
      Lc = function (t, e) {
        return (
          void 0 === e && (e = {}),
          No.create({
            trigger: t,
            animation: Rc(t, e),
            once: !0,
          })
        );
      },
      Oc = function (t, e) {
        void 0 === e && (e = {});
        Sc(
          {
            from: 0,
            to: 1,
            duration: 2,
            stagger: 0.1,
            ease: "expo.out",
          },
          e
        );
        var n = new Yi.timeline(),
          i = t.querySelector(".cb-btn_cta-border"),
          r = t.querySelector(".cb-btn_cta-title");
        return (
          Yi.set(t, {
            pointerEvents: "none",
          }),
          n.set([i, r], {
            willChange: "transform",
          }),
          n.fromTo(
            i,
            {
              scaleY: 0.5,
              scaleX: 0,
            },
            {
              scaleY: 1,
              scaleX: 1,
              duration: 1.5,
              ease: "expo.out",
            },
            0
          ),
          n.fromTo(
            r,
            {
              scaleY: 0.5,
              scaleX: 0.5,
            },
            {
              scaleY: 1,
              scaleX: 1,
              duration: 1.5,
              ease: "expo.out",
            },
            0
          ),
          n.from(
            r,
            {
              y: "110%",
              duration: 1.2,
              ease: "expo.out",
            },
            0.1
          ),
          n.fromTo(
            i,
            {
              opacity: 0,
            },
            {
              opacity: 1,
              duration: 0.4,
            },
            0.2
          ),
          n.set(
            t,
            {
              pointerEvents: "auto",
            },
            0.6
          ),
          n.set([i, r], {
            willChange: "auto",
          }),
          n
        );
      },
      Ic = function (t, e) {
        return (
          void 0 === e && (e = {}),
          No.create({
            trigger: t,
            animation: Oc(t, e),
            once: !0,
          })
        );
      };
    function Fc(t, e) {
      return (Fc = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Uc,
      Nc,
      kc = (function (t) {
        var e, n;
        function i() {
          var e;
          return (
            ((e = t.apply(this, arguments) || this).cursor =
              e.app.get("cursor")),
            (e.ripple = e.el.querySelector(".cb-checkbox_cta-ripple")),
            e.bindHover(),
            e
          );
        }
        return (
          (n = t),
          ((e = i).prototype = Object.create(n.prototype)),
          (e.prototype.constructor = e),
          Fc(e, n),
          (i.prototype.bindHover = function () {
            var t = this;
            this.cursor.follower &&
              (this.el.addEventListener("mouseenter", function () {
                t.cursor.follower.addState("-opaque");
              }),
              this.el.addEventListener("mouseleave", function () {
                t.cursor.follower.removeState("-opaque");
              }),
              Ec(this.el, {
                xDelta: 0.2,
                yDelta: 0.2,
                leaveSpeed: 2,
                leaveEase: "elastic.out(1,0.4)",
              }));
          }),
          i
        );
      })(l),
      zc =
        "function" == typeof Map
          ? new Map()
          : ((Uc = []),
            (Nc = []),
            {
              has: function (t) {
                return Uc.indexOf(t) > -1;
              },
              get: function (t) {
                return Nc[Uc.indexOf(t)];
              },
              set: function (t, e) {
                -1 === Uc.indexOf(t) && (Uc.push(t), Nc.push(e));
              },
              delete: function (t) {
                var e = Uc.indexOf(t);
                e > -1 && (Uc.splice(e, 1), Nc.splice(e, 1));
              },
            }),
      Bc = function (t) {
        return new Event(t, {
          bubbles: !0,
        });
      };
    try {
      new Event("test");
    } catch (t) {
      Bc = function (t) {
        var e = document.createEvent("Event");
        return e.initEvent(t, !0, !1), e;
      };
    }
    function Hc(t) {
      var e = zc.get(t);
      e && e.destroy();
    }
    function Vc(t) {
      var e = zc.get(t);
      e && e.update();
    }
    var Gc = null;
    "undefined" == typeof window || "function" != typeof window.getComputedStyle
      ? (((Gc = function (t) {
          return t;
        }).destroy = function (t) {
          return t;
        }),
        (Gc.update = function (t) {
          return t;
        }))
      : (((Gc = function (t, e) {
          return (
            t &&
              Array.prototype.forEach.call(t.length ? t : [t], function (t) {
                return (function (t) {
                  if (
                    t &&
                    t.nodeName &&
                    "TEXTAREA" === t.nodeName &&
                    !zc.has(t)
                  ) {
                    var e,
                      n = null,
                      i = null,
                      r = null,
                      s = function () {
                        t.clientWidth !== i && c();
                      },
                      o = function (e) {
                        window.removeEventListener("resize", s, !1),
                          t.removeEventListener("input", c, !1),
                          t.removeEventListener("keyup", c, !1),
                          t.removeEventListener("autosize:destroy", o, !1),
                          t.removeEventListener("autosize:update", c, !1),
                          Object.keys(e).forEach(function (n) {
                            t.style[n] = e[n];
                          }),
                          zc.delete(t);
                      }.bind(t, {
                        height: t.style.height,
                        resize: t.style.resize,
                        overflowY: t.style.overflowY,
                        overflowX: t.style.overflowX,
                        wordWrap: t.style.wordWrap,
                      });
                    t.addEventListener("autosize:destroy", o, !1),
                      "onpropertychange" in t &&
                        "oninput" in t &&
                        t.addEventListener("keyup", c, !1),
                      window.addEventListener("resize", s, !1),
                      t.addEventListener("input", c, !1),
                      t.addEventListener("autosize:update", c, !1),
                      (t.style.overflowX = "hidden"),
                      (t.style.wordWrap = "break-word"),
                      zc.set(t, {
                        destroy: o,
                        update: c,
                      }),
                      "vertical" ===
                      (e = window.getComputedStyle(t, null)).resize
                        ? (t.style.resize = "none")
                        : "both" === e.resize &&
                          (t.style.resize = "horizontal"),
                      (n =
                        "content-box" === e.boxSizing
                          ? -(
                              parseFloat(e.paddingTop) +
                              parseFloat(e.paddingBottom)
                            )
                          : parseFloat(e.borderTopWidth) +
                            parseFloat(e.borderBottomWidth)),
                      isNaN(n) && (n = 0),
                      c();
                  }
                  function a(e) {
                    var n = t.style.width;
                    (t.style.width = "0px"),
                      (t.style.width = n),
                      (t.style.overflowY = e);
                  }
                  function l() {
                    if (0 !== t.scrollHeight) {
                      var e = (function (t) {
                        for (
                          var e = [];
                          t && t.parentNode && t.parentNode instanceof Element;

                        )
                          t.parentNode.scrollTop &&
                            ((t.parentNode.style.scrollBehavior = "auto"),
                            e.push([t.parentNode, t.parentNode.scrollTop])),
                            (t = t.parentNode);
                        return function () {
                          return e.forEach(function (t) {
                            var e = t[0];
                            (e.scrollTop = t[1]),
                              (e.style.scrollBehavior = null);
                          });
                        };
                      })(t);
                      (t.style.height = ""),
                        (t.style.height = t.scrollHeight + n + "px"),
                        (i = t.clientWidth),
                        e();
                    }
                  }
                  function c() {
                    l();
                    var e = Math.round(parseFloat(t.style.height)),
                      n = window.getComputedStyle(t, null),
                      i =
                        "content-box" === n.boxSizing
                          ? Math.round(parseFloat(n.height))
                          : t.offsetHeight;
                    if (
                      (i < e
                        ? "hidden" === n.overflowY &&
                          (a("scroll"),
                          l(),
                          (i =
                            "content-box" === n.boxSizing
                              ? Math.round(
                                  parseFloat(
                                    window.getComputedStyle(t, null).height
                                  )
                                )
                              : t.offsetHeight))
                        : "hidden" !== n.overflowY &&
                          (a("hidden"),
                          l(),
                          (i =
                            "content-box" === n.boxSizing
                              ? Math.round(
                                  parseFloat(
                                    window.getComputedStyle(t, null).height
                                  )
                                )
                              : t.offsetHeight)),
                      r !== i)
                    ) {
                      r = i;
                      var s = Bc("autosize:resized");
                      try {
                        t.dispatchEvent(s);
                      } catch (t) {}
                    }
                  }
                })(t);
              }),
            t
          );
        }).destroy = function (t) {
          return t && Array.prototype.forEach.call(t.length ? t : [t], Hc), t;
        }),
        (Gc.update = function (t) {
          return t && Array.prototype.forEach.call(t.length ? t : [t], Vc), t;
        }));
    var Wc = Gc;
    function jc(t, e) {
      (t.prototype = Object.create(e.prototype)),
        (t.prototype.constructor = t),
        Xc(t, e);
    }
    function Xc(t, e) {
      return (Xc = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var qc = (function (t) {
        function e() {
          var e, n, i;
          return (
            ((i = t.apply(this, arguments) || this).input =
              i.el.querySelector("input, textarea")),
            (i.isTextarea =
              "TEXTAREA" === (null == (e = i.input) ? void 0 : e.tagName)),
            (i.validityMsg = JSON.parse(
              null != (n = i.el.dataset.validityMsg) ? n : "null"
            )),
            (i.message = i.el.querySelector(".cb-input_light-message")),
            i.bindInput(),
            i.isTextarea && i.bindAutosize(),
            i
          );
        }
        jc(e, t);
        var n = e.prototype;
        return (
          (n.bindInput = function () {
            var t = this;
            this.input &&
              this.input.addEventListener("change", function () {
                t.el.classList.toggle("-filled", !!t.input.value),
                  t.checkValidity();
              });
          }),
          (n.bindAutosize = function () {
            Wc(this.input),
              this.input.addEventListener("change", function () {
                return No.refresh();
              });
          }),
          (n.checkValidity = function () {
            var t = this.input.validity;
            if (t && this.validityMsg) {
              if ((this.el.classList.toggle("-error", !t.valid), t.valid))
                return (this.message.innerHTML = ""), !0;
              for (var e in t)
                if (t[e] && this.validityMsg[e]) {
                  this.message.innerHTML = this.validityMsg[e];
                  break;
                }
              return !1;
            }
          }),
          (n.reset = function () {
            this.el.classList.remove("-filled -error");
          }),
          e
        );
      })(l),
      Yc = (function (t) {
        function e() {
          var e, n, i;
          return (
            ((i = t.apply(this, arguments) || this).files = []),
            (i.overallSize = 0),
            (i.error = !1),
            (i.validity = JSON.parse(
              null != (e = i.el.dataset.validity) ? e : "null"
            )),
            (i.validityMsg = JSON.parse(
              null != (n = i.el.dataset.validityMsg) ? n : "null"
            )),
            (i.input = i.el.querySelector("[type=file]")),
            (i.isMultiple = !!i.input.multiple),
            (i.btn = i.el.querySelector(".cb-input_file-btn")),
            (i.items = i.el.querySelector(".cb-input_file-items")),
            (i.message = i.el.querySelector(".cb-input_file-message")),
            i.bindChange(),
            i
          );
        }
        jc(e, t);
        var n = e.prototype;
        return (
          (n.bindChange = function () {
            var t = this;
            this.btn.addEventListener("click", function () {
              return t.input.click();
            }),
              this.input.addEventListener("change", function () {
                t.suppressAdd || t.addFiles(), (t.suppressAdd = !1);
              });
          }),
          (n.checkValidity = function () {
            this.validity &&
              this.validityMsg &&
              ((this.error = !1),
              this.files.length > this.validity.limit && (this.error = "limit"),
              this.overallSize > this.validity.size && (this.error = "size"),
              this.error
                ? this.setError(this.validityMsg[this.error])
                : this.removeError());
          }),
          (n.reset = function () {
            (this.input.innerHTML = ""), (this.files = []), this.updateFiles();
          }),
          (n.setError = function (t) {
            void 0 === t && (t = ""),
              this.el.classList.add("-error"),
              t && (this.message.innerHTML = t),
              this.input.setCustomValidity(t || "error");
          }),
          (n.removeError = function () {
            this.el.classList.remove("-error"),
              (this.message.innerHTML = ""),
              this.input.setCustomValidity("");
          }),
          (n.addFiles = function () {
            (this.files = this.isMultiple
              ? this.files.concat(Array.from(this.input.files))
              : this.input.files),
              this.updateFiles();
          }),
          (n.updateFiles = function () {
            var t = this,
              e = new DataTransfer(),
              n = document.createDocumentFragment();
            (this.overallSize = 0),
              this.files.forEach(function (i, r) {
                var s = document.createElement("div");
                (s.className = "cb-input_file-item"),
                  (s.innerHTML = "<i></i><b>" + i.name + "</b>"),
                  s.addEventListener("click", function () {
                    return t.removeFile(r);
                  }),
                  n.appendChild(s),
                  e.items.add(i),
                  (t.overallSize += i.size);
              }),
              (this.input.files = e.files),
              (this.items.innerHTML = ""),
              this.items.appendChild(n),
              this.checkValidity(),
              No.refresh();
          }),
          (n.removeFile = function (t) {
            this.files.splice(t, 1),
              this.updateFiles(),
              (this.suppressAdd = !0),
              this.input.dispatchEvent(new Event("change"));
          }),
          e
        );
      })(l);
    function Kc(t, e) {
      return (Kc = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Zc = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).events = []),
          (e.autoDestroy = !1),
          (e.showTimeout = 30),
          (e.hideTimeout = 600),
          (e.dialog = e.el.querySelector("[data-modal-dialog]")),
          (e.closes = e.el.querySelectorAll("[data-modal-close]")),
          e.bindCloses(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        Kc(e, n);
      var r = i.prototype;
      return (
        (r.bindCloses = function () {
          var t = this;
          this.closes.forEach(function (e) {
            return e.addEventListener("click", function () {
              return t.hide();
            });
          });
        }),
        (r.open = function () {
          var t = this;
          this.trigger("show"),
            this.el.classList.add("-show"),
            document.documentElement.classList.add("modal"),
            clearInterval(this.visibleInt),
            (this.visibleInt = setTimeout(function () {
              t.el.classList.add("-visible"), t.trigger("showed");
            }, this.showTimeout));
        }),
        (r.hide = function () {
          var t = this;
          this.trigger("hide"),
            this.el.classList.remove("-visible"),
            document.documentElement.classList.remove("modal"),
            clearInterval(this.visibleInt),
            (this.visibleInt = setTimeout(function () {
              t.el.classList.remove("-show"),
                t.trigger("hidden"),
                t.autoDestroy && t.destroy();
            }, this.hideTimeout));
        }),
        (r.destroy = function () {
          this.el.parentNode.removeChild(this.el), this.trigger("destroy");
        }),
        (r.setContent = function (t) {
          this.dialog.innerHTML = t;
        }),
        (r.on = function (t, e) {
          this.events[t] instanceof Array || this.off(t),
            this.events[t].push(e);
        }),
        (r.off = function (t, e) {
          this.events[t] = e
            ? this.events[t].filter(function (t) {
                return t !== e;
              })
            : [];
        }),
        (r.trigger = function (t) {
          for (
            var e = this,
              n = arguments.length,
              i = new Array(n > 1 ? n - 1 : 0),
              r = 1;
            r < n;
            r++
          )
            i[r - 1] = arguments[r];
          this.events[t] &&
            this.events[t].forEach(function (t) {
              return t.call.apply(t, [e, e].concat(i));
            });
        }),
        i
      );
    })(l);
    function Jc(t, e) {
      return (Jc = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var $c = (function (t) {
      var e, n;
      function i() {
        return t.apply(this, arguments) || this;
      }
      return (
        (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        Jc(e, n),
        i
      );
    })(l);
    function Qc(t, e) {
      return (Qc = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var tu = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).opened = !1),
          (e.toggleBtn = e.el.querySelector(".cb-menu-toggle button")),
          (e.box = e.el.querySelector(".cb-menu-box")),
          (e.backdrop = e.el.querySelector(".cb-menu-backdrop")),
          (e.fill = e.el.querySelector(".cb-menu-fill")),
          (e.content = e.el.querySelector(".cb-menu-content")),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        Qc(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return (
              (this.tlClose = this.tlHide()),
              (this.tlOpen = this.tlShow()),
              this.bindToggle(),
              this.magicInverse(),
              Promise.resolve()
            );
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onDestroy = function () {
          try {
            return (
              document.documentElement.classList.remove("menu-open"),
              Promise.resolve()
            );
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.bindToggle = function () {
          var t = this;
          this.toggleBtn.addEventListener("click", function () {
            return t.toggle();
          }),
            this.backdrop.addEventListener("click", function () {
              return t.hide();
            }),
            this.tlClose.eventCallback("onComplete", function () {
              t.box.classList.remove("-visible");
            }),
            this.el.addEventListener("mouseenter", function () {
              var e;
              t.el.classList.contains("-inverse") &&
                (null == (e = t.app.get("cursor").follower) ||
                  e.addState("-inverse"));
            }),
            window.addEventListener("keyup", function (e) {
              "Escape" === e.key && t.toggle();
            }),
            No.isTouch ||
              Ec(this.toggleBtn, {
                leaveSpeed: 2,
                leaveEase: "elastic.out(1,0.25)",
              });
        }),
        (r.toggle = function () {
          this.opened ? this.hide() : this.show();
        }),
        (r.show = function () {
          var t;
          ((this.opened = !0),
          this.el.classList.add("-open"),
          document.documentElement.classList.add("menu-open"),
          this.tlClose.pause(),
          this.tlOpen.play(0),
          this.el.classList.contains("-inverse")) &&
            (null == (t = this.app.get("cursor").follower) ||
              t.removeState("-inverse"));
        }),
        (r.hide = function (t) {
          var e;
          (void 0 === t && (t = !1),
          (this.opened = !1),
          this.el.classList.remove("-open"),
          document.documentElement.classList.remove("menu-open"),
          t
            ? (this.tlOpen.pause(0), this.tlClose.pause(0))
            : (this.tlOpen.pause(), this.tlClose.play(0)),
          this.el.classList.contains("-inverse")) &&
            (null == (e = this.app.get("cursor").follower) ||
              e.addState("-inverse"));
        }),
        (r.tlShow = function () {
          var t = new Yi.timeline({
            paused: !0,
          });
          return (
            t.set(
              this.box,
              {
                display: "block",
              },
              0
            ),
            t.fromTo(
              this.backdrop,
              {
                opacity: 0,
              },
              {
                opacity: 1,
                duration: 0.5,
              },
              0
            ),
            t.fromTo(
              this.fill,
              {
                scaleX: 0,
              },
              {
                scaleX: 1,
                ease: "expo.out",
                duration: 1,
              },
              0
            ),
            t.fromTo(
              this.content,
              {
                xPercent: 50,
              },
              {
                xPercent: 0,
                ease: "expo.out",
                duration: 1,
              },
              0
            ),
            t.fromTo(
              this.content,
              {
                opacity: 0,
              },
              {
                opacity: 1,
                duration: 0.5,
              },
              0.15
            ),
            t
          );
        }),
        (r.tlHide = function () {
          var t = new Yi.timeline({
            paused: !0,
          });
          return (
            t.fromTo(
              this.backdrop,
              {
                opacity: 1,
              },
              {
                opacity: 0,
                duration: 0.4,
              },
              0
            ),
            t.fromTo(
              this.fill,
              {
                scaleX: 1,
              },
              {
                scaleX: 0,
                duration: 0.4,
              },
              0
            ),
            t.fromTo(
              this.content,
              {
                xPercent: 0,
              },
              {
                xPercent: 20,
                duration: 0.4,
              },
              0
            ),
            t.fromTo(
              this.content,
              {
                opacity: 1,
              },
              {
                opacity: 0,
                duration: 0.1,
              },
              0
            ),
            t.set(this.box, {
              display: "none",
            }),
            t
          );
        }),
        (r.magicInverse = function () {
          var t = this;
          document
            .querySelectorAll("[data-menu-inverse]")
            .forEach(function (e) {
              No.create({
                trigger: e,
                start: "top top+=50px",
                end: "bottom top+=70px",
                toggleClass: {
                  targets: t.el,
                  className: "-inverse",
                },
                refreshPriority: -99999,
              });
            });
        }),
        i
      );
    })(l);
    function eu(t, e) {
      return (eu = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var nu = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).video =
            e.el.querySelector(".cb-intouch-video")),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        eu(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return this.handleEnter(), this.initMagnetic(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onEnter = function () {
          try {
            var t = this;
            return t.enterTl
              ? Promise.resolve(t.app.wait("loader", "enter")).then(
                  function () {
                    return Promise.resolve(t.enterTl.play(0)).then(
                      function () {}
                    );
                  }
                )
              : Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onRefresh = function () {
          try {
            return this.enterTl && this.enterTl.pause(0), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.handleEnter = function () {
          this.el.offsetWidth && (this.enterTl = this.tlEnter());
        }),
        (r.tlEnter = function () {
          var t = new Yi.timeline({
            paused: !0,
          });
          return (
            t.from(this.el, {
              scale: 0,
              duration: 2,
              ease: "expo.out",
            }),
            t
          );
        }),
        (r.initMagnetic = function () {
          No.isTouch ||
            Ec(this.video, {
              box: this.el,
              xDelta: 0.08,
              yDelta: 0.08,
              leaveSpeed: 2,
              leaveEase: "elastic.out(1,0.25)",
            });
        }),
        i
      );
    })(l);
    function iu(t, e) {
      return (iu = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var ru = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).cursor = e.app.get("cursor")),
          (e.src = e.el.dataset.src),
          e.bindSwitch(),
          e.bindCursor(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        iu(e, n);
      var r = i.prototype;
      return (
        (r.bindSwitch = function () {
          var t = this;
          this.src &&
            this.el.addEventListener("click", function () {
              return t.injectFrame();
            });
        }),
        (r.bindCursor = function () {
          var t = this;
          this.cursor.follower &&
            (this.el.addEventListener("mouseenter", function () {
              return t.cursor.follower.hide();
            }),
            this.el.addEventListener("mouseleave", function () {
              return t.cursor.follower.show();
            }));
        }),
        (r.injectFrame = function () {
          this.el.innerHTML =
            "<iframe src='" +
            this.src +
            "' allow='accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture' allowfullscreen></iframe>";
        }),
        i
      );
    })(l);
    function su(t, e) {
      return (su = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var ou = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).fill =
            e.el.querySelector(".cb-tophead-fill")),
          (e.header = e.el.querySelector(".cb-tophead-header")),
          (e.title = e.el.querySelector(".cb-tophead-title")),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        su(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return this.handleEnter(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onEnter = function () {
          try {
            return this.enterTl && this.enterTl.play(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.handleEnter = function () {
          this.enterTl = this.tlEnter();
        }),
        (r.tlEnter = function () {
          var t = new Yi.timeline({
            paused: !0,
            delay: 0.4,
          });
          return (
            this.header &&
              t.add(
                Mc(this.header.firstElementChild, {
                  stagger: 0.1,
                }),
                0
              ),
            this.title && t.add(Mc(this.title.firstElementChild), 0.1),
            this.fill &&
              (t.set(this.fill, {
                willChange: "transform",
              }),
              t.fromTo(
                this.fill,
                {
                  scaleY: window.innerHeight / this.el.offsetHeight,
                  transformOrigin: "top center",
                },
                {
                  scaleY: 1,
                  transformOrigin: "top center",
                  duration: 3,
                  ease: "expo.out",
                },
                0.5
              ),
              t.set(this.fill, {
                willChange: "auto",
              })),
            t
          );
        }),
        i
      );
    })(l);
    function au(t, e) {
      return (au = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var lu = (function (t) {
      var e, n;
      function i() {
        var e, n;
        return (
          ((n = t.apply(this, arguments) || this).cursor = n.app.get("cursor")),
          (n.modalSuccess = n.app.find("#modal-contact-success", "modal")),
          (n.modalError = n.app.find("#modal-contact-error", "modal")),
          (n.modalErrorMessage =
            null == (e = n.modalError)
              ? void 0
              : e.el.querySelector(".cb-modal_box-message-message")),
          (n.header = n.el.querySelector(".cb-contact-header")),
          (n.form = n.el.querySelector(".cb-contact-form")),
          (n.input = n.form.querySelectorAll("input, select, textarea")),
          (n.submitBtn = n.el.querySelector("[type=submit]")),
          (n.attachments = n.app.get("input.file")),
          n.bindForm(),
          n.bindInputs(),
          n.handleEnter(),
          n.checkValidity(),
          n
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        au(e, n);
      var r = i.prototype;
      return (
        (r.onEnter = function () {
          try {
            var t = this,
              e = (function () {
                if (t.enterTl)
                  return Promise.resolve(t.enterTl.play()).then(function () {});
              })();
            return Promise.resolve(
              e && e.then ? e.then(function () {}) : void 0
            );
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.handleEnter = function () {
          this.enterTl = this.tlEnter();
        }),
        (r.bindForm = function () {
          var t = this;
          this.form.addEventListener("submit", function (e) {
            try {
              return (
                e.preventDefault(),
                window.grecaptcha
                  ? window.grecaptcha.ready(function () {
                      window.grecaptcha
                        .execute("6Lewc_4ZAAAAAFQApM6YE6VtaTFKJgNHxePjQo7D", {
                          action: "submit",
                        })
                        .then(function (e) {
                          (t.reqRecaptchaToken = e), t.submit();
                        });
                    })
                  : t.submit(),
                Promise.resolve()
              );
            } catch (e) {
              return Promise.reject(e);
            }
          });
        }),
        (r.bindInputs = function () {
          var t = this;
          this.input.forEach(function (e) {
            e.addEventListener("change", function () {
              return t.checkValidity();
            });
          });
        }),
        (r.checkValidity = function () {
          this.submitBtn.disabled = !this.form.checkValidity();
        }),
        (r.submit = function () {
          var t = this;
          (this.data = new FormData(this.form)),
            window.fbq && window.fbq("track", "Lead"),
            window.ym && window.ym(window.ymID, "reachGoal", "order"),
            this.reqRecaptchaToken &&
              this.data.append("g-recaptcha-response", this.reqRecaptchaToken),
            this.setLoadingState(),
            fetch(this.form.action, {
              method: "POST",
              body: this.data,
              cache: "no-cache",
            })
              .then(function (e) {
                if (!e.ok) return t.setErrorState(e.statusText), !1;
                t.setSuccessState();
              })
              .catch(function () {
                t.setErrorState();
              });
        }),
        (r.reset = function () {
          this.form.reset(),
            this.attachments.reset(),
            this.submitBtn.setAttribute("disabled", !0);
        }),
        (r.setLoadingState = function () {
          var t, e;
          this.submitBtn.setAttribute("disabled", !0),
            null == (t = this.cursor) || t.follower.removeState("-opaque"),
            null == (e = this.cursor) || e.follower.addState("-loading");
        }),
        (r.removeLoadingState = function () {
          var t;
          this.submitBtn.removeAttribute("disabled"),
            null == (t = this.cursor) || t.follower.removeState("-loading");
        }),
        (r.setSuccessState = function () {
          this.removeLoadingState(), this.reset(), this.modalSuccess.open();
        }),
        (r.setErrorState = function (t) {
          this.removeLoadingState(),
            (this.modalErrorMessage.innerHTML = null != t ? t : ""),
            this.modalError.open();
        }),
        (r.tlEnter = function () {
          var t = new Yi.timeline({
              paused: !0,
              delay: 0.4,
            }),
            e = Array.from(
              this.el.querySelectorAll(
                ".cb-contact-label, .cb-checkbox, .cb-contact-group"
              )
            ).filter(function (t) {
              return No.isInViewport(t);
            });
          return (
            this.header && t.add(Mc(this.header.firstElementChild), 0),
            t.set(
              e,
              {
                willChange: "transform",
              },
              0
            ),
            t.fromTo(
              e,
              {
                y: window.innerWidth > 1e3 ? 50 : 30,
                opacity: 0,
              },
              {
                y: 0,
                opacity: 1,
                ease: "power3.out",
                duration: 1,
                stagger: 0.04,
              },
              0.2
            ),
            t.set(e, {
              willChange: "auto",
            }),
            t
          );
        }),
        i
      );
    })(l);
    function cu(t, e) {
      return (cu = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var uu = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).cursor = e.app.get("cursor")),
          (e.filterModal = e.app.find("#modal-work-filters", "modal")),
          (e.filter = e.el.querySelector(".cb-work-filter")),
          (e.filterTitle = e.el.querySelector(".cb-work-filter-title")),
          (e.filterActive = e.filter.querySelector(".cb-work-filter-active")),
          (e.gridLeft = e.el.querySelector(".cb-work-col.-left")),
          (e.gridRight = e.el.querySelector(".cb-work-col.-right")),
          (e.itemLeft = Array.from(
            e.gridLeft.querySelectorAll(".cb-work-item")
          )),
          (e.itemRight = Array.from(
            e.gridRight.querySelectorAll(".cb-work-item")
          )),
          (e.itemLength = e.itemLeft.length + e.itemRight.length),
          (e.item = new Array(e.itemLength).fill(void 0).map(function (t, n) {
            return n % 2 == 0
              ? e.itemLeft[Math.floor(n / 2)]
              : n % 2 == 1
              ? e.itemRight[Math.floor(n / 2)]
              : void 0;
          })),
          e.bindFilter(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        cu(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            var t = this;
            return Promise.resolve(document.fonts.ready).then(function () {
              t.handleEnter();
            });
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onEnter = function () {
          try {
            return this.enterTl && this.enterTl.play(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.handleEnter = function () {
          this.enterTl = this.tlEnter();
        }),
        (r.bindFilter = function () {
          var t = this,
            e = this.filterModal.el.querySelectorAll(
              ".cb-modal_box-nav-item a"
            );
          this.cursor.follower &&
            this.filterModal.on("hide", function () {
              return t.cursor.follower.removeIcon();
            }),
            this.filterActive.addEventListener("click", function () {
              return t.openFilters();
            }),
            e.forEach(function (e) {
              e.addEventListener("click", function () {
                t.filterSelect(e.dataset.filterTarget, e.innerText),
                  t.hideFilters();
              });
            });
        }),
        (r.filterSelect = function (t, e) {
          var n = this.item.filter(function (e) {
              return "all" === t || e.dataset.cat.indexOf(t) > -1;
            }),
            i = document.createDocumentFragment(),
            r = document.createDocumentFragment();
          n.forEach(function (t, e) {
            e % 2 == 0 && i.appendChild(t),
              e % 2 == 1 && r.appendChild(t),
              (t.style.display = "block");
          }),
            (this.filterActive.querySelector("span").innerHTML = e),
            (this.gridLeft.innerHTML = ""),
            this.gridLeft.appendChild(i),
            (this.gridRight.innerHTML = ""),
            this.gridRight.appendChild(r),
            No.refresh();
        }),
        (r.openFilters = function () {
          this.filterModal.open();
        }),
        (r.hideFilters = function () {
          this.filterModal.hide();
        }),
        (r.tlEnter = function () {
          var t = this,
            e = new Yi.timeline({
              paused: !0,
              delay: 0.4,
            });
          return (
            Yi.set(this.item, {
              opacity: 0,
            }),
            this.filter && e.add(Ac([this.filterTitle, this.filterActive]), 0),
            e.add(function () {
              return t.magicShow();
            }, 0.1),
            e
          );
        }),
        (r.magicShow = function () {
          this.item.length &&
            Pc(this.item, null, {
              interval: 0.2,
            });
        }),
        i
      );
    })(l);
    function hu(t, e) {
      return (hu = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var du = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).header = e.el.querySelector(
            ".cb-entrylist-header"
          )),
          (e.filter = e.el.querySelectorAll(".cb-entrylist-filter")),
          (e.items = e.el.querySelector(".cb-entrylist-items")),
          (e.item = Array.from(e.el.querySelectorAll(".cb-entrylist-item"))),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        hu(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return this.bindFilters(), this.handleEnter(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onEnter = function () {
          try {
            var t = this,
              e = (function () {
                if (t.enterTl)
                  return Promise.resolve(t.enterTl.play(0)).then(
                    function () {}
                  );
              })();
            return Promise.resolve(
              e && e.then ? e.then(function () {}) : void 0
            );
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.bindFilters = function () {
          var t = this;
          this.filter.forEach(function (e) {
            e.addEventListener("click", function () {
              t.smoothChangeCategory(e.dataset.filterId),
                t.filter.forEach(function (t) {
                  t.classList.toggle("-active", t === e);
                });
            });
          });
        }),
        (r.setCategoryFilter = function (t) {
          this.item.forEach(function (e) {
            e.toggleAttribute("hidden", !!t && t !== e.dataset.catId);
          });
        }),
        (r.smoothChangeCategory = function (t) {
          this.stItemShow &&
            this.stItemShow.forEach(function (t) {
              t.kill();
            }),
            this.setCategoryFilter(t),
            Yi.killTweensOf(this.item),
            Yi.set(this.item, {
              opacity: 1,
            });
        }),
        (r.handleEnter = function () {
          this.enterTl = this.tlEnter();
        }),
        (r.tlEnter = function () {
          var t = this,
            e = new Yi.timeline({
              paused: !0,
              delay: 0.4,
            });
          return (
            Yi.set(this.item, {
              opacity: 0,
            }),
            this.header &&
              e.add(
                Mc(this.header.firstElementChild, {
                  stagger: 0.1,
                }),
                0
              ),
            this.filter.length &&
              e.fromTo(
                this.filter,
                {
                  y: window.innerWidth > 1e3 ? 50 : 30,
                  opacity: 0,
                },
                {
                  y: 0,
                  opacity: 1,
                  ease: "power3.out",
                  duration: 1,
                  stagger: 0.04,
                },
                0.2
              ),
            e.add(function () {
              return t.magicShow();
            }, 0.45),
            e
          );
        }),
        (r.magicShow = function () {
          this.item.length && (this.stItemShow = Pc(this.item));
        }),
        i
      );
    })(l);
    function pu(t, e) {
      return (pu = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var fu = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).header = e.el.querySelector(
            ".cb-featured-header"
          )),
          (e.item = e.el.querySelectorAll(".cb-featured-item")),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        pu(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            var t = this;
            return Promise.resolve(document.fonts.ready).then(function () {
              t.bindVideoPlay(), t.magicShow();
            });
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.bindVideoPlay = function () {
          No.isTouch ||
            this.item.forEach(function (t) {
              var e = t.querySelector("video");
              t.addEventListener("mouseenter", function () {
                return e.play();
              }),
                t.addEventListener("mouseleave", function () {
                  return e.pause();
                });
            });
        }),
        (r.magicShow = function () {
          this.header &&
            Tc(this.header.firstElementChild, {
              type: "lines",
              stagger: 0.2,
            }),
            this.item.length && Pc(this.item);
        }),
        i
      );
    })(l);
    function mu(t) {
      return (
        null !== t &&
        "object" == typeof t &&
        "constructor" in t &&
        t.constructor === Object
      );
    }
    function gu(t = {}, e = {}) {
      Object.keys(e).forEach((n) => {
        void 0 === t[n]
          ? (t[n] = e[n])
          : mu(e[n]) &&
            mu(t[n]) &&
            Object.keys(e[n]).length > 0 &&
            gu(t[n], e[n]);
      });
    }
    const vu = {
      body: {},
      addEventListener() {},
      removeEventListener() {},
      activeElement: {
        blur() {},
        nodeName: "",
      },
      querySelector: () => null,
      querySelectorAll: () => [],
      getElementById: () => null,
      createEvent: () => ({
        initEvent() {},
      }),
      createElement: () => ({
        children: [],
        childNodes: [],
        style: {},
        setAttribute() {},
        getElementsByTagName: () => [],
      }),
      createElementNS: () => ({}),
      importNode: () => null,
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: "",
      },
    };
    function _u() {
      const t = "undefined" != typeof document ? document : {};
      return gu(t, vu), t;
    }
    const yu = {
      document: vu,
      navigator: {
        userAgent: "",
      },
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: "",
      },
      history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {},
      },
      CustomEvent: function () {
        return this;
      },
      addEventListener() {},
      removeEventListener() {},
      getComputedStyle: () => ({
        getPropertyValue: () => "",
      }),
      Image() {},
      Date() {},
      screen: {},
      setTimeout() {},
      clearTimeout() {},
      matchMedia: () => ({}),
      requestAnimationFrame: (t) =>
        "undefined" == typeof setTimeout ? (t(), null) : setTimeout(t, 0),
      cancelAnimationFrame(t) {
        "undefined" != typeof setTimeout && clearTimeout(t);
      },
    };
    function xu() {
      const t = "undefined" != typeof window ? window : {};
      return gu(t, yu), t;
    }
    function bu(t, e = 0) {
      return setTimeout(t, e);
    }
    function Su() {
      return Date.now();
    }
    function Eu(t, e = "x") {
      const n = xu();
      let i, r, s;
      const o = (function (t) {
        const e = xu();
        let n;
        return (
          e.getComputedStyle && (n = e.getComputedStyle(t, null)),
          !n && t.currentStyle && (n = t.currentStyle),
          n || (n = t.style),
          n
        );
      })(t);
      return (
        n.WebKitCSSMatrix
          ? ((r = o.transform || o.webkitTransform),
            r.split(",").length > 6 &&
              (r = r
                .split(", ")
                .map((t) => t.replace(",", "."))
                .join(", ")),
            (s = new n.WebKitCSSMatrix("none" === r ? "" : r)))
          : ((s =
              o.MozTransform ||
              o.OTransform ||
              o.MsTransform ||
              o.msTransform ||
              o.transform ||
              o
                .getPropertyValue("transform")
                .replace("translate(", "matrix(1, 0, 0, 1,")),
            (i = s.toString().split(","))),
        "x" === e &&
          (r = n.WebKitCSSMatrix
            ? s.m41
            : 16 === i.length
            ? parseFloat(i[12])
            : parseFloat(i[4])),
        "y" === e &&
          (r = n.WebKitCSSMatrix
            ? s.m42
            : 16 === i.length
            ? parseFloat(i[13])
            : parseFloat(i[5])),
        r || 0
      );
    }
    function Mu(t) {
      return (
        "object" == typeof t &&
        null !== t &&
        t.constructor &&
        "Object" === Object.prototype.toString.call(t).slice(8, -1)
      );
    }
    function Tu(...t) {
      const e = Object(t[0]),
        n = ["__proto__", "constructor", "prototype"];
      for (let r = 1; r < t.length; r += 1) {
        const s = t[r];
        if (
          null != s &&
          ((i = s),
          !("undefined" != typeof window && void 0 !== window.HTMLElement
            ? i instanceof HTMLElement
            : i && (1 === i.nodeType || 11 === i.nodeType)))
        ) {
          const t = Object.keys(Object(s)).filter((t) => n.indexOf(t) < 0);
          for (let n = 0, i = t.length; n < i; n += 1) {
            const i = t[n],
              r = Object.getOwnPropertyDescriptor(s, i);
            void 0 !== r &&
              r.enumerable &&
              (Mu(e[i]) && Mu(s[i])
                ? s[i].__swiper__
                  ? (e[i] = s[i])
                  : Tu(e[i], s[i])
                : !Mu(e[i]) && Mu(s[i])
                ? ((e[i] = {}),
                  s[i].__swiper__ ? (e[i] = s[i]) : Tu(e[i], s[i]))
                : (e[i] = s[i]));
          }
        }
      }
      var i;
      return e;
    }
    function wu(t, e, n) {
      t.style.setProperty(e, n);
    }
    function Du({ swiper: t, targetPosition: e, side: n }) {
      const i = xu(),
        r = -t.translate;
      let s,
        o = null;
      const a = t.params.speed;
      (t.wrapperEl.style.scrollSnapType = "none"),
        i.cancelAnimationFrame(t.cssModeFrameID);
      const l = e > r ? "next" : "prev",
        c = (t, e) => ("next" === l && t >= e) || ("prev" === l && t <= e),
        u = () => {
          (s = new Date().getTime()), null === o && (o = s);
          const l = Math.max(Math.min((s - o) / a, 1), 0),
            h = 0.5 - Math.cos(l * Math.PI) / 2;
          let d = r + h * (e - r);
          if (
            (c(d, e) && (d = e),
            t.wrapperEl.scrollTo({
              [n]: d,
            }),
            c(d, e))
          )
            return (
              (t.wrapperEl.style.overflow = "hidden"),
              (t.wrapperEl.style.scrollSnapType = ""),
              setTimeout(() => {
                (t.wrapperEl.style.overflow = ""),
                  t.wrapperEl.scrollTo({
                    [n]: d,
                  });
              }),
              void i.cancelAnimationFrame(t.cssModeFrameID)
            );
          t.cssModeFrameID = i.requestAnimationFrame(u);
        };
      u();
    }
    function Au(t, e = "") {
      return [...t.children].filter((t) => t.matches(e));
    }
    function Cu(t, e = []) {
      const n = document.createElement(t);
      return n.classList.add(...(Array.isArray(e) ? e : [e])), n;
    }
    function Pu(t, e) {
      return xu().getComputedStyle(t, null).getPropertyValue(e);
    }
    function Ru(t) {
      let e,
        n = t;
      if (n) {
        for (e = 0; null !== (n = n.previousSibling); )
          1 === n.nodeType && (e += 1);
        return e;
      }
    }
    function Lu(t, e) {
      const n = [];
      let i = t.parentElement;
      for (; i; )
        e ? i.matches(e) && n.push(i) : n.push(i), (i = i.parentElement);
      return n;
    }
    function Ou(t, e, n) {
      const i = xu();
      return n
        ? t["width" === e ? "offsetWidth" : "offsetHeight"] +
            parseFloat(
              i
                .getComputedStyle(t, null)
                .getPropertyValue("width" === e ? "margin-right" : "margin-top")
            ) +
            parseFloat(
              i
                .getComputedStyle(t, null)
                .getPropertyValue(
                  "width" === e ? "margin-left" : "margin-bottom"
                )
            )
        : t.offsetWidth;
    }
    let Iu, Fu, Uu;
    function Nu() {
      return (
        Iu ||
          (Iu = (function () {
            const t = xu(),
              e = _u();
            return {
              smoothScroll:
                e.documentElement &&
                "scrollBehavior" in e.documentElement.style,
              touch: !!(
                "ontouchstart" in t ||
                (t.DocumentTouch && e instanceof t.DocumentTouch)
              ),
            };
          })()),
        Iu
      );
    }
    function ku(t = {}) {
      return (
        Fu ||
          (Fu = (function ({ userAgent: t } = {}) {
            const e = Nu(),
              n = xu(),
              i = n.navigator.platform,
              r = t || n.navigator.userAgent,
              s = {
                ios: !1,
                android: !1,
              },
              o = n.screen.width,
              a = n.screen.height,
              l = r.match(/(Android);?[\s\/]+([\d.]+)?/);
            let c = r.match(/(iPad).*OS\s([\d_]+)/);
            const u = r.match(/(iPod)(.*OS\s([\d_]+))?/),
              h = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
              d = "Win32" === i;
            let p = "MacIntel" === i;
            return (
              !c &&
                p &&
                e.touch &&
                [
                  "1024x1366",
                  "1366x1024",
                  "834x1194",
                  "1194x834",
                  "834x1112",
                  "1112x834",
                  "768x1024",
                  "1024x768",
                  "820x1180",
                  "1180x820",
                  "810x1080",
                  "1080x810",
                ].indexOf(`${o}x ${a}`) >= 0 &&
                ((c = r.match(/(Version)\/([\d.]+)/)),
                c || (c = [0, 1, "13_0_0"]),
                (p = !1)),
              l && !d && ((s.os = "android"), (s.android = !0)),
              (c || h || u) && ((s.os = "ios"), (s.ios = !0)),
              s
            );
          })(t)),
        Fu
      );
    }
    function zu() {
      return (
        Uu ||
          (Uu = (function () {
            const t = xu();
            let e = !1;
            function n() {
              const e = t.navigator.userAgent.toLowerCase();
              return (
                e.indexOf("safari") >= 0 &&
                e.indexOf("chrome") < 0 &&
                e.indexOf("android") < 0
              );
            }
            if (n()) {
              const n = String(t.navigator.userAgent);
              if (n.includes("Version/")) {
                const [t, i] = n
                  .split("Version/")[1]
                  .split(" ")[0]
                  .split(".")
                  .map((t) => Number(t));
                e = t < 16 || (16 === t && i < 2);
              }
            }
            return {
              isSafari: e || n(),
              needPerspectiveFix: e,
              isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
                t.navigator.userAgent
              ),
            };
          })()),
        Uu
      );
    }
    const Bu = (t, e) => {
        if (!t || t.destroyed || !t.params) return;
        const n = e.closest(
          t.isElement ? "swiper-slide" : "." + t.params.slideClass
        );
        if (n) {
          const e = n.querySelector("." + t.params.lazyPreloaderClass);
          e && e.remove();
        }
      },
      Hu = (t, e) => {
        if (!t.slides[e]) return;
        const n = t.slides[e].querySelector('[loading="lazy"]');
        n && n.removeAttribute("loading");
      },
      Vu = (t) => {
        if (!t || t.destroyed || !t.params) return;
        let e = t.params.lazyPreloadPrevNext;
        const n = t.slides.length;
        if (!n || !e || e < 0) return;
        e = Math.min(e, n);
        const i =
            "auto" === t.params.slidesPerView
              ? t.slidesPerViewDynamic()
              : Math.ceil(t.params.slidesPerView),
          r = t.activeIndex,
          s = r + i - 1;
        if (t.params.rewind)
          for (let i = r - e; i <= s + e; i += 1) {
            const e = ((i % n) + n) % n;
            e !== r && e > s && Hu(t, e);
          }
        else
          for (let i = Math.max(s - e, 0); i <= Math.min(s + e, n - 1); i += 1)
            i !== r && i > s && Hu(t, i);
      };
    function Gu({ swiper: t, runCallbacks: e, direction: n, step: i }) {
      const { activeIndex: r, previousIndex: s } = t;
      let o = n;
      if (
        (o || (o = r > s ? "next" : r < s ? "prev" : "reset"),
        t.emit("transition" + i),
        e && r !== s)
      ) {
        if ("reset" === o) return void t.emit("slideResetTransition" + i);
        t.emit("slideChangeTransition" + i),
          "next" === o
            ? t.emit("slideNextTransition" + i)
            : t.emit("slidePrevTransition" + i);
      }
    }
    function Wu(t) {
      const e = this,
        n = _u(),
        i = xu(),
        r = e.touchEventsData;
      r.evCache.push(t);
      const { params: s, touches: o, enabled: a } = e;
      if (!a) return;
      if (!s.simulateTouch && "mouse" === t.pointerType) return;
      if (e.animating && s.preventInteractionOnTransition) return;
      !e.animating && s.cssMode && s.loop && e.loopFix();
      let l = t;
      l.originalEvent && (l = l.originalEvent);
      let c = l.target;
      if ("wrapper" === s.touchEventsTarget && !e.wrapperEl.contains(c)) return;
      if ("which" in l && 3 === l.which) return;
      if ("button" in l && l.button > 0) return;
      if (r.isTouched && r.isMoved) return;
      const u = !!s.noSwipingClass && "" !== s.noSwipingClass,
        h = t.composedPath ? t.composedPath() : t.path;
      u && l.target && l.target.shadowRoot && h && (c = h[0]);
      const d = s.noSwipingSelector
          ? s.noSwipingSelector
          : "." + s.noSwipingClass,
        p = !(!l.target || !l.target.shadowRoot);
      if (
        s.noSwiping &&
        (p
          ? (function (t, e = this) {
              return (function e(n) {
                if (!n || n === _u() || n === xu()) return null;
                n.assignedSlot && (n = n.assignedSlot);
                const i = n.closest(t);
                return i || n.getRootNode ? i || e(n.getRootNode().host) : null;
              })(e);
            })(d, c)
          : c.closest(d))
      )
        return void (e.allowClick = !0);
      if (s.swipeHandler && !c.closest(s.swipeHandler)) return;
      (o.currentX = l.pageX), (o.currentY = l.pageY);
      const f = o.currentX,
        m = o.currentY,
        g = s.edgeSwipeDetection || s.iOSEdgeSwipeDetection,
        v = s.edgeSwipeThreshold || s.iOSEdgeSwipeThreshold;
      if (g && (f <= v || f >= i.innerWidth - v)) {
        if ("prevent" !== g) return;
        t.preventDefault();
      }
      Object.assign(r, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0,
      }),
        (o.startX = f),
        (o.startY = m),
        (r.touchStartTime = Su()),
        (e.allowClick = !0),
        e.updateSize(),
        (e.swipeDirection = void 0),
        s.threshold > 0 && (r.allowThresholdMove = !1);
      let _ = !0;
      c.matches(r.focusableElements) &&
        ((_ = !1), "SELECT" === c.nodeName && (r.isTouched = !1)),
        n.activeElement &&
          n.activeElement.matches(r.focusableElements) &&
          n.activeElement !== c &&
          n.activeElement.blur();
      const y = _ && e.allowTouchMove && s.touchStartPreventDefault;
      (!s.touchStartForcePreventDefault && !y) ||
        c.isContentEditable ||
        l.preventDefault(),
        e.params.freeMode &&
          e.params.freeMode.enabled &&
          e.freeMode &&
          e.animating &&
          !s.cssMode &&
          e.freeMode.onTouchStart(),
        e.emit("touchStart", l);
    }
    function ju(t) {
      const e = _u(),
        n = this,
        i = n.touchEventsData,
        { params: r, touches: s, rtlTranslate: o, enabled: a } = n;
      if (!a) return;
      if (!r.simulateTouch && "mouse" === t.pointerType) return;
      let l = t;
      if ((l.originalEvent && (l = l.originalEvent), !i.isTouched))
        return void (
          i.startMoving &&
          i.isScrolling &&
          n.emit("touchMoveOpposite", l)
        );
      const c = i.evCache.findIndex((t) => t.pointerId === l.pointerId);
      c >= 0 && (i.evCache[c] = l);
      const u = i.evCache.length > 1 ? i.evCache[0] : l,
        h = u.pageX,
        d = u.pageY;
      if (l.preventedByNestedSwiper) return (s.startX = h), void (s.startY = d);
      if (!n.allowTouchMove)
        return (
          l.target.matches(i.focusableElements) || (n.allowClick = !1),
          void (
            i.isTouched &&
            (Object.assign(s, {
              startX: h,
              startY: d,
              prevX: n.touches.currentX,
              prevY: n.touches.currentY,
              currentX: h,
              currentY: d,
            }),
            (i.touchStartTime = Su()))
          )
        );
      if (r.touchReleaseOnEdges && !r.loop)
        if (n.isVertical()) {
          if (
            (d < s.startY && n.translate <= n.maxTranslate()) ||
            (d > s.startY && n.translate >= n.minTranslate())
          )
            return (i.isTouched = !1), void (i.isMoved = !1);
        } else if (
          (h < s.startX && n.translate <= n.maxTranslate()) ||
          (h > s.startX && n.translate >= n.minTranslate())
        )
          return;
      if (
        e.activeElement &&
        l.target === e.activeElement &&
        l.target.matches(i.focusableElements)
      )
        return (i.isMoved = !0), void (n.allowClick = !1);
      if (
        (i.allowTouchCallbacks && n.emit("touchMove", l),
        l.targetTouches && l.targetTouches.length > 1)
      )
        return;
      (s.currentX = h), (s.currentY = d);
      const p = s.currentX - s.startX,
        f = s.currentY - s.startY;
      if (n.params.threshold && Math.sqrt(p ** 2 + f ** 2) < n.params.threshold)
        return;
      if (void 0 === i.isScrolling) {
        let t;
        (n.isHorizontal() && s.currentY === s.startY) ||
        (n.isVertical() && s.currentX === s.startX)
          ? (i.isScrolling = !1)
          : p * p + f * f >= 25 &&
            ((t = (180 * Math.atan2(Math.abs(f), Math.abs(p))) / Math.PI),
            (i.isScrolling = n.isHorizontal()
              ? t > r.touchAngle
              : 90 - t > r.touchAngle));
      }
      if (
        (i.isScrolling && n.emit("touchMoveOpposite", l),
        void 0 === i.startMoving &&
          ((s.currentX === s.startX && s.currentY === s.startY) ||
            (i.startMoving = !0)),
        i.isScrolling ||
          (n.zoom &&
            n.params.zoom &&
            n.params.zoom.enabled &&
            i.evCache.length > 1))
      )
        return void (i.isTouched = !1);
      if (!i.startMoving) return;
      (n.allowClick = !1),
        !r.cssMode && l.cancelable && l.preventDefault(),
        r.touchMoveStopPropagation && !r.nested && l.stopPropagation();
      let m = n.isHorizontal() ? p : f,
        g = n.isHorizontal()
          ? s.currentX - s.previousX
          : s.currentY - s.previousY;
      r.oneWayMovement &&
        ((m = Math.abs(m) * (o ? 1 : -1)), (g = Math.abs(g) * (o ? 1 : -1))),
        (s.diff = m),
        (m *= r.touchRatio),
        o && ((m = -m), (g = -g));
      const v = n.touchesDirection;
      (n.swipeDirection = m > 0 ? "prev" : "next"),
        (n.touchesDirection = g > 0 ? "prev" : "next");
      const _ = n.params.loop && !r.cssMode;
      if (!i.isMoved) {
        if (
          (_ &&
            n.loopFix({
              direction: n.swipeDirection,
            }),
          (i.startTranslate = n.getTranslate()),
          n.setTransition(0),
          n.animating)
        ) {
          const t = new window.CustomEvent("transitionend", {
            bubbles: !0,
            cancelable: !0,
          });
          n.wrapperEl.dispatchEvent(t);
        }
        (i.allowMomentumBounce = !1),
          !r.grabCursor ||
            (!0 !== n.allowSlideNext && !0 !== n.allowSlidePrev) ||
            n.setGrabCursor(!0),
          n.emit("sliderFirstMove", l);
      }
      let y;
      i.isMoved &&
        v !== n.touchesDirection &&
        _ &&
        Math.abs(m) >= 1 &&
        (n.loopFix({
          direction: n.swipeDirection,
          setTranslate: !0,
        }),
        (y = !0)),
        n.emit("sliderMove", l),
        (i.isMoved = !0),
        (i.currentTranslate = m + i.startTranslate);
      let x = !0,
        b = r.resistanceRatio;
      if (
        (r.touchReleaseOnEdges && (b = 0),
        m > 0
          ? (_ &&
              !y &&
              i.currentTranslate >
                (r.centeredSlides
                  ? n.minTranslate() - n.size / 2
                  : n.minTranslate()) &&
              n.loopFix({
                direction: "prev",
                setTranslate: !0,
                activeSlideIndex: 0,
              }),
            i.currentTranslate > n.minTranslate() &&
              ((x = !1),
              r.resistance &&
                (i.currentTranslate =
                  n.minTranslate() -
                  1 +
                  (-n.minTranslate() + i.startTranslate + m) ** b)))
          : m < 0 &&
            (_ &&
              !y &&
              i.currentTranslate <
                (r.centeredSlides
                  ? n.maxTranslate() + n.size / 2
                  : n.maxTranslate()) &&
              n.loopFix({
                direction: "next",
                setTranslate: !0,
                activeSlideIndex:
                  n.slides.length -
                  ("auto" === r.slidesPerView
                    ? n.slidesPerViewDynamic()
                    : Math.ceil(parseFloat(r.slidesPerView, 10))),
              }),
            i.currentTranslate < n.maxTranslate() &&
              ((x = !1),
              r.resistance &&
                (i.currentTranslate =
                  n.maxTranslate() +
                  1 -
                  (n.maxTranslate() - i.startTranslate - m) ** b))),
        x && (l.preventedByNestedSwiper = !0),
        !n.allowSlideNext &&
          "next" === n.swipeDirection &&
          i.currentTranslate < i.startTranslate &&
          (i.currentTranslate = i.startTranslate),
        !n.allowSlidePrev &&
          "prev" === n.swipeDirection &&
          i.currentTranslate > i.startTranslate &&
          (i.currentTranslate = i.startTranslate),
        n.allowSlidePrev ||
          n.allowSlideNext ||
          (i.currentTranslate = i.startTranslate),
        r.threshold > 0)
      ) {
        if (!(Math.abs(m) > r.threshold || i.allowThresholdMove))
          return void (i.currentTranslate = i.startTranslate);
        if (!i.allowThresholdMove)
          return (
            (i.allowThresholdMove = !0),
            (s.startX = s.currentX),
            (s.startY = s.currentY),
            (i.currentTranslate = i.startTranslate),
            void (s.diff = n.isHorizontal()
              ? s.currentX - s.startX
              : s.currentY - s.startY)
          );
      }
      r.followFinger &&
        !r.cssMode &&
        (((r.freeMode && r.freeMode.enabled && n.freeMode) ||
          r.watchSlidesProgress) &&
          (n.updateActiveIndex(), n.updateSlidesClasses()),
        n.params.freeMode &&
          r.freeMode.enabled &&
          n.freeMode &&
          n.freeMode.onTouchMove(),
        n.updateProgress(i.currentTranslate),
        n.setTranslate(i.currentTranslate));
    }
    function Xu(t) {
      const e = this,
        n = e.touchEventsData,
        i = n.evCache.findIndex((e) => e.pointerId === t.pointerId);
      if (
        (i >= 0 && n.evCache.splice(i, 1),
        ["pointercancel", "pointerout", "pointerleave"].includes(t.type))
      ) {
        if (
          !(
            "pointercancel" === t.type &&
            (e.browser.isSafari || e.browser.isWebView)
          )
        )
          return;
      }
      const {
        params: r,
        touches: s,
        rtlTranslate: o,
        slidesGrid: a,
        enabled: l,
      } = e;
      if (!l) return;
      if (!r.simulateTouch && "mouse" === t.pointerType) return;
      let c = t;
      if (
        (c.originalEvent && (c = c.originalEvent),
        n.allowTouchCallbacks && e.emit("touchEnd", c),
        (n.allowTouchCallbacks = !1),
        !n.isTouched)
      )
        return (
          n.isMoved && r.grabCursor && e.setGrabCursor(!1),
          (n.isMoved = !1),
          void (n.startMoving = !1)
        );
      r.grabCursor &&
        n.isMoved &&
        n.isTouched &&
        (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) &&
        e.setGrabCursor(!1);
      const u = Su(),
        h = u - n.touchStartTime;
      if (e.allowClick) {
        const t = c.path || (c.composedPath && c.composedPath());
        e.updateClickedSlide((t && t[0]) || c.target),
          e.emit("tap click", c),
          h < 300 &&
            u - n.lastClickTime < 300 &&
            e.emit("doubleTap doubleClick", c);
      }
      if (
        ((n.lastClickTime = Su()),
        bu(() => {
          e.destroyed || (e.allowClick = !0);
        }),
        !n.isTouched ||
          !n.isMoved ||
          !e.swipeDirection ||
          0 === s.diff ||
          n.currentTranslate === n.startTranslate)
      )
        return (n.isTouched = !1), (n.isMoved = !1), void (n.startMoving = !1);
      let d;
      if (
        ((n.isTouched = !1),
        (n.isMoved = !1),
        (n.startMoving = !1),
        (d = r.followFinger
          ? o
            ? e.translate
            : -e.translate
          : -n.currentTranslate),
        r.cssMode)
      )
        return;
      if (e.params.freeMode && r.freeMode.enabled)
        return void e.freeMode.onTouchEnd({
          currentPos: d,
        });
      let p = 0,
        f = e.slidesSizesGrid[0];
      for (
        let t = 0;
        t < a.length;
        t += t < r.slidesPerGroupSkip ? 1 : r.slidesPerGroup
      ) {
        const e = t < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
        void 0 !== a[t + e]
          ? d >= a[t] && d < a[t + e] && ((p = t), (f = a[t + e] - a[t]))
          : d >= a[t] && ((p = t), (f = a[a.length - 1] - a[a.length - 2]));
      }
      let m = null,
        g = null;
      r.rewind &&
        (e.isBeginning
          ? (g =
              e.params.virtual && e.params.virtual.enabled && e.virtual
                ? e.virtual.slides.length - 1
                : e.slides.length - 1)
          : e.isEnd && (m = 0));
      const v = (d - a[p]) / f,
        _ = p < r.slidesPerGroupSkip - 1 ? 1 : r.slidesPerGroup;
      if (h > r.longSwipesMs) {
        if (!r.longSwipes) return void e.slideTo(e.activeIndex);
        "next" === e.swipeDirection &&
          (v >= r.longSwipesRatio
            ? e.slideTo(r.rewind && e.isEnd ? m : p + _)
            : e.slideTo(p)),
          "prev" === e.swipeDirection &&
            (v > 1 - r.longSwipesRatio
              ? e.slideTo(p + _)
              : null !== g && v < 0 && Math.abs(v) > r.longSwipesRatio
              ? e.slideTo(g)
              : e.slideTo(p));
      } else {
        if (!r.shortSwipes) return void e.slideTo(e.activeIndex);
        e.navigation &&
        (c.target === e.navigation.nextEl || c.target === e.navigation.prevEl)
          ? c.target === e.navigation.nextEl
            ? e.slideTo(p + _)
            : e.slideTo(p)
          : ("next" === e.swipeDirection && e.slideTo(null !== m ? m : p + _),
            "prev" === e.swipeDirection && e.slideTo(null !== g ? g : p));
      }
    }
    function qu() {
      const t = this,
        { params: e, el: n } = t;
      if (n && 0 === n.offsetWidth) return;
      e.breakpoints && t.setBreakpoint();
      const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = t,
        o = t.virtual && t.params.virtual.enabled;
      (t.allowSlideNext = !0),
        (t.allowSlidePrev = !0),
        t.updateSize(),
        t.updateSlides(),
        t.updateSlidesClasses();
      const a = o && e.loop;
      !("auto" === e.slidesPerView || e.slidesPerView > 1) ||
      !t.isEnd ||
      t.isBeginning ||
      t.params.centeredSlides ||
      a
        ? t.params.loop && !o
          ? t.slideToLoop(t.realIndex, 0, !1, !0)
          : t.slideTo(t.activeIndex, 0, !1, !0)
        : t.slideTo(t.slides.length - 1, 0, !1, !0),
        t.autoplay &&
          t.autoplay.running &&
          t.autoplay.paused &&
          (clearTimeout(t.autoplay.resizeTimeout),
          (t.autoplay.resizeTimeout = setTimeout(() => {
            t.autoplay &&
              t.autoplay.running &&
              t.autoplay.paused &&
              t.autoplay.resume();
          }, 500))),
        (t.allowSlidePrev = r),
        (t.allowSlideNext = i),
        t.params.watchOverflow && s !== t.snapGrid && t.checkOverflow();
    }
    function Yu(t) {
      const e = this;
      e.enabled &&
        (e.allowClick ||
          (e.params.preventClicks && t.preventDefault(),
          e.params.preventClicksPropagation &&
            e.animating &&
            (t.stopPropagation(), t.stopImmediatePropagation())));
    }
    function Ku() {
      const t = this,
        { wrapperEl: e, rtlTranslate: n, enabled: i } = t;
      if (!i) return;
      let r;
      (t.previousTranslate = t.translate),
        t.isHorizontal()
          ? (t.translate = -e.scrollLeft)
          : (t.translate = -e.scrollTop),
        0 === t.translate && (t.translate = 0),
        t.updateActiveIndex(),
        t.updateSlidesClasses();
      const s = t.maxTranslate() - t.minTranslate();
      (r = 0 === s ? 0 : (t.translate - t.minTranslate()) / s),
        r !== t.progress && t.updateProgress(n ? -t.translate : t.translate),
        t.emit("setTranslate", t.translate, !1);
    }
    function Zu(t) {
      Bu(this, t.target), this.update();
    }
    let Ju = !1;
    function $u() {}
    const Qu = (t, e) => {
      const n = _u(),
        { params: i, el: r, wrapperEl: s, device: o } = t,
        a = !!i.nested,
        l = "on" === e ? "addEventListener" : "removeEventListener",
        c = e;
      r[l]("pointerdown", t.onTouchStart, {
        passive: !1,
      }),
        n[l]("pointermove", t.onTouchMove, {
          passive: !1,
          capture: a,
        }),
        n[l]("pointerup", t.onTouchEnd, {
          passive: !0,
        }),
        n[l]("pointercancel", t.onTouchEnd, {
          passive: !0,
        }),
        n[l]("pointerout", t.onTouchEnd, {
          passive: !0,
        }),
        n[l]("pointerleave", t.onTouchEnd, {
          passive: !0,
        }),
        (i.preventClicks || i.preventClicksPropagation) &&
          r[l]("click", t.onClick, !0),
        i.cssMode && s[l]("scroll", t.onScroll),
        i.updateOnWindowResize
          ? t[c](
              o.ios || o.android
                ? "resize orientationchange observerUpdate"
                : "resize observerUpdate",
              qu,
              !0
            )
          : t[c]("observerUpdate", qu, !0),
        r[l]("load", t.onLoad, {
          capture: !0,
        });
    };
    const th = (t, e) => t.grid && e.grid && e.grid.rows > 1;
    var eh = {
      init: !0,
      direction: "horizontal",
      oneWayMovement: !1,
      touchEventsTarget: "wrapper",
      initialSlide: 0,
      speed: 300,
      cssMode: !1,
      updateOnWindowResize: !0,
      resizeObserver: !0,
      nested: !1,
      createElements: !1,
      enabled: !0,
      focusableElements:
        "input, select, option, textarea, button, video, label",
      width: null,
      height: null,
      preventInteractionOnTransition: !1,
      userAgent: null,
      url: null,
      edgeSwipeDetection: !1,
      edgeSwipeThreshold: 20,
      autoHeight: !1,
      setWrapperSize: !1,
      virtualTranslate: !1,
      effect: "slide",
      breakpoints: void 0,
      breakpointsBase: "window",
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: !1,
      centeredSlides: !1,
      centeredSlidesBounds: !1,
      slidesOffsetBefore: 0,
      slidesOffsetAfter: 0,
      normalizeSlideIndex: !0,
      centerInsufficientSlides: !1,
      watchOverflow: !0,
      roundLengths: !1,
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: !0,
      shortSwipes: !0,
      longSwipes: !0,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: !0,
      allowTouchMove: !0,
      threshold: 5,
      touchMoveStopPropagation: !1,
      touchStartPreventDefault: !0,
      touchStartForcePreventDefault: !1,
      touchReleaseOnEdges: !1,
      uniqueNavElements: !0,
      resistance: !0,
      resistanceRatio: 0.85,
      watchSlidesProgress: !1,
      grabCursor: !1,
      preventClicks: !0,
      preventClicksPropagation: !0,
      slideToClickedSlide: !1,
      loop: !1,
      loopedSlides: null,
      loopPreventsSliding: !0,
      rewind: !1,
      allowSlidePrev: !0,
      allowSlideNext: !0,
      swipeHandler: null,
      noSwiping: !0,
      noSwipingClass: "swiper-no-swiping",
      noSwipingSelector: null,
      passiveListeners: !0,
      maxBackfaceHiddenSlides: 10,
      containerModifierClass: "swiper-",
      slideClass: "swiper-slide",
      slideActiveClass: "swiper-slide-active",
      slideVisibleClass: "swiper-slide-visible",
      slideNextClass: "swiper-slide-next",
      slidePrevClass: "swiper-slide-prev",
      wrapperClass: "swiper-wrapper",
      lazyPreloaderClass: "swiper-lazy-preloader",
      lazyPreloadPrevNext: 0,
      runCallbacksOnInit: !0,
      _emitClasses: !1,
    };
    function nh(t, e) {
      return function (n = {}) {
        const i = Object.keys(n)[0],
          r = n[i];
        "object" == typeof r && null !== r
          ? (["navigation", "pagination", "scrollbar"].indexOf(i) >= 0 &&
              !0 === t[i] &&
              (t[i] = {
                auto: !0,
              }),
            i in t && "enabled" in r
              ? (!0 === t[i] &&
                  (t[i] = {
                    enabled: !0,
                  }),
                "object" != typeof t[i] ||
                  "enabled" in t[i] ||
                  (t[i].enabled = !0),
                t[i] ||
                  (t[i] = {
                    enabled: !1,
                  }),
                Tu(e, n))
              : Tu(e, n))
          : Tu(e, n);
      };
    }
    const ih = {
        eventsEmitter: {
          on(t, e, n) {
            const i = this;
            if (!i.eventsListeners || i.destroyed) return i;
            if ("function" != typeof e) return i;
            const r = n ? "unshift" : "push";
            return (
              t.split(" ").forEach((t) => {
                i.eventsListeners[t] || (i.eventsListeners[t] = []),
                  i.eventsListeners[t][r](e);
              }),
              i
            );
          },
          once(t, e, n) {
            const i = this;
            if (!i.eventsListeners || i.destroyed) return i;
            if ("function" != typeof e) return i;
            function r(...n) {
              i.off(t, r),
                r.__emitterProxy && delete r.__emitterProxy,
                e.apply(i, n);
            }
            return (r.__emitterProxy = e), i.on(t, r, n);
          },
          onAny(t, e) {
            const n = this;
            if (!n.eventsListeners || n.destroyed) return n;
            if ("function" != typeof t) return n;
            const i = e ? "unshift" : "push";
            return (
              n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[i](t),
              n
            );
          },
          offAny(t) {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsAnyListeners) return e;
            const n = e.eventsAnyListeners.indexOf(t);
            return n >= 0 && e.eventsAnyListeners.splice(n, 1), e;
          },
          off(t, e) {
            const n = this;
            return !n.eventsListeners || n.destroyed
              ? n
              : n.eventsListeners
              ? (t.split(" ").forEach((t) => {
                  void 0 === e
                    ? (n.eventsListeners[t] = [])
                    : n.eventsListeners[t] &&
                      n.eventsListeners[t].forEach((i, r) => {
                        (i === e ||
                          (i.__emitterProxy && i.__emitterProxy === e)) &&
                          n.eventsListeners[t].splice(r, 1);
                      });
                }),
                n)
              : n;
          },
          emit(...t) {
            const e = this;
            if (!e.eventsListeners || e.destroyed) return e;
            if (!e.eventsListeners) return e;
            let n, i, r;
            "string" == typeof t[0] || Array.isArray(t[0])
              ? ((n = t[0]), (i = t.slice(1, t.length)), (r = e))
              : ((n = t[0].events), (i = t[0].data), (r = t[0].context || e)),
              i.unshift(r);
            return (
              (Array.isArray(n) ? n : n.split(" ")).forEach((t) => {
                e.eventsAnyListeners &&
                  e.eventsAnyListeners.length &&
                  e.eventsAnyListeners.forEach((e) => {
                    e.apply(r, [t, ...i]);
                  }),
                  e.eventsListeners &&
                    e.eventsListeners[t] &&
                    e.eventsListeners[t].forEach((t) => {
                      t.apply(r, i);
                    });
              }),
              e
            );
          },
        },
        update: {
          updateSize: function () {
            const t = this;
            let e, n;
            const i = t.el;
            (e =
              void 0 !== t.params.width && null !== t.params.width
                ? t.params.width
                : i.clientWidth),
              (n =
                void 0 !== t.params.height && null !== t.params.height
                  ? t.params.height
                  : i.clientHeight),
              (0 === e && t.isHorizontal()) ||
                (0 === n && t.isVertical()) ||
                ((e =
                  e -
                  parseInt(Pu(i, "padding-left") || 0, 10) -
                  parseInt(Pu(i, "padding-right") || 0, 10)),
                (n =
                  n -
                  parseInt(Pu(i, "padding-top") || 0, 10) -
                  parseInt(Pu(i, "padding-bottom") || 0, 10)),
                Number.isNaN(e) && (e = 0),
                Number.isNaN(n) && (n = 0),
                Object.assign(t, {
                  width: e,
                  height: n,
                  size: t.isHorizontal() ? e : n,
                }));
          },
          updateSlides: function () {
            const t = this;
            function e(e) {
              return t.isHorizontal()
                ? e
                : {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom",
                  }[e];
            }
            function n(t, n) {
              return parseFloat(t.getPropertyValue(e(n)) || 0);
            }
            const i = t.params,
              {
                wrapperEl: r,
                slidesEl: s,
                size: o,
                rtlTranslate: a,
                wrongRTL: l,
              } = t,
              c = t.virtual && i.virtual.enabled,
              u = c ? t.virtual.slides.length : t.slides.length,
              h = Au(s, `.${t.params.slideClass}, swiper-slide`),
              d = c ? t.virtual.slides.length : h.length;
            let p = [];
            const f = [],
              m = [];
            let g = i.slidesOffsetBefore;
            "function" == typeof g && (g = i.slidesOffsetBefore.call(t));
            let v = i.slidesOffsetAfter;
            "function" == typeof v && (v = i.slidesOffsetAfter.call(t));
            const _ = t.snapGrid.length,
              y = t.slidesGrid.length;
            let x = i.spaceBetween,
              b = -g,
              S = 0,
              E = 0;
            if (void 0 === o) return;
            "string" == typeof x && x.indexOf("%") >= 0
              ? (x = (parseFloat(x.replace("%", "")) / 100) * o)
              : "string" == typeof x && (x = parseFloat(x)),
              (t.virtualSize = -x),
              h.forEach((t) => {
                a ? (t.style.marginLeft = "") : (t.style.marginRight = ""),
                  (t.style.marginBottom = ""),
                  (t.style.marginTop = "");
              }),
              i.centeredSlides &&
                i.cssMode &&
                (wu(r, "--swiper-centered-offset-before", ""),
                wu(r, "--swiper-centered-offset-after", ""));
            const M = i.grid && i.grid.rows > 1 && t.grid;
            let T;
            M && t.grid.initSlides(d);
            const w =
              "auto" === i.slidesPerView &&
              i.breakpoints &&
              Object.keys(i.breakpoints).filter(
                (t) => void 0 !== i.breakpoints[t].slidesPerView
              ).length > 0;
            for (let r = 0; r < d; r += 1) {
              let s;
              if (
                ((T = 0),
                h[r] && (s = h[r]),
                M && t.grid.updateSlide(r, s, d, e),
                !h[r] || "none" !== Pu(s, "display"))
              ) {
                if ("auto" === i.slidesPerView) {
                  w && (h[r].style[e("width")] = "");
                  const o = getComputedStyle(s),
                    a = s.style.transform,
                    l = s.style.webkitTransform;
                  if (
                    (a && (s.style.transform = "none"),
                    l && (s.style.webkitTransform = "none"),
                    i.roundLengths)
                  )
                    T = t.isHorizontal()
                      ? Ou(s, "width", !0)
                      : Ou(s, "height", !0);
                  else {
                    const t = n(o, "width"),
                      e = n(o, "padding-left"),
                      i = n(o, "padding-right"),
                      r = n(o, "margin-left"),
                      a = n(o, "margin-right"),
                      l = o.getPropertyValue("box-sizing");
                    if (l && "border-box" === l) T = t + r + a;
                    else {
                      const { clientWidth: n, offsetWidth: o } = s;
                      T = t + e + i + r + a + (o - n);
                    }
                  }
                  a && (s.style.transform = a),
                    l && (s.style.webkitTransform = l),
                    i.roundLengths && (T = Math.floor(T));
                } else
                  (T = (o - (i.slidesPerView - 1) * x) / i.slidesPerView),
                    i.roundLengths && (T = Math.floor(T)),
                    h[r] && (h[r].style[e("width")] = T + "px");
                h[r] && (h[r].swiperSlideSize = T),
                  m.push(T),
                  i.centeredSlides
                    ? ((b = b + T / 2 + S / 2 + x),
                      0 === S && 0 !== r && (b = b - o / 2 - x),
                      0 === r && (b = b - o / 2 - x),
                      Math.abs(b) < 0.001 && (b = 0),
                      i.roundLengths && (b = Math.floor(b)),
                      E % i.slidesPerGroup == 0 && p.push(b),
                      f.push(b))
                    : (i.roundLengths && (b = Math.floor(b)),
                      (E - Math.min(t.params.slidesPerGroupSkip, E)) %
                        t.params.slidesPerGroup ==
                        0 && p.push(b),
                      f.push(b),
                      (b = b + T + x)),
                  (t.virtualSize += T + x),
                  (S = T),
                  (E += 1);
              }
            }
            if (
              ((t.virtualSize = Math.max(t.virtualSize, o) + v),
              a &&
                l &&
                ("slide" === i.effect || "coverflow" === i.effect) &&
                (r.style.width = t.virtualSize + x + "px"),
              i.setWrapperSize &&
                (r.style[e("width")] = t.virtualSize + x + "px"),
              M && t.grid.updateWrapperSize(T, p, e),
              !i.centeredSlides)
            ) {
              const e = [];
              for (let n = 0; n < p.length; n += 1) {
                let r = p[n];
                i.roundLengths && (r = Math.floor(r)),
                  p[n] <= t.virtualSize - o && e.push(r);
              }
              (p = e),
                Math.floor(t.virtualSize - o) - Math.floor(p[p.length - 1]) >
                  1 && p.push(t.virtualSize - o);
            }
            if (c && i.loop) {
              const e = m[0] + x;
              if (i.slidesPerGroup > 1) {
                const n = Math.ceil(
                    (t.virtual.slidesBefore + t.virtual.slidesAfter) /
                      i.slidesPerGroup
                  ),
                  r = e * i.slidesPerGroup;
                for (let t = 0; t < n; t += 1) p.push(p[p.length - 1] + r);
              }
              for (
                let n = 0;
                n < t.virtual.slidesBefore + t.virtual.slidesAfter;
                n += 1
              )
                1 === i.slidesPerGroup && p.push(p[p.length - 1] + e),
                  f.push(f[f.length - 1] + e),
                  (t.virtualSize += e);
            }
            if ((0 === p.length && (p = [0]), 0 !== x)) {
              const n = t.isHorizontal() && a ? "marginLeft" : e("marginRight");
              h.filter(
                (t, e) => !(i.cssMode && !i.loop) || e !== h.length - 1
              ).forEach((t) => {
                t.style[n] = x + "px";
              });
            }
            if (i.centeredSlides && i.centeredSlidesBounds) {
              let t = 0;
              m.forEach((e) => {
                t += e + (x || 0);
              }),
                (t -= x);
              const e = t - o;
              p = p.map((t) => (t < 0 ? -g : t > e ? e + v : t));
            }
            if (i.centerInsufficientSlides) {
              let t = 0;
              if (
                (m.forEach((e) => {
                  t += e + (x || 0);
                }),
                (t -= x),
                t < o)
              ) {
                const e = (o - t) / 2;
                p.forEach((t, n) => {
                  p[n] = t - e;
                }),
                  f.forEach((t, n) => {
                    f[n] = t + e;
                  });
              }
            }
            if (
              (Object.assign(t, {
                slides: h,
                snapGrid: p,
                slidesGrid: f,
                slidesSizesGrid: m,
              }),
              i.centeredSlides && i.cssMode && !i.centeredSlidesBounds)
            ) {
              wu(r, "--swiper-centered-offset-before", -p[0] + "px"),
                wu(
                  r,
                  "--swiper-centered-offset-after",
                  t.size / 2 - m[m.length - 1] / 2 + "px"
                );
              const e = -t.snapGrid[0],
                n = -t.slidesGrid[0];
              (t.snapGrid = t.snapGrid.map((t) => t + e)),
                (t.slidesGrid = t.slidesGrid.map((t) => t + n));
            }
            if (
              (d !== u && t.emit("slidesLengthChange"),
              p.length !== _ &&
                (t.params.watchOverflow && t.checkOverflow(),
                t.emit("snapGridLengthChange")),
              f.length !== y && t.emit("slidesGridLengthChange"),
              i.watchSlidesProgress && t.updateSlidesOffset(),
              !(
                c ||
                i.cssMode ||
                ("slide" !== i.effect && "fade" !== i.effect)
              ))
            ) {
              const e = i.containerModifierClass + "backface-hidden",
                n = t.el.classList.contains(e);
              d <= i.maxBackfaceHiddenSlides
                ? n || t.el.classList.add(e)
                : n && t.el.classList.remove(e);
            }
          },
          updateAutoHeight: function (t) {
            const e = this,
              n = [],
              i = e.virtual && e.params.virtual.enabled;
            let r,
              s = 0;
            "number" == typeof t
              ? e.setTransition(t)
              : !0 === t && e.setTransition(e.params.speed);
            const o = (t) =>
              i ? e.slides[e.getSlideIndexByData(t)] : e.slides[t];
            if ("auto" !== e.params.slidesPerView && e.params.slidesPerView > 1)
              if (e.params.centeredSlides)
                (e.visibleSlides || []).forEach((t) => {
                  n.push(t);
                });
              else
                for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
                  const t = e.activeIndex + r;
                  if (t > e.slides.length && !i) break;
                  n.push(o(t));
                }
            else n.push(o(e.activeIndex));
            for (r = 0; r < n.length; r += 1)
              if (void 0 !== n[r]) {
                const t = n[r].offsetHeight;
                s = t > s ? t : s;
              }
            (s || 0 === s) && (e.wrapperEl.style.height = s + "px");
          },
          updateSlidesOffset: function () {
            const t = this,
              e = t.slides,
              n = t.isElement
                ? t.isHorizontal()
                  ? t.wrapperEl.offsetLeft
                  : t.wrapperEl.offsetTop
                : 0;
            for (let i = 0; i < e.length; i += 1)
              e[i].swiperSlideOffset =
                (t.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) -
                n -
                t.cssOverflowAdjustment();
          },
          updateSlidesProgress: function (t = (this && this.translate) || 0) {
            const e = this,
              n = e.params,
              { slides: i, rtlTranslate: r, snapGrid: s } = e;
            if (0 === i.length) return;
            void 0 === i[0].swiperSlideOffset && e.updateSlidesOffset();
            let o = -t;
            r && (o = t),
              i.forEach((t) => {
                t.classList.remove(n.slideVisibleClass);
              }),
              (e.visibleSlidesIndexes = []),
              (e.visibleSlides = []);
            let a = n.spaceBetween;
            "string" == typeof a && a.indexOf("%") >= 0
              ? (a = (parseFloat(a.replace("%", "")) / 100) * e.size)
              : "string" == typeof a && (a = parseFloat(a));
            for (let t = 0; t < i.length; t += 1) {
              const l = i[t];
              let c = l.swiperSlideOffset;
              n.cssMode && n.centeredSlides && (c -= i[0].swiperSlideOffset);
              const u =
                  (o + (n.centeredSlides ? e.minTranslate() : 0) - c) /
                  (l.swiperSlideSize + a),
                h =
                  (o - s[0] + (n.centeredSlides ? e.minTranslate() : 0) - c) /
                  (l.swiperSlideSize + a),
                d = -(o - c),
                p = d + e.slidesSizesGrid[t];
              ((d >= 0 && d < e.size - 1) ||
                (p > 1 && p <= e.size) ||
                (d <= 0 && p >= e.size)) &&
                (e.visibleSlides.push(l),
                e.visibleSlidesIndexes.push(t),
                i[t].classList.add(n.slideVisibleClass)),
                (l.progress = r ? -u : u),
                (l.originalProgress = r ? -h : h);
            }
          },
          updateProgress: function (t) {
            const e = this;
            if (void 0 === t) {
              const n = e.rtlTranslate ? -1 : 1;
              t = (e && e.translate && e.translate * n) || 0;
            }
            const n = e.params,
              i = e.maxTranslate() - e.minTranslate();
            let { progress: r, isBeginning: s, isEnd: o, progressLoop: a } = e;
            const l = s,
              c = o;
            if (0 === i) (r = 0), (s = !0), (o = !0);
            else {
              r = (t - e.minTranslate()) / i;
              const n = Math.abs(t - e.minTranslate()) < 1,
                a = Math.abs(t - e.maxTranslate()) < 1;
              (s = n || r <= 0), (o = a || r >= 1), n && (r = 0), a && (r = 1);
            }
            if (n.loop) {
              const n = e.getSlideIndexByData(0),
                i = e.getSlideIndexByData(e.slides.length - 1),
                r = e.slidesGrid[n],
                s = e.slidesGrid[i],
                o = e.slidesGrid[e.slidesGrid.length - 1],
                l = Math.abs(t);
              (a = l >= r ? (l - r) / o : (l + o - s) / o), a > 1 && (a -= 1);
            }
            Object.assign(e, {
              progress: r,
              progressLoop: a,
              isBeginning: s,
              isEnd: o,
            }),
              (n.watchSlidesProgress || (n.centeredSlides && n.autoHeight)) &&
                e.updateSlidesProgress(t),
              s && !l && e.emit("reachBeginning toEdge"),
              o && !c && e.emit("reachEnd toEdge"),
              ((l && !s) || (c && !o)) && e.emit("fromEdge"),
              e.emit("progress", r);
          },
          updateSlidesClasses: function () {
            const t = this,
              { slides: e, params: n, slidesEl: i, activeIndex: r } = t,
              s = t.virtual && n.virtual.enabled,
              o = (t) => Au(i, `.${n.slideClass}${t}, swiper-slide ${t}`)[0];
            let a;
            if (
              (e.forEach((t) => {
                t.classList.remove(
                  n.slideActiveClass,
                  n.slideNextClass,
                  n.slidePrevClass
                );
              }),
              s)
            )
              if (n.loop) {
                let e = r - t.virtual.slidesBefore;
                e < 0 && (e = t.virtual.slides.length + e),
                  e >= t.virtual.slides.length &&
                    (e -= t.virtual.slides.length),
                  (a = o(`[data-swiper-slide-index="${e}"]`));
              } else a = o(`[data-swiper-slide-index="${r}"]`);
            else a = e[r];
            if (a) {
              a.classList.add(n.slideActiveClass);
              let t = (function (t, e) {
                const n = [];
                for (; t.nextElementSibling; ) {
                  const i = t.nextElementSibling;
                  e ? i.matches(e) && n.push(i) : n.push(i), (t = i);
                }
                return n;
              })(a, `.${n.slideClass}, swiper-slide`)[0];
              n.loop && !t && (t = e[0]),
                t && t.classList.add(n.slideNextClass);
              let i = (function (t, e) {
                const n = [];
                for (; t.previousElementSibling; ) {
                  const i = t.previousElementSibling;
                  e ? i.matches(e) && n.push(i) : n.push(i), (t = i);
                }
                return n;
              })(a, `.${n.slideClass}, swiper-slide`)[0];
              n.loop && 0 === !i && (i = e[e.length - 1]),
                i && i.classList.add(n.slidePrevClass);
            }
            t.emitSlidesClasses();
          },
          updateActiveIndex: function (t) {
            const e = this,
              n = e.rtlTranslate ? e.translate : -e.translate,
              {
                snapGrid: i,
                params: r,
                activeIndex: s,
                realIndex: o,
                snapIndex: a,
              } = e;
            let l,
              c = t;
            const u = (t) => {
              let n = t - e.virtual.slidesBefore;
              return (
                n < 0 && (n = e.virtual.slides.length + n),
                n >= e.virtual.slides.length && (n -= e.virtual.slides.length),
                n
              );
            };
            if (
              (void 0 === c &&
                (c = (function (t) {
                  const { slidesGrid: e, params: n } = t,
                    i = t.rtlTranslate ? t.translate : -t.translate;
                  let r;
                  for (let t = 0; t < e.length; t += 1)
                    void 0 !== e[t + 1]
                      ? i >= e[t] && i < e[t + 1] - (e[t + 1] - e[t]) / 2
                        ? (r = t)
                        : i >= e[t] && i < e[t + 1] && (r = t + 1)
                      : i >= e[t] && (r = t);
                  return (
                    n.normalizeSlideIndex && (r < 0 || void 0 === r) && (r = 0),
                    r
                  );
                })(e)),
              i.indexOf(n) >= 0)
            )
              l = i.indexOf(n);
            else {
              const t = Math.min(r.slidesPerGroupSkip, c);
              l = t + Math.floor((c - t) / r.slidesPerGroup);
            }
            if ((l >= i.length && (l = i.length - 1), c === s))
              return (
                l !== a && ((e.snapIndex = l), e.emit("snapIndexChange")),
                void (
                  e.params.loop &&
                  e.virtual &&
                  e.params.virtual.enabled &&
                  (e.realIndex = u(c))
                )
              );
            let h;
            (h =
              e.virtual && r.virtual.enabled && r.loop
                ? u(c)
                : e.slides[c]
                ? parseInt(
                    e.slides[c].getAttribute("data-swiper-slide-index") || c,
                    10
                  )
                : c),
              Object.assign(e, {
                previousSnapIndex: a,
                snapIndex: l,
                previousRealIndex: o,
                realIndex: h,
                previousIndex: s,
                activeIndex: c,
              }),
              e.initialized && Vu(e),
              e.emit("activeIndexChange"),
              e.emit("snapIndexChange"),
              o !== h && e.emit("realIndexChange"),
              (e.initialized || e.params.runCallbacksOnInit) &&
                e.emit("slideChange");
          },
          updateClickedSlide: function (t) {
            const e = this,
              n = e.params,
              i = t.closest(`.${n.slideClass}, swiper-slide`);
            let r,
              s = !1;
            if (i)
              for (let t = 0; t < e.slides.length; t += 1)
                if (e.slides[t] === i) {
                  (s = !0), (r = t);
                  break;
                }
            if (!i || !s)
              return (e.clickedSlide = void 0), void (e.clickedIndex = void 0);
            (e.clickedSlide = i),
              e.virtual && e.params.virtual.enabled
                ? (e.clickedIndex = parseInt(
                    i.getAttribute("data-swiper-slide-index"),
                    10
                  ))
                : (e.clickedIndex = r),
              n.slideToClickedSlide &&
                void 0 !== e.clickedIndex &&
                e.clickedIndex !== e.activeIndex &&
                e.slideToClickedSlide();
          },
        },
        translate: {
          getTranslate: function (t = this.isHorizontal() ? "x" : "y") {
            const {
              params: e,
              rtlTranslate: n,
              translate: i,
              wrapperEl: r,
            } = this;
            if (e.virtualTranslate) return n ? -i : i;
            if (e.cssMode) return i;
            let s = Eu(r, t);
            return (s += this.cssOverflowAdjustment()), n && (s = -s), s || 0;
          },
          setTranslate: function (t, e) {
            const n = this,
              { rtlTranslate: i, params: r, wrapperEl: s, progress: o } = n;
            let a,
              l = 0,
              c = 0;
            n.isHorizontal() ? (l = i ? -t : t) : (c = t),
              r.roundLengths && ((l = Math.floor(l)), (c = Math.floor(c))),
              (n.previousTranslate = n.translate),
              (n.translate = n.isHorizontal() ? l : c),
              r.cssMode
                ? (s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] =
                    n.isHorizontal() ? -l : -c)
                : r.virtualTranslate ||
                  (n.isHorizontal()
                    ? (l -= n.cssOverflowAdjustment())
                    : (c -= n.cssOverflowAdjustment()),
                  (s.style.transform = `translate3d(${l}px, ${c}px, 0px)`));
            const u = n.maxTranslate() - n.minTranslate();
            (a = 0 === u ? 0 : (t - n.minTranslate()) / u),
              a !== o && n.updateProgress(t),
              n.emit("setTranslate", n.translate, e);
          },
          minTranslate: function () {
            return -this.snapGrid[0];
          },
          maxTranslate: function () {
            return -this.snapGrid[this.snapGrid.length - 1];
          },
          translateTo: function (
            t = 0,
            e = this.params.speed,
            n = !0,
            i = !0,
            r
          ) {
            const s = this,
              { params: o, wrapperEl: a } = s;
            if (s.animating && o.preventInteractionOnTransition) return !1;
            const l = s.minTranslate(),
              c = s.maxTranslate();
            let u;
            if (
              ((u = i && t > l ? l : i && t < c ? c : t),
              s.updateProgress(u),
              o.cssMode)
            ) {
              const t = s.isHorizontal();
              if (0 === e) a[t ? "scrollLeft" : "scrollTop"] = -u;
              else {
                if (!s.support.smoothScroll)
                  return (
                    Du({
                      swiper: s,
                      targetPosition: -u,
                      side: t ? "left" : "top",
                    }),
                    !0
                  );
                a.scrollTo({
                  [t ? "left" : "top"]: -u,
                  behavior: "smooth",
                });
              }
              return !0;
            }
            return (
              0 === e
                ? (s.setTransition(0),
                  s.setTranslate(u),
                  n &&
                    (s.emit("beforeTransitionStart", e, r),
                    s.emit("transitionEnd")))
                : (s.setTransition(e),
                  s.setTranslate(u),
                  n &&
                    (s.emit("beforeTransitionStart", e, r),
                    s.emit("transitionStart")),
                  s.animating ||
                    ((s.animating = !0),
                    s.onTranslateToWrapperTransitionEnd ||
                      (s.onTranslateToWrapperTransitionEnd = function (t) {
                        s &&
                          !s.destroyed &&
                          t.target === this &&
                          (s.wrapperEl.removeEventListener(
                            "transitionend",
                            s.onTranslateToWrapperTransitionEnd
                          ),
                          (s.onTranslateToWrapperTransitionEnd = null),
                          delete s.onTranslateToWrapperTransitionEnd,
                          n && s.emit("transitionEnd"));
                      }),
                    s.wrapperEl.addEventListener(
                      "transitionend",
                      s.onTranslateToWrapperTransitionEnd
                    ))),
              !0
            );
          },
        },
        transition: {
          setTransition: function (t, e) {
            const n = this;
            n.params.cssMode ||
              (n.wrapperEl.style.transitionDuration = t + "ms"),
              n.emit("setTransition", t, e);
          },
          transitionStart: function (t = !0, e) {
            const n = this,
              { params: i } = n;
            i.cssMode ||
              (i.autoHeight && n.updateAutoHeight(),
              Gu({
                swiper: n,
                runCallbacks: t,
                direction: e,
                step: "Start",
              }));
          },
          transitionEnd: function (t = !0, e) {
            const { params: n } = this;
            (this.animating = !1),
              n.cssMode ||
                (this.setTransition(0),
                Gu({
                  swiper: this,
                  runCallbacks: t,
                  direction: e,
                  step: "End",
                }));
          },
        },
        slide: {
          slideTo: function (t = 0, e = this.params.speed, n = !0, i, r) {
            "string" == typeof t && (t = parseInt(t, 10));
            const s = this;
            let o = t;
            o < 0 && (o = 0);
            const {
              params: a,
              snapGrid: l,
              slidesGrid: c,
              previousIndex: u,
              activeIndex: h,
              rtlTranslate: d,
              wrapperEl: p,
              enabled: f,
            } = s;
            if (
              (s.animating && a.preventInteractionOnTransition) ||
              (!f && !i && !r)
            )
              return !1;
            const m = Math.min(s.params.slidesPerGroupSkip, o);
            let g = m + Math.floor((o - m) / s.params.slidesPerGroup);
            g >= l.length && (g = l.length - 1);
            const v = -l[g];
            if (a.normalizeSlideIndex)
              for (let t = 0; t < c.length; t += 1) {
                const e = -Math.floor(100 * v),
                  n = Math.floor(100 * c[t]),
                  i = Math.floor(100 * c[t + 1]);
                void 0 !== c[t + 1]
                  ? e >= n && e < i - (i - n) / 2
                    ? (o = t)
                    : e >= n && e < i && (o = t + 1)
                  : e >= n && (o = t);
              }
            if (s.initialized && o !== h) {
              if (!s.allowSlideNext && v < s.translate && v < s.minTranslate())
                return !1;
              if (
                !s.allowSlidePrev &&
                v > s.translate &&
                v > s.maxTranslate() &&
                (h || 0) !== o
              )
                return !1;
            }
            let _;
            if (
              (o !== (u || 0) && n && s.emit("beforeSlideChangeStart"),
              s.updateProgress(v),
              (_ = o > h ? "next" : o < h ? "prev" : "reset"),
              (d && -v === s.translate) || (!d && v === s.translate))
            )
              return (
                s.updateActiveIndex(o),
                a.autoHeight && s.updateAutoHeight(),
                s.updateSlidesClasses(),
                "slide" !== a.effect && s.setTranslate(v),
                "reset" !== _ &&
                  (s.transitionStart(n, _), s.transitionEnd(n, _)),
                !1
              );
            if (a.cssMode) {
              const t = s.isHorizontal(),
                n = d ? v : -v;
              if (0 === e) {
                const e = s.virtual && s.params.virtual.enabled;
                e &&
                  ((s.wrapperEl.style.scrollSnapType = "none"),
                  (s._immediateVirtual = !0)),
                  e && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0
                    ? ((s._cssModeVirtualInitialSet = !0),
                      requestAnimationFrame(() => {
                        p[t ? "scrollLeft" : "scrollTop"] = n;
                      }))
                    : (p[t ? "scrollLeft" : "scrollTop"] = n),
                  e &&
                    requestAnimationFrame(() => {
                      (s.wrapperEl.style.scrollSnapType = ""),
                        (s._immediateVirtual = !1);
                    });
              } else {
                if (!s.support.smoothScroll)
                  return (
                    Du({
                      swiper: s,
                      targetPosition: n,
                      side: t ? "left" : "top",
                    }),
                    !0
                  );
                p.scrollTo({
                  [t ? "left" : "top"]: n,
                  behavior: "smooth",
                });
              }
              return !0;
            }
            return (
              s.setTransition(e),
              s.setTranslate(v),
              s.updateActiveIndex(o),
              s.updateSlidesClasses(),
              s.emit("beforeTransitionStart", e, i),
              s.transitionStart(n, _),
              0 === e
                ? s.transitionEnd(n, _)
                : s.animating ||
                  ((s.animating = !0),
                  s.onSlideToWrapperTransitionEnd ||
                    (s.onSlideToWrapperTransitionEnd = function (t) {
                      s &&
                        !s.destroyed &&
                        t.target === this &&
                        (s.wrapperEl.removeEventListener(
                          "transitionend",
                          s.onSlideToWrapperTransitionEnd
                        ),
                        (s.onSlideToWrapperTransitionEnd = null),
                        delete s.onSlideToWrapperTransitionEnd,
                        s.transitionEnd(n, _));
                    }),
                  s.wrapperEl.addEventListener(
                    "transitionend",
                    s.onSlideToWrapperTransitionEnd
                  )),
              !0
            );
          },
          slideToLoop: function (t = 0, e = this.params.speed, n = !0, i) {
            if ("string" == typeof t) {
              t = parseInt(t, 10);
            }
            const r = this;
            let s = t;
            return (
              r.params.loop &&
                (r.virtual && r.params.virtual.enabled
                  ? (s += r.virtual.slidesBefore)
                  : (s = r.getSlideIndexByData(s))),
              r.slideTo(s, e, n, i)
            );
          },
          slideNext: function (t = this.params.speed, e = !0, n) {
            const i = this,
              { enabled: r, params: s, animating: o } = i;
            if (!r) return i;
            let a = s.slidesPerGroup;
            "auto" === s.slidesPerView &&
              1 === s.slidesPerGroup &&
              s.slidesPerGroupAuto &&
              (a = Math.max(i.slidesPerViewDynamic("current", !0), 1));
            const l = i.activeIndex < s.slidesPerGroupSkip ? 1 : a,
              c = i.virtual && s.virtual.enabled;
            if (s.loop) {
              if (o && !c && s.loopPreventsSliding) return !1;
              i.loopFix({
                direction: "next",
              }),
                (i._clientLeft = i.wrapperEl.clientLeft);
            }
            return s.rewind && i.isEnd
              ? i.slideTo(0, t, e, n)
              : i.slideTo(i.activeIndex + l, t, e, n);
          },
          slidePrev: function (t = this.params.speed, e = !0, n) {
            const i = this,
              {
                params: r,
                snapGrid: s,
                slidesGrid: o,
                rtlTranslate: a,
                enabled: l,
                animating: c,
              } = i;
            if (!l) return i;
            const u = i.virtual && r.virtual.enabled;
            if (r.loop) {
              if (c && !u && r.loopPreventsSliding) return !1;
              i.loopFix({
                direction: "prev",
              }),
                (i._clientLeft = i.wrapperEl.clientLeft);
            }
            function h(t) {
              return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t);
            }
            const d = h(a ? i.translate : -i.translate),
              p = s.map((t) => h(t));
            let f = s[p.indexOf(d) - 1];
            if (void 0 === f && r.cssMode) {
              let t;
              s.forEach((e, n) => {
                d >= e && (t = n);
              }),
                void 0 !== t && (f = s[t > 0 ? t - 1 : t]);
            }
            let m = 0;
            if (
              (void 0 !== f &&
                ((m = o.indexOf(f)),
                m < 0 && (m = i.activeIndex - 1),
                "auto" === r.slidesPerView &&
                  1 === r.slidesPerGroup &&
                  r.slidesPerGroupAuto &&
                  ((m = m - i.slidesPerViewDynamic("previous", !0) + 1),
                  (m = Math.max(m, 0)))),
              r.rewind && i.isBeginning)
            ) {
              const r =
                i.params.virtual && i.params.virtual.enabled && i.virtual
                  ? i.virtual.slides.length - 1
                  : i.slides.length - 1;
              return i.slideTo(r, t, e, n);
            }
            return i.slideTo(m, t, e, n);
          },
          slideReset: function (t = this.params.speed, e = !0, n) {
            return this.slideTo(this.activeIndex, t, e, n);
          },
          slideToClosest: function (t = this.params.speed, e = !0, n, i = 0.5) {
            const r = this;
            let s = r.activeIndex;
            const o = Math.min(r.params.slidesPerGroupSkip, s),
              a = o + Math.floor((s - o) / r.params.slidesPerGroup),
              l = r.rtlTranslate ? r.translate : -r.translate;
            if (l >= r.snapGrid[a]) {
              const t = r.snapGrid[a];
              l - t > (r.snapGrid[a + 1] - t) * i &&
                (s += r.params.slidesPerGroup);
            } else {
              const t = r.snapGrid[a - 1];
              l - t <= (r.snapGrid[a] - t) * i &&
                (s -= r.params.slidesPerGroup);
            }
            return (
              (s = Math.max(s, 0)),
              (s = Math.min(s, r.slidesGrid.length - 1)),
              r.slideTo(s, t, e, n)
            );
          },
          slideToClickedSlide: function () {
            const t = this,
              { params: e, slidesEl: n } = t,
              i =
                "auto" === e.slidesPerView
                  ? t.slidesPerViewDynamic()
                  : e.slidesPerView;
            let r,
              s = t.clickedIndex;
            const o = t.isElement ? "swiper-slide" : "." + e.slideClass;
            if (e.loop) {
              if (t.animating) return;
              (r = parseInt(
                t.clickedSlide.getAttribute("data-swiper-slide-index"),
                10
              )),
                e.centeredSlides
                  ? s < t.loopedSlides - i / 2 ||
                    s > t.slides.length - t.loopedSlides + i / 2
                    ? (t.loopFix(),
                      (s = t.getSlideIndex(
                        Au(n, `${o}[data-swiper-slide-index="${r}"]`)[0]
                      )),
                      bu(() => {
                        t.slideTo(s);
                      }))
                    : t.slideTo(s)
                  : s > t.slides.length - i
                  ? (t.loopFix(),
                    (s = t.getSlideIndex(
                      Au(n, `${o}[data-swiper-slide-index="${r}"]`)[0]
                    )),
                    bu(() => {
                      t.slideTo(s);
                    }))
                  : t.slideTo(s);
            } else t.slideTo(s);
          },
        },
        loop: {
          loopCreate: function (t) {
            const { params: e, slidesEl: n } = this;
            if (!e.loop || (this.virtual && this.params.virtual.enabled))
              return;
            Au(n, `.${e.slideClass}, swiper-slide`).forEach((t, e) => {
              t.setAttribute("data-swiper-slide-index", e);
            }),
              this.loopFix({
                slideRealIndex: t,
                direction: e.centeredSlides ? void 0 : "next",
              });
          },
          loopFix: function ({
            slideRealIndex: t,
            slideTo: e = !0,
            direction: n,
            setTranslate: i,
            activeSlideIndex: r,
            byController: s,
            byMousewheel: o,
          } = {}) {
            const a = this;
            if (!a.params.loop) return;
            a.emit("beforeLoopFix");
            const {
              slides: l,
              allowSlidePrev: c,
              allowSlideNext: u,
              slidesEl: h,
              params: d,
            } = a;
            if (
              ((a.allowSlidePrev = !0),
              (a.allowSlideNext = !0),
              a.virtual && d.virtual.enabled)
            )
              return (
                e &&
                  (d.centeredSlides || 0 !== a.snapIndex
                    ? d.centeredSlides && a.snapIndex < d.slidesPerView
                      ? a.slideTo(
                          a.virtual.slides.length + a.snapIndex,
                          0,
                          !1,
                          !0
                        )
                      : a.snapIndex === a.snapGrid.length - 1 &&
                        a.slideTo(a.virtual.slidesBefore, 0, !1, !0)
                    : a.slideTo(a.virtual.slides.length, 0, !1, !0)),
                (a.allowSlidePrev = c),
                (a.allowSlideNext = u),
                void a.emit("loopFix")
              );
            const p =
              "auto" === d.slidesPerView
                ? a.slidesPerViewDynamic()
                : Math.ceil(parseFloat(d.slidesPerView, 10));
            let f = d.loopedSlides || p;
            f % d.slidesPerGroup != 0 &&
              (f += d.slidesPerGroup - (f % d.slidesPerGroup)),
              (a.loopedSlides = f);
            const m = [],
              g = [];
            let v = a.activeIndex;
            void 0 === r
              ? (r = a.getSlideIndex(
                  a.slides.filter((t) =>
                    t.classList.contains(d.slideActiveClass)
                  )[0]
                ))
              : (v = r);
            const _ = "next" === n || !n,
              y = "prev" === n || !n;
            let x = 0,
              b = 0;
            if (r < f) {
              x = Math.max(f - r, d.slidesPerGroup);
              for (let t = 0; t < f - r; t += 1) {
                const e = t - Math.floor(t / l.length) * l.length;
                m.push(l.length - e - 1);
              }
            } else if (r > a.slides.length - 2 * f) {
              b = Math.max(r - (a.slides.length - 2 * f), d.slidesPerGroup);
              for (let t = 0; t < b; t += 1) {
                const e = t - Math.floor(t / l.length) * l.length;
                g.push(e);
              }
            }
            if (
              (y &&
                m.forEach((t) => {
                  (a.slides[t].swiperLoopMoveDOM = !0),
                    h.prepend(a.slides[t]),
                    (a.slides[t].swiperLoopMoveDOM = !1);
                }),
              _ &&
                g.forEach((t) => {
                  (a.slides[t].swiperLoopMoveDOM = !0),
                    h.append(a.slides[t]),
                    (a.slides[t].swiperLoopMoveDOM = !1);
                }),
              a.recalcSlides(),
              "auto" === d.slidesPerView && a.updateSlides(),
              d.watchSlidesProgress && a.updateSlidesOffset(),
              e)
            )
              if (m.length > 0 && y)
                if (void 0 === t) {
                  const t = a.slidesGrid[v],
                    e = a.slidesGrid[v + x] - t;
                  o
                    ? a.setTranslate(a.translate - e)
                    : (a.slideTo(v + x, 0, !1, !0),
                      i &&
                        (a.touches[a.isHorizontal() ? "startX" : "startY"] +=
                          e));
                } else i && a.slideToLoop(t, 0, !1, !0);
              else if (g.length > 0 && _)
                if (void 0 === t) {
                  const t = a.slidesGrid[v],
                    e = a.slidesGrid[v - b] - t;
                  o
                    ? a.setTranslate(a.translate - e)
                    : (a.slideTo(v - b, 0, !1, !0),
                      i &&
                        (a.touches[a.isHorizontal() ? "startX" : "startY"] +=
                          e));
                } else a.slideToLoop(t, 0, !1, !0);
            if (
              ((a.allowSlidePrev = c),
              (a.allowSlideNext = u),
              a.controller && a.controller.control && !s)
            ) {
              const e = {
                slideRealIndex: t,
                slideTo: !1,
                direction: n,
                setTranslate: i,
                activeSlideIndex: r,
                byController: !0,
              };
              Array.isArray(a.controller.control)
                ? a.controller.control.forEach((t) => {
                    !t.destroyed && t.params.loop && t.loopFix(e);
                  })
                : a.controller.control instanceof a.constructor &&
                  a.controller.control.params.loop &&
                  a.controller.control.loopFix(e);
            }
            a.emit("loopFix");
          },
          loopDestroy: function () {
            const { params: t, slidesEl: e } = this;
            if (!t.loop || (this.virtual && this.params.virtual.enabled))
              return;
            this.recalcSlides();
            const n = [];
            this.slides.forEach((t) => {
              const e =
                void 0 === t.swiperSlideIndex
                  ? 1 * t.getAttribute("data-swiper-slide-index")
                  : t.swiperSlideIndex;
              n[e] = t;
            }),
              this.slides.forEach((t) => {
                t.removeAttribute("data-swiper-slide-index");
              }),
              n.forEach((t) => {
                e.append(t);
              }),
              this.recalcSlides(),
              this.slideTo(this.realIndex, 0);
          },
        },
        grabCursor: {
          setGrabCursor: function (t) {
            const e = this;
            if (
              !e.params.simulateTouch ||
              (e.params.watchOverflow && e.isLocked) ||
              e.params.cssMode
            )
              return;
            const n =
              "container" === e.params.touchEventsTarget ? e.el : e.wrapperEl;
            e.isElement && (e.__preventObserver__ = !0),
              (n.style.cursor = "move"),
              (n.style.cursor = t ? "grabbing" : "grab"),
              e.isElement &&
                requestAnimationFrame(() => {
                  e.__preventObserver__ = !1;
                });
          },
          unsetGrabCursor: function () {
            const t = this;
            (t.params.watchOverflow && t.isLocked) ||
              t.params.cssMode ||
              (t.isElement && (t.__preventObserver__ = !0),
              (t[
                "container" === t.params.touchEventsTarget ? "el" : "wrapperEl"
              ].style.cursor = ""),
              t.isElement &&
                requestAnimationFrame(() => {
                  t.__preventObserver__ = !1;
                }));
          },
        },
        events: {
          attachEvents: function () {
            const t = this,
              e = _u(),
              { params: n } = t;
            (t.onTouchStart = Wu.bind(t)),
              (t.onTouchMove = ju.bind(t)),
              (t.onTouchEnd = Xu.bind(t)),
              n.cssMode && (t.onScroll = Ku.bind(t)),
              (t.onClick = Yu.bind(t)),
              (t.onLoad = Zu.bind(t)),
              Ju || (e.addEventListener("touchstart", $u), (Ju = !0)),
              Qu(t, "on");
          },
          detachEvents: function () {
            Qu(this, "off");
          },
        },
        breakpoints: {
          setBreakpoint: function () {
            const t = this,
              { realIndex: e, initialized: n, params: i, el: r } = t,
              s = i.breakpoints;
            if (!s || (s && 0 === Object.keys(s).length)) return;
            const o = t.getBreakpoint(s, t.params.breakpointsBase, t.el);
            if (!o || t.currentBreakpoint === o) return;
            const a = (o in s ? s[o] : void 0) || t.originalParams,
              l = th(t, i),
              c = th(t, a),
              u = i.enabled;
            l && !c
              ? (r.classList.remove(
                  i.containerModifierClass + "grid",
                  i.containerModifierClass + "grid-column"
                ),
                t.emitContainerClasses())
              : !l &&
                c &&
                (r.classList.add(i.containerModifierClass + "grid"),
                ((a.grid.fill && "column" === a.grid.fill) ||
                  (!a.grid.fill && "column" === i.grid.fill)) &&
                  r.classList.add(i.containerModifierClass + "grid-column"),
                t.emitContainerClasses()),
              ["navigation", "pagination", "scrollbar"].forEach((e) => {
                const n = i[e] && i[e].enabled,
                  r = a[e] && a[e].enabled;
                n && !r && t[e].disable(), !n && r && t[e].enable();
              });
            const h = a.direction && a.direction !== i.direction,
              d = i.loop && (a.slidesPerView !== i.slidesPerView || h);
            h && n && t.changeDirection(), Tu(t.params, a);
            const p = t.params.enabled;
            Object.assign(t, {
              allowTouchMove: t.params.allowTouchMove,
              allowSlideNext: t.params.allowSlideNext,
              allowSlidePrev: t.params.allowSlidePrev,
            }),
              u && !p ? t.disable() : !u && p && t.enable(),
              (t.currentBreakpoint = o),
              t.emit("_beforeBreakpoint", a),
              d && n && (t.loopDestroy(), t.loopCreate(e), t.updateSlides()),
              t.emit("breakpoint", a);
          },
          getBreakpoint: function (t, e = "window", n) {
            if (!t || ("container" === e && !n)) return;
            let i = !1;
            const r = xu(),
              s = "window" === e ? r.innerHeight : n.clientHeight,
              o = Object.keys(t).map((t) => {
                if ("string" == typeof t && 0 === t.indexOf("@")) {
                  const e = parseFloat(t.substr(1));
                  return {
                    value: s * e,
                    point: t,
                  };
                }
                return {
                  value: t,
                  point: t,
                };
              });
            o.sort((t, e) => parseInt(t.value, 10) - parseInt(e.value, 10));
            for (let t = 0; t < o.length; t += 1) {
              const { point: s, value: a } = o[t];
              "window" === e
                ? r.matchMedia(`(min-width: ${a}px)`).matches && (i = s)
                : a <= n.clientWidth && (i = s);
            }
            return i || "max";
          },
        },
        checkOverflow: {
          checkOverflow: function () {
            const t = this,
              { isLocked: e, params: n } = t,
              { slidesOffsetBefore: i } = n;
            if (i) {
              const e = t.slides.length - 1,
                n = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * i;
              t.isLocked = t.size > n;
            } else t.isLocked = 1 === t.snapGrid.length;
            !0 === n.allowSlideNext && (t.allowSlideNext = !t.isLocked),
              !0 === n.allowSlidePrev && (t.allowSlidePrev = !t.isLocked),
              e && e !== t.isLocked && (t.isEnd = !1),
              e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock");
          },
        },
        classes: {
          addClasses: function () {
            const { classNames: t, params: e, rtl: n, el: i, device: r } = this,
              s = (function (t, e) {
                const n = [];
                return (
                  t.forEach((t) => {
                    "object" == typeof t
                      ? Object.keys(t).forEach((i) => {
                          t[i] && n.push(e + i);
                        })
                      : "string" == typeof t && n.push(e + t);
                  }),
                  n
                );
              })(
                [
                  "initialized",
                  e.direction,
                  {
                    "free-mode": this.params.freeMode && e.freeMode.enabled,
                  },
                  {
                    autoheight: e.autoHeight,
                  },
                  {
                    rtl: n,
                  },
                  {
                    grid: e.grid && e.grid.rows > 1,
                  },
                  {
                    "grid-column":
                      e.grid && e.grid.rows > 1 && "column" === e.grid.fill,
                  },
                  {
                    android: r.android,
                  },
                  {
                    ios: r.ios,
                  },
                  {
                    "css-mode": e.cssMode,
                  },
                  {
                    centered: e.cssMode && e.centeredSlides,
                  },
                  {
                    "watch-progress": e.watchSlidesProgress,
                  },
                ],
                e.containerModifierClass
              );
            t.push(...s), i.classList.add(...t), this.emitContainerClasses();
          },
          removeClasses: function () {
            const { el: t, classNames: e } = this;
            t.classList.remove(...e), this.emitContainerClasses();
          },
        },
      },
      rh = {};
    class sh {
      constructor(...t) {
        let e, n;
        1 === t.length &&
        t[0].constructor &&
        "Object" === Object.prototype.toString.call(t[0]).slice(8, -1)
          ? (n = t[0])
          : ([e, n] = t),
          n || (n = {}),
          (n = Tu({}, n)),
          e && !n.el && (n.el = e);
        const i = _u();
        if (
          n.el &&
          "string" == typeof n.el &&
          i.querySelectorAll(n.el).length > 1
        ) {
          const t = [];
          return (
            i.querySelectorAll(n.el).forEach((e) => {
              const i = Tu({}, n, {
                el: e,
              });
              t.push(new sh(i));
            }),
            t
          );
        }
        const r = this;
        (r.__swiper__ = !0),
          (r.support = Nu()),
          (r.device = ku({
            userAgent: n.userAgent,
          })),
          (r.browser = zu()),
          (r.eventsListeners = {}),
          (r.eventsAnyListeners = []),
          (r.modules = [...r.__modules__]),
          n.modules && Array.isArray(n.modules) && r.modules.push(...n.modules);
        const s = {};
        r.modules.forEach((t) => {
          t({
            params: n,
            swiper: r,
            extendParams: nh(n, s),
            on: r.on.bind(r),
            once: r.once.bind(r),
            off: r.off.bind(r),
            emit: r.emit.bind(r),
          });
        });
        const o = Tu({}, eh, s);
        return (
          (r.params = Tu({}, o, rh, n)),
          (r.originalParams = Tu({}, r.params)),
          (r.passedParams = Tu({}, n)),
          r.params &&
            r.params.on &&
            Object.keys(r.params.on).forEach((t) => {
              r.on(t, r.params.on[t]);
            }),
          r.params && r.params.onAny && r.onAny(r.params.onAny),
          Object.assign(r, {
            enabled: r.params.enabled,
            el: e,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal: () => "horizontal" === r.params.direction,
            isVertical: () => "vertical" === r.params.direction,
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
              return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
            },
            allowSlideNext: r.params.allowSlideNext,
            allowSlidePrev: r.params.allowSlidePrev,
            touchEventsData: {
              isTouched: void 0,
              isMoved: void 0,
              allowTouchCallbacks: void 0,
              touchStartTime: void 0,
              isScrolling: void 0,
              currentTranslate: void 0,
              startTranslate: void 0,
              allowThresholdMove: void 0,
              focusableElements: r.params.focusableElements,
              lastClickTime: 0,
              clickTimeout: void 0,
              velocities: [],
              allowMomentumBounce: void 0,
              startMoving: void 0,
              evCache: [],
            },
            allowClick: !0,
            allowTouchMove: r.params.allowTouchMove,
            touches: {
              startX: 0,
              startY: 0,
              currentX: 0,
              currentY: 0,
              diff: 0,
            },
            imagesToLoad: [],
            imagesLoaded: 0,
          }),
          r.emit("_swiper"),
          r.params.init && r.init(),
          r
        );
      }
      getSlideIndex(t) {
        const { slidesEl: e, params: n } = this,
          i = Ru(Au(e, `.${n.slideClass}, swiper-slide`)[0]);
        return Ru(t) - i;
      }
      getSlideIndexByData(t) {
        return this.getSlideIndex(
          this.slides.filter(
            (e) => 1 * e.getAttribute("data-swiper-slide-index") === t
          )[0]
        );
      }
      recalcSlides() {
        const { slidesEl: t, params: e } = this;
        this.slides = Au(t, `.${e.slideClass}, swiper-slide`);
      }
      enable() {
        const t = this;
        t.enabled ||
          ((t.enabled = !0),
          t.params.grabCursor && t.setGrabCursor(),
          t.emit("enable"));
      }
      disable() {
        const t = this;
        t.enabled &&
          ((t.enabled = !1),
          t.params.grabCursor && t.unsetGrabCursor(),
          t.emit("disable"));
      }
      setProgress(t, e) {
        t = Math.min(Math.max(t, 0), 1);
        const n = this.minTranslate(),
          i = (this.maxTranslate() - n) * t + n;
        this.translateTo(i, void 0 === e ? 0 : e),
          this.updateActiveIndex(),
          this.updateSlidesClasses();
      }
      emitContainerClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el) return;
        const e = t.el.className
          .split(" ")
          .filter(
            (e) =>
              0 === e.indexOf("swiper") ||
              0 === e.indexOf(t.params.containerModifierClass)
          );
        t.emit("_containerClasses", e.join(" "));
      }
      getSlideClasses(t) {
        const e = this;
        return e.destroyed
          ? ""
          : t.className
              .split(" ")
              .filter(
                (t) =>
                  0 === t.indexOf("swiper-slide") ||
                  0 === t.indexOf(e.params.slideClass)
              )
              .join(" ");
      }
      emitSlidesClasses() {
        const t = this;
        if (!t.params._emitClasses || !t.el) return;
        const e = [];
        t.slides.forEach((n) => {
          const i = t.getSlideClasses(n);
          e.push({
            slideEl: n,
            classNames: i,
          }),
            t.emit("_slideClass", n, i);
        }),
          t.emit("_slideClasses", e);
      }
      slidesPerViewDynamic(t = "current", e = !1) {
        const {
          params: n,
          slides: i,
          slidesGrid: r,
          slidesSizesGrid: s,
          size: o,
          activeIndex: a,
        } = this;
        let l = 1;
        if (n.centeredSlides) {
          let t,
            e = i[a].swiperSlideSize;
          for (let n = a + 1; n < i.length; n += 1)
            i[n] &&
              !t &&
              ((e += i[n].swiperSlideSize), (l += 1), e > o && (t = !0));
          for (let n = a - 1; n >= 0; n -= 1)
            i[n] &&
              !t &&
              ((e += i[n].swiperSlideSize), (l += 1), e > o && (t = !0));
        } else if ("current" === t)
          for (let t = a + 1; t < i.length; t += 1) {
            (e ? r[t] + s[t] - r[a] < o : r[t] - r[a] < o) && (l += 1);
          }
        else
          for (let t = a - 1; t >= 0; t -= 1) {
            r[a] - r[t] < o && (l += 1);
          }
        return l;
      }
      update() {
        const t = this;
        if (!t || t.destroyed) return;
        const { snapGrid: e, params: n } = t;
        function i() {
          const e = t.rtlTranslate ? -1 * t.translate : t.translate,
            n = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
          t.setTranslate(n), t.updateActiveIndex(), t.updateSlidesClasses();
        }
        let r;
        if (
          (n.breakpoints && t.setBreakpoint(),
          [...t.el.querySelectorAll('[loading="lazy"]')].forEach((e) => {
            e.complete && Bu(t, e);
          }),
          t.updateSize(),
          t.updateSlides(),
          t.updateProgress(),
          t.updateSlidesClasses(),
          t.params.freeMode && t.params.freeMode.enabled)
        )
          i(), t.params.autoHeight && t.updateAutoHeight();
        else {
          if (
            ("auto" === t.params.slidesPerView || t.params.slidesPerView > 1) &&
            t.isEnd &&
            !t.params.centeredSlides
          ) {
            const e =
              t.virtual && t.params.virtual.enabled
                ? t.virtual.slides
                : t.slides;
            r = t.slideTo(e.length - 1, 0, !1, !0);
          } else r = t.slideTo(t.activeIndex, 0, !1, !0);
          r || i();
        }
        n.watchOverflow && e !== t.snapGrid && t.checkOverflow(),
          t.emit("update");
      }
      changeDirection(t, e = !0) {
        const n = this,
          i = n.params.direction;
        return (
          t || (t = "horizontal" === i ? "vertical" : "horizontal"),
          t === i ||
            ("horizontal" !== t && "vertical" !== t) ||
            (n.el.classList.remove(`${n.params.containerModifierClass}${i}`),
            n.el.classList.add(`${n.params.containerModifierClass}${t}`),
            n.emitContainerClasses(),
            (n.params.direction = t),
            n.slides.forEach((e) => {
              "vertical" === t ? (e.style.width = "") : (e.style.height = "");
            }),
            n.emit("changeDirection"),
            e && n.update()),
          n
        );
      }
      changeLanguageDirection(t) {
        const e = this;
        (e.rtl && "rtl" === t) ||
          (!e.rtl && "ltr" === t) ||
          ((e.rtl = "rtl" === t),
          (e.rtlTranslate = "horizontal" === e.params.direction && e.rtl),
          e.rtl
            ? (e.el.classList.add(e.params.containerModifierClass + "rtl"),
              (e.el.dir = "rtl"))
            : (e.el.classList.remove(e.params.containerModifierClass + "rtl"),
              (e.el.dir = "ltr")),
          e.update());
      }
      mount(t) {
        const e = this;
        if (e.mounted) return !0;
        let n = t || e.params.el;
        if (("string" == typeof n && (n = document.querySelector(n)), !n))
          return !1;
        (n.swiper = e), n.shadowEl && (e.isElement = !0);
        const i = () =>
          "." + (e.params.wrapperClass || "").trim().split(" ").join(".");
        let r = (() => {
          if (n && n.shadowRoot && n.shadowRoot.querySelector) {
            return n.shadowRoot.querySelector(i());
          }
          return Au(n, i())[0];
        })();
        return (
          !r &&
            e.params.createElements &&
            ((r = Cu("div", e.params.wrapperClass)),
            n.append(r),
            Au(n, "." + e.params.slideClass).forEach((t) => {
              r.append(t);
            })),
          Object.assign(e, {
            el: n,
            wrapperEl: r,
            slidesEl: e.isElement ? n : r,
            mounted: !0,
            rtl: "rtl" === n.dir.toLowerCase() || "rtl" === Pu(n, "direction"),
            rtlTranslate:
              "horizontal" === e.params.direction &&
              ("rtl" === n.dir.toLowerCase() || "rtl" === Pu(n, "direction")),
            wrongRTL: "-webkit-box" === Pu(r, "display"),
          }),
          !0
        );
      }
      init(t) {
        const e = this;
        if (e.initialized) return e;
        return (
          !1 === e.mount(t) ||
            (e.emit("beforeInit"),
            e.params.breakpoints && e.setBreakpoint(),
            e.addClasses(),
            e.updateSize(),
            e.updateSlides(),
            e.params.watchOverflow && e.checkOverflow(),
            e.params.grabCursor && e.enabled && e.setGrabCursor(),
            e.params.loop && e.virtual && e.params.virtual.enabled
              ? e.slideTo(
                  e.params.initialSlide + e.virtual.slidesBefore,
                  0,
                  e.params.runCallbacksOnInit,
                  !1,
                  !0
                )
              : e.slideTo(
                  e.params.initialSlide,
                  0,
                  e.params.runCallbacksOnInit,
                  !1,
                  !0
                ),
            e.params.loop && e.loopCreate(),
            e.attachEvents(),
            [...e.el.querySelectorAll('[loading="lazy"]')].forEach((t) => {
              t.complete
                ? Bu(e, t)
                : t.addEventListener("load", (t) => {
                    Bu(e, t.target);
                  });
            }),
            Vu(e),
            (e.initialized = !0),
            Vu(e),
            e.emit("init"),
            e.emit("afterInit")),
          e
        );
      }
      destroy(t = !0, e = !0) {
        const n = this,
          { params: i, el: r, wrapperEl: s, slides: o } = n;
        return (
          void 0 === n.params ||
            n.destroyed ||
            (n.emit("beforeDestroy"),
            (n.initialized = !1),
            n.detachEvents(),
            i.loop && n.loopDestroy(),
            e &&
              (n.removeClasses(),
              r.removeAttribute("style"),
              s.removeAttribute("style"),
              o &&
                o.length &&
                o.forEach((t) => {
                  t.classList.remove(
                    i.slideVisibleClass,
                    i.slideActiveClass,
                    i.slideNextClass,
                    i.slidePrevClass
                  ),
                    t.removeAttribute("style"),
                    t.removeAttribute("data-swiper-slide-index");
                })),
            n.emit("destroy"),
            Object.keys(n.eventsListeners).forEach((t) => {
              n.off(t);
            }),
            !1 !== t &&
              ((n.el.swiper = null),
              (function (t) {
                const e = t;
                Object.keys(e).forEach((t) => {
                  try {
                    e[t] = null;
                  } catch (t) {}
                  try {
                    delete e[t];
                  } catch (t) {}
                });
              })(n)),
            (n.destroyed = !0)),
          null
        );
      }
      static extendDefaults(t) {
        Tu(rh, t);
      }
      static get extendedDefaults() {
        return rh;
      }
      static get defaults() {
        return eh;
      }
      static installModule(t) {
        sh.prototype.__modules__ || (sh.prototype.__modules__ = []);
        const e = sh.prototype.__modules__;
        "function" == typeof t && e.indexOf(t) < 0 && e.push(t);
      }
      static use(t) {
        return Array.isArray(t)
          ? (t.forEach((t) => sh.installModule(t)), sh)
          : (sh.installModule(t), sh);
      }
    }
    Object.keys(ih).forEach((t) => {
      Object.keys(ih[t]).forEach((e) => {
        sh.prototype[e] = ih[t][e];
      });
    }),
      sh.use([
        function ({ swiper: t, on: e, emit: n }) {
          const i = xu();
          let r = null,
            s = null;
          const o = () => {
              t &&
                !t.destroyed &&
                t.initialized &&
                (n("beforeResize"), n("resize"));
            },
            a = () => {
              t && !t.destroyed && t.initialized && n("orientationchange");
            };
          e("init", () => {
            t.params.resizeObserver && void 0 !== i.ResizeObserver
              ? t &&
                !t.destroyed &&
                t.initialized &&
                ((r = new ResizeObserver((e) => {
                  s = i.requestAnimationFrame(() => {
                    const { width: n, height: i } = t;
                    let r = n,
                      s = i;
                    e.forEach(
                      ({ contentBoxSize: e, contentRect: n, target: i }) => {
                        (i && i !== t.el) ||
                          ((r = n ? n.width : (e[0] || e).inlineSize),
                          (s = n ? n.height : (e[0] || e).blockSize));
                      }
                    ),
                      (r === n && s === i) || o();
                  });
                })),
                r.observe(t.el))
              : (i.addEventListener("resize", o),
                i.addEventListener("orientationchange", a));
          }),
            e("destroy", () => {
              s && i.cancelAnimationFrame(s),
                r && r.unobserve && t.el && (r.unobserve(t.el), (r = null)),
                i.removeEventListener("resize", o),
                i.removeEventListener("orientationchange", a);
            });
        },
        function ({ swiper: t, extendParams: e, on: n, emit: i }) {
          const r = [],
            s = xu(),
            o = (e, n = {}) => {
              const o = new (s.MutationObserver || s.WebkitMutationObserver)(
                (e) => {
                  if (t.__preventObserver__) return;
                  if (1 === e.length) return void i("observerUpdate", e[0]);
                  const n = function () {
                    i("observerUpdate", e[0]);
                  };
                  s.requestAnimationFrame
                    ? s.requestAnimationFrame(n)
                    : s.setTimeout(n, 0);
                }
              );
              o.observe(e, {
                attributes: void 0 === n.attributes || n.attributes,
                childList: void 0 === n.childList || n.childList,
                characterData: void 0 === n.characterData || n.characterData,
              }),
                r.push(o);
            };
          e({
            observer: !1,
            observeParents: !1,
            observeSlideChildren: !1,
          }),
            n("init", () => {
              if (t.params.observer) {
                if (t.params.observeParents) {
                  const e = Lu(t.el);
                  for (let t = 0; t < e.length; t += 1) o(e[t]);
                }
                o(t.el, {
                  childList: t.params.observeSlideChildren,
                }),
                  o(t.wrapperEl, {
                    attributes: !1,
                  });
              }
            }),
            n("destroy", () => {
              r.forEach((t) => {
                t.disconnect();
              }),
                r.splice(0, r.length);
            });
        },
      ]);
    var oh = sh;
    function ah() {
      return (ah =
        Object.assign ||
        function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var i in n)
              Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
          }
          return t;
        }).apply(this, arguments);
    }
    function lh(t, e) {
      (t.prototype = Object.create(e.prototype)),
        (t.prototype.constructor = t),
        ch(t, e);
    }
    function ch(t, e) {
      return (ch =
        Object.setPrototypeOf ||
        function (t, e) {
          return (t.__proto__ = e), t;
        })(t, e);
    }
    var uh = (function () {
        function t() {
          this.events = {};
        }
        var e = t.prototype;
        return (
          (e.on = function (t, e) {
            this.events[t] instanceof Array || (this.events[t] = []),
              this.events[t].push(e);
          }),
          (e.off = function (t, e) {
            this.events[t] = e
              ? this.events[t].filter(function (t) {
                  return t !== e;
                })
              : [];
          }),
          (e.trigger = function (t) {
            var e = arguments,
              n = this;
            this.events[t] &&
              this.events[t].forEach(function (t) {
                return t.call.apply(t, [n, n].concat([].slice.call(e, 1)));
              });
          }),
          t
        );
      })(),
      hh = (function (t) {
        function e(n) {
          var i;
          return (
            ((i = t.call(this) || this).options = ah({}, e.defaultOptions, n)),
            (i.container =
              "string" == typeof i.options.container
                ? document.querySelector(i.options.container)
                : i.options.container),
            (i.wrapper =
              "string" == typeof i.options.wrapper
                ? i.container.querySelector(i.options.wrapper)
                : i.options.wrapper || i.options.container),
            (i.item = []),
            i.refresh(!1),
            i.options.autoUpdate ? i.bindResizeObserver() : i.update(),
            i
          );
        }
        lh(e, t);
        var n = e.prototype;
        return (
          (n.bindResizeObserver = function () {
            var t = this;
            (this.resizeObserver = new ResizeObserver(function () {
              t.update();
            })),
              this.resizeObserver.observe(this.container);
          }),
          (n.addClones = function (t, e) {
            var n;
            void 0 === e && (e = 0);
            for (var i = [], r = 0; r < t; r++) {
              var s = this.item[(e + r) % this.item.length].cloneNode(!0);
              s.classList.add(this.options.cloneClassName), i.push(s);
            }
            (n = this.wrapper).append.apply(n, i);
          }),
          (n.removeClones = function (t) {
            void 0 === t && (t = 0),
              Array.from(
                this.wrapper.getElementsByClassName(this.options.cloneClassName)
              )
                .slice(-t)
                .forEach(function (t) {
                  return t.remove();
                });
          }),
          (n.setClonesCount = function (t) {
            this.clonesCount !== t &&
              (this.clonesCount < t &&
                this.addClones(t - this.clonesCount, this.clonesCount),
              this.clonesCount > t && this.removeClones(this.clonesCount - t),
              (this.clonesCount = t));
          }),
          (n.getCalcData = function () {
            var t = {
              clonesCount: 0,
              clonesWidth: 0,
              containerWidth: this.container.offsetWidth,
              fullWidth: 0,
              itemWidth: [],
              itemsWidth: 0,
              lastIndex: 0,
            };
            this.item.map(function (e) {
              var n = e.getBoundingClientRect(),
                i = window.getComputedStyle(e),
                r = n.width + parseInt(i.marginLeft) + parseInt(i.marginRight);
              t.itemWidth.push(r), (t.itemsWidth += r);
            });
            for (
              var e = t.itemWidth.length,
                n = this.options.clonesOverflow
                  ? t.containerWidth
                  : t.containerWidth - t.itemsWidth;
              n > t.clonesWidth ||
              t.clonesCount < this.options.clonesMin ||
              (this.options.clonesFinish && t.clonesCount % e > 0);

            )
              (t.lastIndex = t.clonesCount % e),
                (t.clonesWidth += t.itemWidth[t.lastIndex]),
                t.clonesCount++;
            return (t.fullWidth = t.clonesWidth + t.itemsWidth), t;
          }),
          (n.update = function () {
            (this.calcData = this.getCalcData()),
              this.setClonesCount(this.calcData.clonesCount),
              this.trigger("update", this.calcData);
          }),
          (n.refresh = function (t) {
            void 0 === t && (t = !0),
              this.removeClones(),
              (this.item = Array.from(
                this.container.querySelectorAll(this.options.itemSelector)
              )),
              (this.calcData = {}),
              (this.clonesCount = 0),
              this.trigger("refresh"),
              t && this.update();
          }),
          (n.destroy = function (t) {
            void 0 === t && (t = !1),
              t && this.removeClones(),
              this.resizeObserver && this.resizeObserver.disconnect(),
              this.trigger("destroy");
          }),
          e
        );
      })(uh);
    hh.defaultOptions = {
      container: null,
      wrapper: null,
      itemSelector: null,
      cloneClassName: "-clone",
      autoUpdate: !0,
      clonesOverflow: !1,
      clonesFinish: !1,
      clonesMin: 0,
    };
    var dh = (function (t) {
      function e(n) {
        var i;
        return (
          ((i = t.call(this) || this).options = ah({}, e.defaultOptions, n)),
          (i.gsap = e.gsap || window.gsap),
          (i.paused = i.options.paused),
          i.createFiller(),
          i.createTimeline(),
          i.options.autoStop && i.bindIntersectionObserver(),
          i.options.plugins && i.initPlugins(),
          i
        );
      }
      lh(e, t),
        (e.registerGSAP = function (t) {
          e.gsap = t;
        }),
        (e.use = function () {
          [].slice.call(arguments).forEach(function (t) {
            var n = t.pluginName;
            if ("string" != typeof n)
              throw new TypeError("Invalid plugin. Name is required.");
            e.plugins[n] = t;
          });
        });
      var n = e.prototype;
      return (
        (n.createFiller = function () {
          var t = this;
          (this.filler = new hh(this.options)),
            this.filler.on("update", function (e, n) {
              t.invalidate(), t.trigger("update", n);
            }),
            this.filler.on("refresh", function () {
              t.trigger("refresh");
            });
        }),
        (n.createTimeline = function () {
          var t = this;
          return (
            (this.tl = new this.gsap.timeline({
              paused: this.options.paused,
              repeat: -1,
              yoyo: !this.options.loop,
              onReverseComplete: function () {
                this.progress(1);
              },
            })),
            this.gsap.set(this.filler.container, {
              overflow: "hidden",
            }),
            this.tl.fromTo(
              this.filler.wrapper,
              {
                x: function () {
                  return t.options.clonesOverflow
                    ? -t.filler.calcData.itemsWidth
                    : -(
                        t.filler.calcData.fullWidth -
                        t.filler.calcData.containerWidth
                      );
                },
              },
              {
                x: 0,
                duration: this.options.speed,
                ease: this.options.ease,
              }
            ),
            this.tl.seek(this.options.seek),
            this.tl
          );
        }),
        (n.bindIntersectionObserver = function () {
          var t = this;
          (this.intersectionObserver = new IntersectionObserver(function (e) {
            e[0].isIntersecting ? t.resume() : t.pause();
          })),
            this.intersectionObserver.observe(this.filler.container);
        }),
        (n.initPlugins = function () {
          this.plugin = {};
          for (
            var t = 0, n = Object.entries(this.options.plugins);
            t < n.length;
            t++
          ) {
            var i = n[t],
              r = i[0],
              s = i[1],
              o = e.plugins[r];
            o
              ? (this.plugin[r] = new o(this, s))
              : console.error(
                  "Plugin " +
                    r +
                    " not found. Make sure you register it with Reeller.use()"
                );
          }
        }),
        (n.destroyPlugins = function () {
          for (var t = 0, e = Object.values(this.plugin); t < e.length; t++) {
            var n = e[t];
            n.destroy && n.destroy();
          }
        }),
        (n.resume = function () {
          this.gsap.set(this.filler.container, {
            z: "0",
          }),
            this.gsap.set(this.filler.wrapper, {
              willChange: "transform",
            }),
            (this.paused = !1),
            this.tl.resume(),
            this.trigger("resume");
        }),
        (n.reverse = function () {
          (this.paused = !1), this.tl.reverse(), this.trigger("reverse");
        }),
        (n.pause = function () {
          this.gsap.set(this.filler.container, {
            clearProps: "z",
          }),
            this.gsap.set(this.filler.wrapper, {
              willChange: "auto",
            }),
            (this.paused = !0),
            this.tl.pause(),
            this.trigger("pause");
        }),
        (n.invalidate = function () {
          this.tl.invalidate(), this.trigger("invalidate");
        }),
        (n.update = function () {
          this.filler.update();
        }),
        (n.refresh = function (t) {
          void 0 === t && (t = !0), this.filler.refresh(t);
        }),
        (n.destroy = function (t, e) {
          void 0 === t && (t = !1),
            void 0 === e && (e = !1),
            this.intersectionObserver && this.intersectionObserver.disconnect(),
            this.options.plugins && this.destroyPlugins(),
            this.tl.kill(),
            this.filler.destroy(t),
            e &&
              (this.gsap.set(this.filler.container, {
                clearProps: "overflow",
              }),
              this.gsap.set(this.filler.wrapper, {
                clearProps: "x,willChange",
              })),
            this.trigger("destroy");
        }),
        e
      );
    })(uh);
    (dh.defaultOptions = {
      container: null,
      wrapper: null,
      itemSelector: null,
      cloneClassName: "-clone",
      speed: 10,
      ease: "none",
      initialSeek: 10,
      loop: !0,
      paused: !0,
      reversed: !1,
      autoStop: !0,
      autoUpdate: !0,
      clonesOverflow: !0,
      clonesFinish: !1,
      clonesMin: 0,
      plugins: null,
    }),
      (dh.plugins = {});
    var ph = (function () {
      function t(e, n) {
        (this.options = ah({}, t.defaultOptions, n)),
          (this.reeller = e),
          (this.gsap = this.reeller.gsap),
          (this.tl = this.reeller.tl),
          this.init();
      }
      var e = t.prototype;
      return (
        (e.getScrollPos = function () {
          return this.options.scrollProxy
            ? this.options.scrollProxy()
            : window.pageYOffset;
        }),
        (e.init = function () {
          var t = this,
            e = this.getScrollPos(),
            n = 1,
            i = !0;
          (this.tickerFn = function () {
            var r = t.getScrollPos(),
              s = r - e;
            if (
              (t.options.bothDirection || (s = Math.abs(s)),
              t.options.reversed && (s *= -1),
              t.reeller.paused)
            )
              return (
                (n = Math.sign(s)),
                (e = r),
                i || (t.gsap.killTweensOf(t.tl), (i = !0)),
                void t.tl.timeScale(n * t.options.threshold)
              );
            if (s) {
              var o = s * t.options.multiplier,
                a =
                  o > 0
                    ? Math.max(t.options.threshold, o)
                    : Math.min(-t.options.threshold, o);
              (t.tween = t.gsap.to(t.tl, {
                timeScale: a,
                duration: t.options.speed,
                ease: t.options.ease,
                overwrite: t.options.overwrite,
              })),
                (i = !1);
            } else if (!i) {
              var l = t.options.stopOnEnd ? 0 : n * t.options.threshold;
              t.gsap.killTweensOf(t.tl),
                (t.tween = t.gsap.to(t.tl, {
                  timeScale: l,
                  duration: t.options.speed,
                  overwrite: t.options.overwrite,
                  ease: t.options.ease,
                })),
                (i = !0);
            }
            (n = Math.sign(s)), (e = r);
          }),
            this.gsap.ticker.add(this.tickerFn);
        }),
        (e.destroy = function () {
          this.tickerFn &&
            (this.gsap.ticker.remove(this.tickerFn), (this.tickerFn = null)),
            this.tween && this.tween.kill();
        }),
        t
      );
    })();
    function fh(t, e) {
      return (fh = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    (ph.pluginName = "scroller"),
      (ph.defaultOptions = {
        speed: 1,
        multiplier: 0.5,
        threshold: 1,
        ease: "expo.out",
        overwrite: !0,
        bothDirection: !0,
        reversed: !1,
        stopOnEnd: !1,
        scrollProxy: null,
      }),
      dh.registerGSAP(Yi),
      dh.use(ph),
      oh.use([
        function ({ swiper: t, extendParams: e, on: n, emit: i, params: r }) {
          let s, o;
          (t.autoplay = {
            running: !1,
            paused: !1,
            timeLeft: 0,
          }),
            e({
              autoplay: {
                enabled: !1,
                delay: 3e3,
                waitForTransition: !0,
                disableOnInteraction: !0,
                stopOnLastSlide: !1,
                reverseDirection: !1,
                pauseOnMouseEnter: !1,
              },
            });
          let a,
            l,
            c,
            u,
            h,
            d,
            p,
            f = r && r.autoplay ? r.autoplay.delay : 3e3,
            m = r && r.autoplay ? r.autoplay.delay : 3e3,
            g = new Date().getTime;
          function v(e) {
            t &&
              !t.destroyed &&
              t.wrapperEl &&
              e.target === t.wrapperEl &&
              (t.wrapperEl.removeEventListener("transitionend", v), E());
          }
          const _ = () => {
              if (t.destroyed || !t.autoplay.running) return;
              t.autoplay.paused ? (l = !0) : l && ((m = a), (l = !1));
              const e = t.autoplay.paused ? a : g + m - new Date().getTime();
              (t.autoplay.timeLeft = e),
                i("autoplayTimeLeft", e, e / f),
                (o = requestAnimationFrame(() => {
                  _();
                }));
            },
            y = (e) => {
              if (t.destroyed || !t.autoplay.running) return;
              cancelAnimationFrame(o), _();
              let n = void 0 === e ? t.params.autoplay.delay : e;
              (f = t.params.autoplay.delay), (m = t.params.autoplay.delay);
              const r = (() => {
                let e;
                if (
                  ((e =
                    t.virtual && t.params.virtual.enabled
                      ? t.slides.filter((t) =>
                          t.classList.contains("swiper-slide-active")
                        )[0]
                      : t.slides[t.activeIndex]),
                  !e)
                )
                  return;
                return parseInt(e.getAttribute("data-swiper-autoplay"), 10);
              })();
              !Number.isNaN(r) &&
                r > 0 &&
                void 0 === e &&
                ((n = r), (f = r), (m = r)),
                (a = n);
              const l = t.params.speed,
                c = () => {
                  t &&
                    !t.destroyed &&
                    (t.params.autoplay.reverseDirection
                      ? !t.isBeginning || t.params.loop || t.params.rewind
                        ? (t.slidePrev(l, !0, !0), i("autoplay"))
                        : t.params.autoplay.stopOnLastSlide ||
                          (t.slideTo(t.slides.length - 1, l, !0, !0),
                          i("autoplay"))
                      : !t.isEnd || t.params.loop || t.params.rewind
                      ? (t.slideNext(l, !0, !0), i("autoplay"))
                      : t.params.autoplay.stopOnLastSlide ||
                        (t.slideTo(0, l, !0, !0), i("autoplay")),
                    t.params.cssMode &&
                      ((g = new Date().getTime()),
                      requestAnimationFrame(() => {
                        y();
                      })));
                };
              return (
                n > 0
                  ? (clearTimeout(s),
                    (s = setTimeout(() => {
                      c();
                    }, n)))
                  : requestAnimationFrame(() => {
                      c();
                    }),
                n
              );
            },
            x = () => {
              (t.autoplay.running = !0), y(), i("autoplayStart");
            },
            b = () => {
              (t.autoplay.running = !1),
                clearTimeout(s),
                cancelAnimationFrame(o),
                i("autoplayStop");
            },
            S = (e, n) => {
              if (t.destroyed || !t.autoplay.running) return;
              clearTimeout(s), e || (p = !0);
              const r = () => {
                i("autoplayPause"),
                  t.params.autoplay.waitForTransition
                    ? t.wrapperEl.addEventListener("transitionend", v)
                    : E();
              };
              if (((t.autoplay.paused = !0), n))
                return d && (a = t.params.autoplay.delay), (d = !1), void r();
              const o = a || t.params.autoplay.delay;
              (a = o - (new Date().getTime() - g)),
                (t.isEnd && a < 0 && !t.params.loop) || (a < 0 && (a = 0), r());
            },
            E = () => {
              (t.isEnd && a < 0 && !t.params.loop) ||
                t.destroyed ||
                !t.autoplay.running ||
                ((g = new Date().getTime()),
                p ? ((p = !1), y(a)) : y(),
                (t.autoplay.paused = !1),
                i("autoplayResume"));
            },
            M = () => {
              if (t.destroyed || !t.autoplay.running) return;
              const e = _u();
              "hidden" === e.visibilityState && ((p = !0), S(!0)),
                "visible" === e.visibilityState && E();
            },
            T = (t) => {
              "mouse" === t.pointerType && ((p = !0), S(!0));
            },
            w = (e) => {
              "mouse" === e.pointerType && t.autoplay.paused && E();
            };
          n("init", () => {
            t.params.autoplay.enabled &&
              (t.params.autoplay.pauseOnMouseEnter &&
                (t.el.addEventListener("pointerenter", T),
                t.el.addEventListener("pointerleave", w)),
              _u().addEventListener("visibilitychange", M),
              (g = new Date().getTime()),
              x());
          }),
            n("destroy", () => {
              t.el.removeEventListener("pointerenter", T),
                t.el.removeEventListener("pointerleave", w),
                _u().removeEventListener("visibilitychange", M),
                t.autoplay.running && b();
            }),
            n("beforeTransitionStart", (e, n, i) => {
              !t.destroyed &&
                t.autoplay.running &&
                (i || !t.params.autoplay.disableOnInteraction
                  ? S(!0, !0)
                  : b());
            }),
            n("sliderFirstMove", () => {
              !t.destroyed &&
                t.autoplay.running &&
                (t.params.autoplay.disableOnInteraction
                  ? b()
                  : ((c = !0),
                    (u = !1),
                    (p = !1),
                    (h = setTimeout(() => {
                      (p = !0), (u = !0), S(!0);
                    }, 200))));
            }),
            n("touchEnd", () => {
              if (!t.destroyed && t.autoplay.running && c) {
                if (
                  (clearTimeout(h),
                  clearTimeout(s),
                  t.params.autoplay.disableOnInteraction)
                )
                  return (u = !1), void (c = !1);
                u && t.params.cssMode && E(), (u = !1), (c = !1);
              }
            }),
            n("slideChange", () => {
              !t.destroyed && t.autoplay.running && (d = !0);
            }),
            Object.assign(t.autoplay, {
              start: x,
              stop: b,
              pause: S,
              resume: E,
            });
        },
      ]);
    var mh = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).cursor = e.app.get("cursor")),
          (e.layout = e.app.get("layout")),
          (e.bg = e.el.querySelector(".cb-overview-bg")),
          (e.content = e.el.querySelector(".cb-overview-content")),
          (e.carousel = e.el.querySelector(".cb-overview-carousel")),
          (e.carouselItem = e.el.querySelectorAll(
            ".cb-overview-carousel-item"
          )),
          (e.header = e.el.querySelector(".cb-overview-header")),
          (e.icon = e.el.querySelector(".cb-overview-icon")),
          (e.caption = e.el.querySelectorAll(".cb-overview-caption")),
          (e.author = e.el.querySelector(".cb-overview-author")),
          (e.text = e.el.querySelector(".cb-overview-text")),
          (e.action = e.el.querySelector(".cb-overview-action")),
          (e.link = e.el.querySelectorAll(".cb-overview-link")),
          (e.counter = e.el.querySelectorAll(".cb-overview-counter")),
          (e.logo = e.el.querySelectorAll(".cb-overview-logo")),
          e.initCarousel(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        fh(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            var t = this;
            return Promise.resolve(document.fonts.ready).then(function () {
              t.magicParallax(), t.magicShow();
            });
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onDestroy = function () {
          try {
            return (
              this.swiper && this.swiper.destroy(!0, !1), Promise.resolve()
            );
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.initCarousel = function () {
          var t = this;
          this.carousel &&
            ((this.swiper = new oh(this.carousel, {
              wrapperClass: "cb-overview-carousel-wrap",
              slideClass: "cb-overview-carousel-item",
              slidesPerView: 1,
              loop: !0,
              grabCursor: !0,
              touchStartPreventDefault: !1,
              autoplay: {
                delay: 5e3,
                pauseOnMouseEnter: !0,
              },
            })),
            this.carouselItem.forEach(function (e) {
              var n = e.querySelector(".cb-overview-text");
              n &&
                (n.addEventListener("click", function (e) {
                  t.swiper.slideNext();
                }),
                t.cursor.follower &&
                  (n.addEventListener("mouseenter", function () {
                    t.cursor.follower.setIcon(
                      "long-arrow-right-o",
                      "font-size:28px"
                    );
                  }),
                  n.addEventListener("mouseleave", function () {
                    t.cursor.follower.removeIcon();
                  })));
            }));
        }),
        (r.magicShow = function () {
          var t, e, n;
          this.header &&
            Tc(this.header.firstElementChild, {
              type: "lines",
              stagger: 0.3,
            }),
            this.icon && Dc(this.icon),
            this.caption.length &&
              this.caption.forEach(function (t) {
                Tc(t, {
                  stagger: 0.1,
                });
              }),
            this.author && Lc(this.author),
            this.text && Tc(this.text),
            this.action && Cc(this.action),
            this.link.length &&
              Lc(this.link, {
                duration: 0.8,
                stagger: 0.2,
              }),
            this.counter.length && Cc(this.counter),
            this.logo.length &&
              ((t = this.logo),
              void 0 === e && (e = {}),
              void 0 === n && (n = {}),
              Yi.set(t, {
                opacity: 0,
              }),
              No.batch(
                t,
                Sc(
                  {
                    onEnter: function (t) {
                      return Lc(t, e);
                    },
                    once: !0,
                  },
                  n
                )
              ));
        }),
        (r.magicParallax = function () {
          this.bg &&
            No.create({
              trigger: this.el,
              animation: this.tlParallax(),
              start: "top bottom",
              end: "bottom top",
              scrub: !0,
            });
        }),
        (r.tlParallax = function () {
          var t = new Yi.timeline();
          return (
            this.bg &&
              t.fromTo(
                this.bg,
                {
                  yPercent: -30,
                },
                {
                  yPercent: 30,
                  ease: "none",
                },
                0
              ),
            t
          );
        }),
        i
      );
    })(l);
    function gh(t, e) {
      return (gh = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var vh = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).item =
            e.el.querySelectorAll(".cb-splitshow-item")),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        gh(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return this.magicItems(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.magicItems = function () {
          var t = this;
          this.item.forEach(function (e) {
            var n = e
                .querySelector(".cb-splitshow-preview")
                .querySelector(".cb-splitshow-preview-media"),
              i = e.querySelector(".cb-splitshow-caption");
            No.create({
              trigger: e,
              animation: t.tlShow(n, i),
              once: !0,
            }),
              No.create({
                trigger: e,
                animation: t.tlParallax(n),
                start: "top bottom",
                end: "bottom top",
                scrub: !0,
              });
          });
        }),
        (r.tlShow = function (t, e) {
          var n = new Yi.timeline();
          return (
            Yi.set(t, {
              opacity: 0,
            }),
            n.to(t, {
              opacity: 1,
              duration: 1,
            }),
            n
          );
        }),
        (r.tlParallax = function (t) {
          var e = new Yi.timeline();
          return (
            Yi.set(t, {
              scale: 1.05,
            }),
            e.fromTo(
              t,
              {
                y: "-10%",
              },
              {
                y: "10%",
                ease: "none",
              }
            ),
            e
          );
        }),
        i
      );
    })(l);
    const _h = (t) => Math.max(t.offsetHeight, t.scrollHeight);
    class yh {
      constructor(t = {}) {
        const e = {
          content: t.viewport.children[0],
          direction: "all",
          pointerMode: "all",
          scrollMode: void 0,
          bounce: !0,
          bounceForce: 0.1,
          friction: 0.05,
          textSelection: !1,
          inputsFocus: !0,
          emulateScroll: !1,
          preventDefaultOnEmulateScroll: !1,
          preventPointerMoveDefault: !0,
          lockScrollOnDragDirection: !1,
          pointerDownPreventDefault: !0,
          dragDirectionTolerance: 40,
          onPointerDown() {},
          onPointerUp() {},
          onPointerMove() {},
          onClick() {},
          onUpdate() {},
          onWheel() {},
          shouldScroll: () => !0,
        };
        if (
          ((this.props = {
            ...e,
            ...t,
          }),
          !(this.props.viewport && this.props.viewport instanceof Element))
        )
          return void console.error(
            'ScrollBooster init error: "viewport" config property must be present and must be Element'
          );
        if (!this.props.content)
          return void console.error(
            "ScrollBooster init error: Viewport does not have any content"
          );
        (this.isDragging = !1),
          (this.isTargetScroll = !1),
          (this.isScrolling = !1),
          (this.isRunning = !1);
        const n = {
          x: 0,
          y: 0,
        };
        (this.position = {
          ...n,
        }),
          (this.velocity = {
            ...n,
          }),
          (this.dragStartPosition = {
            ...n,
          }),
          (this.dragOffset = {
            ...n,
          }),
          (this.clientOffset = {
            ...n,
          }),
          (this.dragPosition = {
            ...n,
          }),
          (this.targetPosition = {
            ...n,
          }),
          (this.scrollOffset = {
            ...n,
          }),
          (this.rafID = null),
          (this.events = {}),
          this.updateMetrics(),
          this.handleEvents();
      }
      updateOptions(t = {}) {
        (this.props = {
          ...this.props,
          ...t,
        }),
          this.props.onUpdate(this.getState()),
          this.startAnimationLoop();
      }
      updateMetrics() {
        var t;
        (this.viewport = {
          width: this.props.viewport.clientWidth,
          height: this.props.viewport.clientHeight,
        }),
          (this.content = {
            width:
              ((t = this.props.content),
              Math.max(t.offsetWidth, t.scrollWidth)),
            height: _h(this.props.content),
          }),
          (this.edgeX = {
            from: Math.min(-this.content.width + this.viewport.width, 0),
            to: 0,
          }),
          (this.edgeY = {
            from: Math.min(-this.content.height + this.viewport.height, 0),
            to: 0,
          }),
          this.props.onUpdate(this.getState()),
          this.startAnimationLoop();
      }
      startAnimationLoop() {
        (this.isRunning = !0),
          cancelAnimationFrame(this.rafID),
          (this.rafID = requestAnimationFrame(() => this.animate()));
      }
      animate() {
        if (!this.isRunning) return;
        this.updateScrollPosition(),
          this.isMoving() ||
            ((this.isRunning = !1), (this.isTargetScroll = !1));
        const t = this.getState();
        this.setContentPosition(t),
          this.props.onUpdate(t),
          (this.rafID = requestAnimationFrame(() => this.animate()));
      }
      updateScrollPosition() {
        this.applyEdgeForce(),
          this.applyDragForce(),
          this.applyScrollForce(),
          this.applyTargetForce();
        const t = 1 - this.props.friction;
        (this.velocity.x *= t),
          (this.velocity.y *= t),
          "vertical" !== this.props.direction &&
            (this.position.x += this.velocity.x),
          "horizontal" !== this.props.direction &&
            (this.position.y += this.velocity.y),
          (this.props.bounce && !this.isScrolling) ||
            this.isTargetScroll ||
            ((this.position.x = Math.max(
              Math.min(this.position.x, this.edgeX.to),
              this.edgeX.from
            )),
            (this.position.y = Math.max(
              Math.min(this.position.y, this.edgeY.to),
              this.edgeY.from
            )));
      }
      applyForce(t) {
        (this.velocity.x += t.x), (this.velocity.y += t.y);
      }
      applyEdgeForce() {
        if (!this.props.bounce || this.isDragging) return;
        const t = this.position.x < this.edgeX.from,
          e = this.position.x > this.edgeX.to,
          n = this.position.y < this.edgeY.from,
          i = this.position.y > this.edgeY.to,
          r = t || e,
          s = n || i;
        if (!r && !s) return;
        const o = t ? this.edgeX.from : this.edgeX.to,
          a = n ? this.edgeY.from : this.edgeY.to,
          l = o - this.position.x,
          c = a - this.position.y,
          u = {
            x: l * this.props.bounceForce,
            y: c * this.props.bounceForce,
          },
          h = this.position.x + (this.velocity.x + u.x) / this.props.friction,
          d = this.position.y + (this.velocity.y + u.y) / this.props.friction;
        ((t && h >= this.edgeX.from) || (e && h <= this.edgeX.to)) &&
          (u.x = l * this.props.bounceForce - this.velocity.x),
          ((n && d >= this.edgeY.from) || (i && d <= this.edgeY.to)) &&
            (u.y = c * this.props.bounceForce - this.velocity.y),
          this.applyForce({
            x: r ? u.x : 0,
            y: s ? u.y : 0,
          });
      }
      applyDragForce() {
        if (!this.isDragging) return;
        const t = this.dragPosition.x - this.position.x,
          e = this.dragPosition.y - this.position.y;
        this.applyForce({
          x: t - this.velocity.x,
          y: e - this.velocity.y,
        });
      }
      applyScrollForce() {
        this.isScrolling &&
          (this.applyForce({
            x: this.scrollOffset.x - this.velocity.x,
            y: this.scrollOffset.y - this.velocity.y,
          }),
          (this.scrollOffset.x = 0),
          (this.scrollOffset.y = 0));
      }
      applyTargetForce() {
        this.isTargetScroll &&
          this.applyForce({
            x:
              0.08 * (this.targetPosition.x - this.position.x) -
              this.velocity.x,
            y:
              0.08 * (this.targetPosition.y - this.position.y) -
              this.velocity.y,
          });
      }
      isMoving() {
        return (
          this.isDragging ||
          this.isScrolling ||
          Math.abs(this.velocity.x) >= 0.01 ||
          Math.abs(this.velocity.y) >= 0.01
        );
      }
      scrollTo(t = {}) {
        (this.isTargetScroll = !0),
          (this.targetPosition.x = -t.x || 0),
          (this.targetPosition.y = -t.y || 0),
          this.startAnimationLoop();
      }
      setPosition(t = {}) {
        (this.velocity.x = 0),
          (this.velocity.y = 0),
          (this.position.x = -t.x || 0),
          (this.position.y = -t.y || 0),
          this.startAnimationLoop();
      }
      getState() {
        return {
          isMoving: this.isMoving(),
          isDragging: !(!this.dragOffset.x && !this.dragOffset.y),
          position: {
            x: -this.position.x,
            y: -this.position.y,
          },
          dragOffset: this.dragOffset,
          dragAngle: this.getDragAngle(
            this.clientOffset.x,
            this.clientOffset.y
          ),
          borderCollision: {
            left: this.position.x >= this.edgeX.to,
            right: this.position.x <= this.edgeX.from,
            top: this.position.y >= this.edgeY.to,
            bottom: this.position.y <= this.edgeY.from,
          },
        };
      }
      getDragAngle(t, e) {
        return Math.round(Math.atan2(t, e) * (180 / Math.PI));
      }
      getDragDirection(t, e) {
        return Math.abs(90 - Math.abs(t)) <= 90 - e ? "horizontal" : "vertical";
      }
      setContentPosition(t) {
        "transform" === this.props.scrollMode &&
          (this.props.content.style.transform = `translate(${-t.position
            .x}px, ${-t.position.y}px)`),
          "native" === this.props.scrollMode &&
            ((this.props.viewport.scrollTop = t.position.y),
            (this.props.viewport.scrollLeft = t.position.x));
      }
      handleEvents() {
        const t = {
            x: 0,
            y: 0,
          },
          e = {
            x: 0,
            y: 0,
          };
        let n = null,
          i = null,
          r = !1;
        const s = (i) => {
          if (!this.isDragging) return;
          const s = r ? i.touches[0] : i,
            { pageX: o, pageY: a, clientX: l, clientY: c } = s;
          (this.dragOffset.x = o - t.x),
            (this.dragOffset.y = a - t.y),
            (this.clientOffset.x = l - e.x),
            (this.clientOffset.y = c - e.y),
            ((Math.abs(this.clientOffset.x) > 5 && !n) ||
              (Math.abs(this.clientOffset.y) > 5 && !n)) &&
              (n = this.getDragDirection(
                this.getDragAngle(this.clientOffset.x, this.clientOffset.y),
                this.props.dragDirectionTolerance
              )),
            this.props.lockScrollOnDragDirection &&
            "all" !== this.props.lockScrollOnDragDirection
              ? n === this.props.lockScrollOnDragDirection && r
                ? ((this.dragPosition.x =
                    this.dragStartPosition.x + this.dragOffset.x),
                  (this.dragPosition.y =
                    this.dragStartPosition.y + this.dragOffset.y))
                : r
                ? ((this.dragPosition.x = this.dragStartPosition.x),
                  (this.dragPosition.y = this.dragStartPosition.y))
                : ((this.dragPosition.x =
                    this.dragStartPosition.x + this.dragOffset.x),
                  (this.dragPosition.y =
                    this.dragStartPosition.y + this.dragOffset.y))
              : ((this.dragPosition.x =
                  this.dragStartPosition.x + this.dragOffset.x),
                (this.dragPosition.y =
                  this.dragStartPosition.y + this.dragOffset.y));
        };
        (this.events.pointerdown = (n) => {
          (r = !(!n.touches || !n.touches[0])),
            this.props.onPointerDown(this.getState(), n, r);
          const i = r ? n.touches[0] : n,
            { pageX: o, pageY: a, clientX: l, clientY: c } = i,
            { viewport: u } = this.props,
            h = u.getBoundingClientRect();
          if (l - h.left >= u.clientLeft + u.clientWidth) return;
          if (c - h.top >= u.clientTop + u.clientHeight) return;
          if (!this.props.shouldScroll(this.getState(), n)) return;
          if (2 === n.button) return;
          if ("mouse" === this.props.pointerMode && r) return;
          if ("touch" === this.props.pointerMode && !r) return;
          if (
            !(
              this.props.inputsFocus &&
              ["input", "textarea", "button", "select", "label"].indexOf(
                n.target.nodeName.toLowerCase()
              ) > -1
            )
          ) {
            if (this.props.textSelection) {
              if (
                ((t, e, n) => {
                  const i = t.childNodes,
                    r = document.createRange();
                  for (let t = 0; t < i.length; t++) {
                    const s = i[t];
                    if (3 !== s.nodeType) continue;
                    r.selectNodeContents(s);
                    const o = r.getBoundingClientRect();
                    if (
                      e >= o.left &&
                      n >= o.top &&
                      e <= o.right &&
                      n <= o.bottom
                    )
                      return s;
                  }
                  return !1;
                })(n.target, l, c)
              )
                return;
              (() => {
                const t = window.getSelection
                  ? window.getSelection()
                  : document.selection;
                t &&
                  (t.removeAllRanges
                    ? t.removeAllRanges()
                    : t.empty && t.empty());
              })();
            }
            (this.isDragging = !0),
              (t.x = o),
              (t.y = a),
              (e.x = l),
              (e.y = c),
              (this.dragStartPosition.x = this.position.x),
              (this.dragStartPosition.y = this.position.y),
              s(n),
              this.startAnimationLoop(),
              !r && this.props.pointerDownPreventDefault && n.preventDefault();
          }
        }),
          (this.events.pointermove = (t) => {
            !t.cancelable ||
              ("all" !== this.props.lockScrollOnDragDirection &&
                this.props.lockScrollOnDragDirection !== n) ||
              t.preventDefault(),
              s(t),
              this.props.onPointerMove(this.getState(), t, r);
          }),
          (this.events.pointerup = (t) => {
            (this.isDragging = !1),
              (n = null),
              this.props.onPointerUp(this.getState(), t, r);
          }),
          (this.events.wheel = (t) => {
            const e = this.getState();
            this.props.emulateScroll &&
              ((this.velocity.x = 0),
              (this.velocity.y = 0),
              (this.isScrolling = !0),
              (this.scrollOffset.x = -t.deltaX),
              (this.scrollOffset.y = -t.deltaY),
              this.props.onWheel(e, t),
              this.startAnimationLoop(),
              clearTimeout(i),
              (i = setTimeout(() => (this.isScrolling = !1), 80)),
              this.props.preventDefaultOnEmulateScroll &&
                this.getDragDirection(
                  this.getDragAngle(-t.deltaX, -t.deltaY),
                  this.props.dragDirectionTolerance
                ) === this.props.preventDefaultOnEmulateScroll &&
                t.preventDefault());
          }),
          (this.events.scroll = () => {
            const { scrollLeft: t, scrollTop: e } = this.props.viewport;
            Math.abs(this.position.x + t) > 3 &&
              ((this.position.x = -t), (this.velocity.x = 0)),
              Math.abs(this.position.y + e) > 3 &&
                ((this.position.y = -e), (this.velocity.y = 0));
          }),
          (this.events.click = (t) => {
            const e = this.getState(),
              n = "vertical" !== this.props.direction ? e.dragOffset.x : 0,
              i = "horizontal" !== this.props.direction ? e.dragOffset.y : 0;
            Math.max(Math.abs(n), Math.abs(i)) > 5 &&
              (t.preventDefault(), t.stopPropagation()),
              this.props.onClick(e, t, r);
          }),
          (this.events.contentLoad = () => this.updateMetrics()),
          (this.events.resize = () => this.updateMetrics()),
          this.props.viewport.addEventListener(
            "mousedown",
            this.events.pointerdown
          ),
          this.props.viewport.addEventListener(
            "touchstart",
            this.events.pointerdown,
            {
              passive: !1,
            }
          ),
          this.props.viewport.addEventListener("click", this.events.click),
          this.props.viewport.addEventListener("wheel", this.events.wheel, {
            passive: !1,
          }),
          this.props.viewport.addEventListener("scroll", this.events.scroll),
          this.props.content.addEventListener(
            "load",
            this.events.contentLoad,
            !0
          ),
          window.addEventListener("mousemove", this.events.pointermove),
          window.addEventListener("touchmove", this.events.pointermove, {
            passive: !1,
          }),
          window.addEventListener("mouseup", this.events.pointerup),
          window.addEventListener("touchend", this.events.pointerup),
          window.addEventListener("resize", this.events.resize);
      }
      destroy() {
        this.props.viewport.removeEventListener(
          "mousedown",
          this.events.pointerdown
        ),
          this.props.viewport.removeEventListener(
            "touchstart",
            this.events.pointerdown
          ),
          this.props.viewport.removeEventListener("click", this.events.click),
          this.props.viewport.removeEventListener("wheel", this.events.wheel),
          this.props.viewport.removeEventListener("scroll", this.events.scroll),
          this.props.content.removeEventListener(
            "load",
            this.events.contentLoad
          ),
          window.removeEventListener("mousemove", this.events.pointermove),
          window.removeEventListener("touchmove", this.events.pointermove),
          window.removeEventListener("mouseup", this.events.pointerup),
          window.removeEventListener("touchend", this.events.pointerup),
          window.removeEventListener("resize", this.events.resize);
      }
    }
    function xh(t, e) {
      return (xh = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var bh = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).header =
            e.el.querySelector(".cb-summary-header")),
          (e.text = e.el.querySelector(".cb-summary-text")),
          (e.figure = e.el.querySelector(".cb-summary-figure")),
          (e.carousel = e.el.querySelector(".cb-summary-carousel")),
          (e.entry = e.el.querySelectorAll(".cb-summary-entry")),
          (e.more = e.el.querySelector(".cb-summary-more")),
          (e.actionBtn = e.el.querySelector(".cb-summary-action a")),
          e.initCarousel(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        xh(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            var t = this;
            return Promise.resolve(document.fonts.ready).then(function () {
              t.magicShow();
            });
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onDestroy = function () {
          try {
            return this.swiper && this.sb.destroy(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.initCarousel = function () {
          this.carousel &&
            (this.sb = new yh({
              viewport: this.carousel,
              scrollMode: "transform",
              direction: "horizontal",
              lockScrollOnDragDirection: "horizontal",
            }));
        }),
        (r.magicShow = function () {
          this.header &&
            Tc(this.header.firstElementChild, {
              type: "lines",
              stagger: 0.2,
            }),
            this.text && Tc(this.text),
            this.figure &&
              Dc(this.figure, {
                from: 0.5,
              }),
            this.entry.length &&
              Lc(this.entry, {
                duration: 1,
              }),
            this.more && Cc(this.more),
            this.actionBtn && Ic(this.actionBtn);
        }),
        i
      );
    })(l);
    function Sh(t, e) {
      return (Sh = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Eh = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).preview = e.el.querySelector(
            ".cb-screenshot-preview"
          )),
          (e.previewMedia = e.preview.querySelector(
            ".cb-screenshot-preview-media"
          )),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        Sh(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return this.magicShow(), this.magicParallax(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.magicShow = function () {
          No.create({
            trigger: this.el,
            animation: this.tlShow(),
            once: !0,
          });
        }),
        (r.tlShow = function () {
          var t = new Yi.timeline();
          return (
            Yi.set(this.previewMedia, {
              opacity: 0,
            }),
            t.to(this.previewMedia, {
              opacity: 1,
              duration: 1,
            }),
            t
          );
        }),
        (r.magicParallax = function () {
          No.create({
            trigger: this.el,
            animation: this.tlParallax(),
            start: "top bottom",
            end: "bottom top",
            scrub: !0,
          });
        }),
        (r.tlParallax = function () {
          var t = new Yi.timeline();
          return (
            Yi.set(this.previewMedia, {
              scale: 1.05,
            }),
            t.fromTo(
              this.previewMedia,
              {
                y: "-10%",
              },
              {
                y: "10%",
                ease: "none",
              }
            ),
            t
          );
        }),
        i
      );
    })(l);
    function Mh(t, e) {
      return (Mh = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Th = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).layout = e.app.get("layout")),
          (e.reel = e.el.querySelector(".cb-nextcase-reel")),
          e.initReeller(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        Mh(e, n);
      var r = i.prototype;
      return (
        (r.onDestroy = function () {
          try {
            return this.reeller.destroy(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.initReeller = function () {
          var t = this;
          this.reeller = new dh({
            container: this.reel,
            wrapper: ".cb-nextcase-reel-items",
            itemSelector: ".cb-nextcase-reel-item",
            speed: 15,
            plugins: {
              scroller: {
                multiplier: 0.3,
                speed: 1,
                threshold: 1,
                reversed: !0,
                scrollProxy: function () {
                  return t.layout.scrollTop();
                },
              },
            },
          });
        }),
        i
      );
    })(l);
    function wh(t, e) {
      return (wh = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Dh = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).layout = e.app.get("layout")),
          (e.reel = e.el.querySelector(".cb-smfeed-reel")),
          (e.carousel = e.el.querySelector(".cb-smfeed-carousel")),
          (e.item = e.el.querySelectorAll(".cb-smfeed-item")),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        wh(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            var t = this;
            return Promise.resolve(document.fonts.ready).then(function () {
              t.initReeller(), t.initCarousel(), t.magicShow();
            });
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.onDestroy = function () {
          try {
            return this.sb && this.sb.destroy(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.initCarousel = function () {
          this.carousel &&
            (this.sb = new yh({
              viewport: this.carousel,
              scrollMode: "transform",
              direction: "horizontal",
              lockScrollOnDragDirection: "horizontal",
            }));
        }),
        (r.initReeller = function () {
          var t = this;
          this.reel &&
            (this.reeller = new dh({
              container: this.reel,
              wrapper: ".cb-smfeed-reel-wrap",
              itemSelector: ".cb-smfeed-reel-item",
              speed: 20,
              plugins: {
                scroller: {
                  multiplier: 0.3,
                  speed: 1,
                  threshold: 1,
                  reversed: !0,
                  scrollProxy: function () {
                    var e;
                    return null == (e = t.layout) ? void 0 : e.scrollTop();
                  },
                },
              },
            }));
        }),
        (r.magicShow = function () {
          this.item.length &&
            Lc(this.item, {
              duration: 1,
            });
        }),
        i
      );
    })(l);
    function Ah(t, e) {
      return (Ah = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var Ch = (function (t) {
      var e, n;
      function i() {
        var e;
        return (
          ((e = t.apply(this, arguments) || this).layout = e.app.get("layout")),
          (e.reel = e.el.querySelector(".cb-outro-reel")),
          (e.header = e.el.querySelector(".cb-outro-header")),
          (e.caption = e.el.querySelector(".cb-outro-caption")),
          (e.social = e.el.querySelectorAll(".cb-outro-social")),
          (e.location = e.el.querySelectorAll(".cb-outro-location")),
          e.initReeller(),
          e
        );
      }
      (n = t),
        ((e = i).prototype = Object.create(n.prototype)),
        (e.prototype.constructor = e),
        Ah(e, n);
      var r = i.prototype;
      return (
        (r.onInit = function () {
          try {
            return this.magicShow(), Promise.resolve();
          } catch (t) {
            return Promise.reject(t);
          }
        }),
        (r.initReeller = function () {
          var t = this;
          new dh({
            container: this.reel,
            wrapper: ".cb-outro-reel-wrap",
            itemSelector: ".cb-outro-reel-item",
            speed: 10,
            plugins: {
              scroller: {
                multiplier: 0.3,
                speed: 1,
                threshold: 1,
                reversed: !0,
                scrollProxy: function () {
                  var e;
                  return null == (e = t.layout) ? void 0 : e.scrollTop();
                },
              },
            },
          });
          No.isTouch ||
            this.social.forEach(function (t) {
              var e = t.querySelector(".cb-outro-social-reel"),
                n = new dh({
                  container: e,
                  wrapper: ".cb-outro-social-reel-wrap",
                  itemSelector: ".cb-outro-social-reel-item",
                  autoStop: !1,
                  speed: 3,
                });
              t.addEventListener("mouseenter", function () {
                return n.reverse();
              }),
                t.addEventListener("mouseleave", function () {
                  return n.pause();
                });
            });
        }),
        (r.magicShow = function () {
          var t = this;
          this.caption &&
            Tc(this.caption, {
              stagger: 0.1,
            }),
            this.social.length &&
              this.social.forEach(function (e) {
                No.create({
                  trigger: e,
                  start: "center bottom",
                  animation: t.tlShowSocialItem(e),
                  once: !0,
                });
              }),
            this.location.length &&
              this.location.forEach(function (e) {
                No.create({
                  trigger: e,
                  start: "center bottom",
                  animation: t.tlShowLocationItem(e),
                  once: !0,
                });
              });
        }),
        (r.tlShowSocialItem = function (t) {
          var e = new Yi.timeline(),
            n = t.querySelector(".cb-outro-social-title"),
            i = t.querySelector(".cb-outro-social-divider"),
            r = t.querySelector(".cb-outro-social-arr");
          return (
            Yi.set(i, {
              scaleX: 0,
              transformOrigin: "left center",
            }),
            e.to(
              i,
              {
                scaleX: 1,
                duration: 3,
                stagger: 0.3,
                ease: "expo.out",
              },
              0
            ),
            e.add(
              Mc(n, {
                duration: 2.5,
              }),
              0
            ),
            e.add(wc(r), 0.5),
            e
          );
        }),
        (r.tlShowLocationItem = function (t) {
          var e = new Yi.timeline(),
            n = t.querySelector(".cb-outro-location-caption"),
            i = t.querySelector(".cb-outro-location-address"),
            r = t.querySelector(".cb-outro-location-action");
          return e.add(Rc(n), 0), e.add(Mc(i), 0.2), e.add(Ac(r), 0.4), e;
        }),
        i
      );
    })(l);
    /**
     * @license
     * Copyright 2010-2023 Three.js Authors
     * SPDX-License-Identifier: MIT
     */
    class Ph {
      addEventListener(t, e) {
        void 0 === this._listeners && (this._listeners = {});
        const n = this._listeners;
        void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e);
      }
      hasEventListener(t, e) {
        if (void 0 === this._listeners) return !1;
        const n = this._listeners;
        return void 0 !== n[t] && -1 !== n[t].indexOf(e);
      }
      removeEventListener(t, e) {
        if (void 0 === this._listeners) return;
        const n = this._listeners[t];
        if (void 0 !== n) {
          const t = n.indexOf(e);
          -1 !== t && n.splice(t, 1);
        }
      }
      dispatchEvent(t) {
        if (void 0 === this._listeners) return;
        const e = this._listeners[t.type];
        if (void 0 !== e) {
          t.target = this;
          const n = e.slice(0);
          for (let e = 0, i = n.length; e < i; e++) n[e].call(this, t);
          t.target = null;
        }
      }
    }
    const Rh = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0a",
      "0b",
      "0c",
      "0d",
      "0e",
      "0f",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1a",
      "1b",
      "1c",
      "1d",
      "1e",
      "1f",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2a",
      "2b",
      "2c",
      "2d",
      "2e",
      "2f",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3a",
      "3b",
      "3c",
      "3d",
      "3e",
      "3f",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4a",
      "4b",
      "4c",
      "4d",
      "4e",
      "4f",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5a",
      "5b",
      "5c",
      "5d",
      "5e",
      "5f",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6a",
      "6b",
      "6c",
      "6d",
      "6e",
      "6f",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7a",
      "7b",
      "7c",
      "7d",
      "7e",
      "7f",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8a",
      "8b",
      "8c",
      "8d",
      "8e",
      "8f",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9a",
      "9b",
      "9c",
      "9d",
      "9e",
      "9f",
      "a0",
      "a1",
      "a2",
      "a3",
      "a4",
      "a5",
      "a6",
      "a7",
      "a8",
      "a9",
      "aa",
      "ab",
      "ac",
      "ad",
      "ae",
      "af",
      "b0",
      "b1",
      "b2",
      "b3",
      "b4",
      "b5",
      "b6",
      "b7",
      "b8",
      "b9",
      "ba",
      "bb",
      "bc",
      "bd",
      "be",
      "bf",
      "c0",
      "c1",
      "c2",
      "c3",
      "c4",
      "c5",
      "c6",
      "c7",
      "c8",
      "c9",
      "ca",
      "cb",
      "cc",
      "cd",
      "ce",
      "cf",
      "d0",
      "d1",
      "d2",
      "d3",
      "d4",
      "d5",
      "d6",
      "d7",
      "d8",
      "d9",
      "da",
      "db",
      "dc",
      "dd",
      "de",
      "df",
      "e0",
      "e1",
      "e2",
      "e3",
      "e4",
      "e5",
      "e6",
      "e7",
      "e8",
      "e9",
      "ea",
      "eb",
      "ec",
      "ed",
      "ee",
      "ef",
      "f0",
      "f1",
      "f2",
      "f3",
      "f4",
      "f5",
      "f6",
      "f7",
      "f8",
      "f9",
      "fa",
      "fb",
      "fc",
      "fd",
      "fe",
      "ff",
    ];
    const Lh = Math.PI / 180,
      Oh = 180 / Math.PI;
    function Ih() {
      const t = (4294967295 * Math.random()) | 0,
        e = (4294967295 * Math.random()) | 0,
        n = (4294967295 * Math.random()) | 0,
        i = (4294967295 * Math.random()) | 0;
      return (
        Rh[255 & t] +
        Rh[(t >> 8) & 255] +
        Rh[(t >> 16) & 255] +
        Rh[(t >> 24) & 255] +
        "-" +
        Rh[255 & e] +
        Rh[(e >> 8) & 255] +
        "-" +
        Rh[((e >> 16) & 15) | 64] +
        Rh[(e >> 24) & 255] +
        "-" +
        Rh[(63 & n) | 128] +
        Rh[(n >> 8) & 255] +
        "-" +
        Rh[(n >> 16) & 255] +
        Rh[(n >> 24) & 255] +
        Rh[255 & i] +
        Rh[(i >> 8) & 255] +
        Rh[(i >> 16) & 255] +
        Rh[(i >> 24) & 255]
      ).toLowerCase();
    }
    function Fh(t, e, n) {
      return Math.max(e, Math.min(n, t));
    }
    function Uh(t, e) {
      return ((t % e) + e) % e;
    }
    function Nh(t, e, n) {
      return (1 - n) * t + n * e;
    }
    function kh(t) {
      return 0 == (t & (t - 1)) && 0 !== t;
    }
    function zh(t) {
      return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
    }
    function Bh(t, e) {
      switch (e.constructor) {
        case Float32Array:
          return t;
        case Uint32Array:
          return t / 4294967295;
        case Uint16Array:
          return t / 65535;
        case Uint8Array:
          return t / 255;
        case Int32Array:
          return Math.max(t / 2147483647, -1);
        case Int16Array:
          return Math.max(t / 32767, -1);
        case Int8Array:
          return Math.max(t / 127, -1);
        default:
          throw new Error("Invalid component type.");
      }
    }
    function Hh(t, e) {
      switch (e.constructor) {
        case Float32Array:
          return t;
        case Uint32Array:
          return Math.round(4294967295 * t);
        case Uint16Array:
          return Math.round(65535 * t);
        case Uint8Array:
          return Math.round(255 * t);
        case Int32Array:
          return Math.round(2147483647 * t);
        case Int16Array:
          return Math.round(32767 * t);
        case Int8Array:
          return Math.round(127 * t);
        default:
          throw new Error("Invalid component type.");
      }
    }
    class Vh {
      constructor(t = 0, e = 0) {
        (Vh.prototype.isVector2 = !0), (this.x = t), (this.y = e);
      }
      get width() {
        return this.x;
      }
      set width(t) {
        this.x = t;
      }
      get height() {
        return this.y;
      }
      set height(t) {
        this.y = t;
      }
      set(t, e) {
        return (this.x = t), (this.y = e), this;
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      copy(t) {
        return (this.x = t.x), (this.y = t.y), this;
      }
      add(t) {
        return (this.x += t.x), (this.y += t.y), this;
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), this;
      }
      addVectors(t, e) {
        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
      }
      addScaledVector(t, e) {
        return (this.x += t.x * e), (this.y += t.y * e), this;
      }
      sub(t) {
        return (this.x -= t.x), (this.y -= t.y), this;
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), this;
      }
      subVectors(t, e) {
        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
      }
      multiply(t) {
        return (this.x *= t.x), (this.y *= t.y), this;
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), this;
      }
      divide(t) {
        return (this.x /= t.x), (this.y /= t.y), this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      applyMatrix3(t) {
        const e = this.x,
          n = this.y,
          i = t.elements;
        return (
          (this.x = i[0] * e + i[3] * n + i[6]),
          (this.y = i[1] * e + i[4] * n + i[7]),
          this
        );
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          this
        );
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      }
      ceil() {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      }
      round() {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y;
      }
      cross(t) {
        return this.x * t.y - this.y * t.x;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI;
      }
      angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(Fh(n, -1, 1));
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          n = this.y - t.y;
        return e * e + n * n;
      }
      manhattanDistanceTo(t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this
        );
      }
      lerpVectors(t, e, n) {
        return (
          (this.x = t.x + (e.x - t.x) * n),
          (this.y = t.y + (e.y - t.y) * n),
          this
        );
      }
      equals(t) {
        return t.x === this.x && t.y === this.y;
      }
      fromArray(t, e = 0) {
        return (this.x = t[e]), (this.y = t[e + 1]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.x), (t[e + 1] = this.y), t;
      }
      fromBufferAttribute(t, e) {
        return (this.x = t.getX(e)), (this.y = t.getY(e)), this;
      }
      rotateAround(t, e) {
        const n = Math.cos(e),
          i = Math.sin(e),
          r = this.x - t.x,
          s = this.y - t.y;
        return (
          (this.x = r * n - s * i + t.x), (this.y = r * i + s * n + t.y), this
        );
      }
      random() {
        return (this.x = Math.random()), (this.y = Math.random()), this;
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y;
      }
    }
    class Gh {
      constructor(t, e, n, i, r, s, o, a, l) {
        (Gh.prototype.isMatrix3 = !0),
          (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          void 0 !== t && this.set(t, e, n, i, r, s, o, a, l);
      }
      set(t, e, n, i, r, s, o, a, l) {
        const c = this.elements;
        return (
          (c[0] = t),
          (c[1] = i),
          (c[2] = o),
          (c[3] = e),
          (c[4] = r),
          (c[5] = a),
          (c[6] = n),
          (c[7] = s),
          (c[8] = l),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      }
      copy(t) {
        const e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          this
        );
      }
      extractBasis(t, e, n) {
        return (
          t.setFromMatrix3Column(this, 0),
          e.setFromMatrix3Column(this, 1),
          n.setFromMatrix3Column(this, 2),
          this
        );
      }
      setFromMatrix4(t) {
        const e = t.elements;
        return (
          this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
        );
      }
      multiply(t) {
        return this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const n = t.elements,
          i = e.elements,
          r = this.elements,
          s = n[0],
          o = n[3],
          a = n[6],
          l = n[1],
          c = n[4],
          u = n[7],
          h = n[2],
          d = n[5],
          p = n[8],
          f = i[0],
          m = i[3],
          g = i[6],
          v = i[1],
          _ = i[4],
          y = i[7],
          x = i[2],
          b = i[5],
          S = i[8];
        return (
          (r[0] = s * f + o * v + a * x),
          (r[3] = s * m + o * _ + a * b),
          (r[6] = s * g + o * y + a * S),
          (r[1] = l * f + c * v + u * x),
          (r[4] = l * m + c * _ + u * b),
          (r[7] = l * g + c * y + u * S),
          (r[2] = h * f + d * v + p * x),
          (r[5] = h * m + d * _ + p * b),
          (r[8] = h * g + d * y + p * S),
          this
        );
      }
      multiplyScalar(t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8];
        return (
          e * s * c - e * o * l - n * r * c + n * o * a + i * r * l - i * s * a
        );
      }
      invert() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8],
          u = c * s - o * l,
          h = o * a - c * r,
          d = l * r - s * a,
          p = e * u + n * h + i * d;
        if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const f = 1 / p;
        return (
          (t[0] = u * f),
          (t[1] = (i * l - c * n) * f),
          (t[2] = (o * n - i * s) * f),
          (t[3] = h * f),
          (t[4] = (c * e - i * a) * f),
          (t[5] = (i * r - o * e) * f),
          (t[6] = d * f),
          (t[7] = (n * a - l * e) * f),
          (t[8] = (s * e - n * r) * f),
          this
        );
      }
      transpose() {
        let t;
        const e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      }
      getNormalMatrix(t) {
        return this.setFromMatrix4(t).invert().transpose();
      }
      transposeIntoArray(t) {
        const e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      }
      setUvTransform(t, e, n, i, r, s, o) {
        const a = Math.cos(r),
          l = Math.sin(r);
        return (
          this.set(
            n * a,
            n * l,
            -n * (a * s + l * o) + s + t,
            -i * l,
            i * a,
            -i * (-l * s + a * o) + o + e,
            0,
            0,
            1
          ),
          this
        );
      }
      scale(t, e) {
        return this.premultiply(Wh.makeScale(t, e)), this;
      }
      rotate(t) {
        return this.premultiply(Wh.makeRotation(-t)), this;
      }
      translate(t, e) {
        return this.premultiply(Wh.makeTranslation(t, e)), this;
      }
      makeTranslation(t, e) {
        return (
          t.isVector2
            ? this.set(1, 0, t.x, 0, 1, t.y, 0, 0, 1)
            : this.set(1, 0, t, 0, 1, e, 0, 0, 1),
          this
        );
      }
      makeRotation(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this;
      }
      makeScale(t, e) {
        return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this;
      }
      equals(t) {
        const e = this.elements,
          n = t.elements;
        for (let t = 0; t < 9; t++) if (e[t] !== n[t]) return !1;
        return !0;
      }
      fromArray(t, e = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = t[n + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          t
        );
      }
      clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }
    const Wh = new Gh();
    function jh(t) {
      for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
      return !1;
    }
    Int8Array,
      Uint8Array,
      Uint8ClampedArray,
      Int16Array,
      Uint16Array,
      Int32Array,
      Uint32Array,
      Float32Array,
      Float64Array;
    function Xh(t) {
      return document.createElementNS("http://www.w3.org/1999/xhtml", t);
    }
    const qh = {};
    function Yh(t) {
      t in qh || ((qh[t] = !0), console.warn(t));
    }
    function Kh(t) {
      return t < 0.04045
        ? 0.0773993808 * t
        : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
    }
    function Zh(t) {
      return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
    }
    const Jh = new Gh().fromArray([
        0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
        1e-7, 0.9105199,
      ]),
      $h = new Gh().fromArray([
        1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361,
        1e-7, 0, 1.0982735,
      ]);
    const Qh = {
        "srgb-linear": (t) => t,
        srgb: (t) => t.convertSRGBToLinear(),
        "display-p3": function (t) {
          return t.convertSRGBToLinear().applyMatrix3($h);
        },
      },
      td = {
        "srgb-linear": (t) => t,
        srgb: (t) => t.convertLinearToSRGB(),
        "display-p3": function (t) {
          return t.applyMatrix3(Jh).convertLinearToSRGB();
        },
      },
      ed = {
        enabled: !0,
        get legacyMode() {
          return (
            console.warn(
              "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
            ),
            !this.enabled
          );
        },
        set legacyMode(t) {
          console.warn(
            "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
          ),
            (this.enabled = !t);
        },
        get workingColorSpace() {
          return "srgb-linear";
        },
        set workingColorSpace(t) {
          console.warn(
            "THREE.ColorManagement: .workingColorSpace is readonly."
          );
        },
        convert: function (t, e, n) {
          if (!1 === this.enabled || e === n || !e || !n) return t;
          const i = Qh[e],
            r = td[n];
          if (void 0 === i || void 0 === r)
            throw new Error(
              `Unsupported color space conversion, "${e}" to "${n}".`
            );
          return r(i(t));
        },
        fromWorkingColorSpace: function (t, e) {
          return this.convert(t, this.workingColorSpace, e);
        },
        toWorkingColorSpace: function (t, e) {
          return this.convert(t, e, this.workingColorSpace);
        },
      };
    let nd;
    class id {
      static getDataURL(t) {
        if (/^data:/i.test(t.src)) return t.src;
        if ("undefined" == typeof HTMLCanvasElement) return t.src;
        let e;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
          void 0 === nd && (nd = Xh("canvas")),
            (nd.width = t.width),
            (nd.height = t.height);
          const n = nd.getContext("2d");
          t instanceof ImageData
            ? n.putImageData(t, 0, 0)
            : n.drawImage(t, 0, 0, t.width, t.height),
            (e = nd);
        }
        return e.width > 2048 || e.height > 2048
          ? (console.warn(
              "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
              t
            ),
            e.toDataURL("image/jpeg", 0.6))
          : e.toDataURL("image/png");
      }
      static sRGBToLinear(t) {
        if (
          ("undefined" != typeof HTMLImageElement &&
            t instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            t instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
        ) {
          const e = Xh("canvas");
          (e.width = t.width), (e.height = t.height);
          const n = e.getContext("2d");
          n.drawImage(t, 0, 0, t.width, t.height);
          const i = n.getImageData(0, 0, t.width, t.height),
            r = i.data;
          for (let t = 0; t < r.length; t++) r[t] = 255 * Kh(r[t] / 255);
          return n.putImageData(i, 0, 0), e;
        }
        if (t.data) {
          const e = t.data.slice(0);
          for (let t = 0; t < e.length; t++)
            e instanceof Uint8Array || e instanceof Uint8ClampedArray
              ? (e[t] = Math.floor(255 * Kh(e[t] / 255)))
              : (e[t] = Kh(e[t]));
          return {
            data: e,
            width: t.width,
            height: t.height,
          };
        }
        return (
          console.warn(
            "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
          ),
          t
        );
      }
    }
    let rd = 0;
    class sd {
      constructor(t = null) {
        (this.isSource = !0),
          Object.defineProperty(this, "id", {
            value: rd++,
          }),
          (this.uuid = Ih()),
          (this.data = t),
          (this.version = 0);
      }
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.images[this.uuid]) return t.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: "",
          },
          i = this.data;
        if (null !== i) {
          let t;
          if (Array.isArray(i)) {
            t = [];
            for (let e = 0, n = i.length; e < n; e++)
              i[e].isDataTexture ? t.push(od(i[e].image)) : t.push(od(i[e]));
          } else t = od(i);
          n.url = t;
        }
        return e || (t.images[this.uuid] = n), n;
      }
    }
    function od(t) {
      return ("undefined" != typeof HTMLImageElement &&
        t instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          t instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
        ? id.getDataURL(t)
        : t.data
        ? {
            data: Array.from(t.data),
            width: t.width,
            height: t.height,
            type: t.data.constructor.name,
          }
        : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
    }
    let ad = 0;
    class ld extends Ph {
      constructor(
        t = ld.DEFAULT_IMAGE,
        e = ld.DEFAULT_MAPPING,
        n = 1001,
        i = 1001,
        r = 1006,
        s = 1008,
        o = 1023,
        a = 1009,
        l = ld.DEFAULT_ANISOTROPY,
        c = ""
      ) {
        super(),
          (this.isTexture = !0),
          Object.defineProperty(this, "id", {
            value: ad++,
          }),
          (this.uuid = Ih()),
          (this.name = ""),
          (this.source = new sd(t)),
          (this.mipmaps = []),
          (this.mapping = e),
          (this.channel = 0),
          (this.wrapS = n),
          (this.wrapT = i),
          (this.magFilter = r),
          (this.minFilter = s),
          (this.anisotropy = l),
          (this.format = o),
          (this.internalFormat = null),
          (this.type = a),
          (this.offset = new Vh(0, 0)),
          (this.repeat = new Vh(1, 1)),
          (this.center = new Vh(0, 0)),
          (this.rotation = 0),
          (this.matrixAutoUpdate = !0),
          (this.matrix = new Gh()),
          (this.generateMipmaps = !0),
          (this.premultiplyAlpha = !1),
          (this.flipY = !0),
          (this.unpackAlignment = 4),
          "string" == typeof c
            ? (this.colorSpace = c)
            : (Yh(
                "THREE.Texture: Property .encoding has been replaced by .colorSpace."
              ),
              (this.colorSpace = 3001 === c ? "srgb" : "")),
          (this.userData = {}),
          (this.version = 0),
          (this.onUpdate = null),
          (this.isRenderTargetTexture = !1),
          (this.needsPMREMUpdate = !1);
      }
      get image() {
        return this.source.data;
      }
      set image(t = null) {
        this.source.data = t;
      }
      updateMatrix() {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return (
          (this.name = t.name),
          (this.source = t.source),
          (this.mipmaps = t.mipmaps.slice(0)),
          (this.mapping = t.mapping),
          (this.channel = t.channel),
          (this.wrapS = t.wrapS),
          (this.wrapT = t.wrapT),
          (this.magFilter = t.magFilter),
          (this.minFilter = t.minFilter),
          (this.anisotropy = t.anisotropy),
          (this.format = t.format),
          (this.internalFormat = t.internalFormat),
          (this.type = t.type),
          this.offset.copy(t.offset),
          this.repeat.copy(t.repeat),
          this.center.copy(t.center),
          (this.rotation = t.rotation),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this.matrix.copy(t.matrix),
          (this.generateMipmaps = t.generateMipmaps),
          (this.premultiplyAlpha = t.premultiplyAlpha),
          (this.flipY = t.flipY),
          (this.unpackAlignment = t.unpackAlignment),
          (this.colorSpace = t.colorSpace),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          (this.needsUpdate = !0),
          this
        );
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        if (!e && void 0 !== t.textures[this.uuid])
          return t.textures[this.uuid];
        const n = {
          metadata: {
            version: 4.6,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(t).uuid,
          mapping: this.mapping,
          channel: this.channel,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          internalFormat: this.internalFormat,
          type: this.type,
          colorSpace: this.colorSpace,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          generateMipmaps: this.generateMipmaps,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment,
        };
        return (
          Object.keys(this.userData).length > 0 && (n.userData = this.userData),
          e || (t.textures[this.uuid] = n),
          n
        );
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
      transformUv(t) {
        if (300 !== this.mapping) return t;
        if ((t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1))
          switch (this.wrapS) {
            case 1e3:
              t.x = t.x - Math.floor(t.x);
              break;
            case 1001:
              t.x = t.x < 0 ? 0 : 1;
              break;
            case 1002:
              1 === Math.abs(Math.floor(t.x) % 2)
                ? (t.x = Math.ceil(t.x) - t.x)
                : (t.x = t.x - Math.floor(t.x));
          }
        if (t.y < 0 || t.y > 1)
          switch (this.wrapT) {
            case 1e3:
              t.y = t.y - Math.floor(t.y);
              break;
            case 1001:
              t.y = t.y < 0 ? 0 : 1;
              break;
            case 1002:
              1 === Math.abs(Math.floor(t.y) % 2)
                ? (t.y = Math.ceil(t.y) - t.y)
                : (t.y = t.y - Math.floor(t.y));
          }
        return this.flipY && (t.y = 1 - t.y), t;
      }
      set needsUpdate(t) {
        !0 === t && (this.version++, (this.source.needsUpdate = !0));
      }
      get encoding() {
        return (
          Yh(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          "srgb" === this.colorSpace ? 3001 : 3e3
        );
      }
      set encoding(t) {
        Yh(
          "THREE.Texture: Property .encoding has been replaced by .colorSpace."
        ),
          (this.colorSpace = 3001 === t ? "srgb" : "");
      }
    }
    (ld.DEFAULT_IMAGE = null),
      (ld.DEFAULT_MAPPING = 300),
      (ld.DEFAULT_ANISOTROPY = 1);
    class cd {
      constructor(t = 0, e = 0, n = 0, i = 1) {
        (cd.prototype.isVector4 = !0),
          (this.x = t),
          (this.y = e),
          (this.z = n),
          (this.w = i);
      }
      get width() {
        return this.z;
      }
      set width(t) {
        this.z = t;
      }
      get height() {
        return this.w;
      }
      set height(t) {
        this.w = t;
      }
      set(t, e, n, i) {
        return (this.x = t), (this.y = e), (this.z = n), (this.w = i), this;
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setZ(t) {
        return (this.z = t), this;
      }
      setW(t) {
        return (this.w = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copy(t) {
        return (
          (this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.w = void 0 !== t.w ? t.w : 1),
          this
        );
      }
      add(t) {
        return (
          (this.x += t.x),
          (this.y += t.y),
          (this.z += t.z),
          (this.w += t.w),
          this
        );
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
      }
      addVectors(t, e) {
        return (
          (this.x = t.x + e.x),
          (this.y = t.y + e.y),
          (this.z = t.z + e.z),
          (this.w = t.w + e.w),
          this
        );
      }
      addScaledVector(t, e) {
        return (
          (this.x += t.x * e),
          (this.y += t.y * e),
          (this.z += t.z * e),
          (this.w += t.w * e),
          this
        );
      }
      sub(t) {
        return (
          (this.x -= t.x),
          (this.y -= t.y),
          (this.z -= t.z),
          (this.w -= t.w),
          this
        );
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
      }
      subVectors(t, e) {
        return (
          (this.x = t.x - e.x),
          (this.y = t.y - e.y),
          (this.z = t.z - e.z),
          (this.w = t.w - e.w),
          this
        );
      }
      multiply(t) {
        return (
          (this.x *= t.x),
          (this.y *= t.y),
          (this.z *= t.z),
          (this.w *= t.w),
          this
        );
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
      }
      applyMatrix4(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = this.w,
          s = t.elements;
        return (
          (this.x = s[0] * e + s[4] * n + s[8] * i + s[12] * r),
          (this.y = s[1] * e + s[5] * n + s[9] * i + s[13] * r),
          (this.z = s[2] * e + s[6] * n + s[10] * i + s[14] * r),
          (this.w = s[3] * e + s[7] * n + s[11] * i + s[15] * r),
          this
        );
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      setAxisAngleFromQuaternion(t) {
        this.w = 2 * Math.acos(t.w);
        const e = Math.sqrt(1 - t.w * t.w);
        return (
          e < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
          this
        );
      }
      setAxisAngleFromRotationMatrix(t) {
        let e, n, i, r;
        const s = t.elements,
          o = s[0],
          a = s[4],
          l = s[8],
          c = s[1],
          u = s[5],
          h = s[9],
          d = s[2],
          p = s[6],
          f = s[10];
        if (
          Math.abs(a - c) < 0.01 &&
          Math.abs(l - d) < 0.01 &&
          Math.abs(h - p) < 0.01
        ) {
          if (
            Math.abs(a + c) < 0.1 &&
            Math.abs(l + d) < 0.1 &&
            Math.abs(h + p) < 0.1 &&
            Math.abs(o + u + f - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          const t = (o + 1) / 2,
            s = (u + 1) / 2,
            m = (f + 1) / 2,
            g = (a + c) / 4,
            v = (l + d) / 4,
            _ = (h + p) / 4;
          return (
            t > s && t > m
              ? t < 0.01
                ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                : ((n = Math.sqrt(t)), (i = g / n), (r = v / n))
              : s > m
              ? s < 0.01
                ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                : ((i = Math.sqrt(s)), (n = g / i), (r = _ / i))
              : m < 0.01
              ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
              : ((r = Math.sqrt(m)), (n = v / r), (i = _ / r)),
            this.set(n, i, r, e),
            this
          );
        }
        let m = Math.sqrt(
          (p - h) * (p - h) + (l - d) * (l - d) + (c - a) * (c - a)
        );
        return (
          Math.abs(m) < 0.001 && (m = 1),
          (this.x = (p - h) / m),
          (this.y = (l - d) / m),
          (this.z = (c - a) / m),
          (this.w = Math.acos((o + u + f - 1) / 2)),
          this
        );
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          (this.w = Math.min(this.w, t.w)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          (this.w = Math.max(this.w, t.w)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          (this.w = Math.max(t.w, Math.min(e.w, this.w))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          (this.w = Math.max(t, Math.min(e, this.w))),
          this
        );
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      }
      negate() {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      }
      lengthSq() {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      length() {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      }
      manhattanLength() {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          (this.w += (t.w - this.w) * e),
          this
        );
      }
      lerpVectors(t, e, n) {
        return (
          (this.x = t.x + (e.x - t.x) * n),
          (this.y = t.y + (e.y - t.y) * n),
          (this.z = t.z + (e.z - t.z) * n),
          (this.w = t.w + (e.w - t.w) * n),
          this
        );
      }
      equals(t) {
        return (
          t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        );
      }
      fromArray(t, e = 0) {
        return (
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          (this.w = t[e + 3]),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          (t[e + 3] = this.w),
          t
        );
      }
      fromBufferAttribute(t, e) {
        return (
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          (this.w = t.getW(e)),
          this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          (this.w = Math.random()),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w;
      }
    }
    class ud extends Ph {
      constructor(t = 1, e = 1, n = {}) {
        super(),
          (this.isRenderTarget = !0),
          (this.width = t),
          (this.height = e),
          (this.depth = 1),
          (this.scissor = new cd(0, 0, t, e)),
          (this.scissorTest = !1),
          (this.viewport = new cd(0, 0, t, e));
        const i = {
          width: t,
          height: e,
          depth: 1,
        };
        void 0 !== n.encoding &&
          (Yh(
            "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
          ),
          (n.colorSpace = 3001 === n.encoding ? "srgb" : "")),
          (this.texture = new ld(
            i,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.colorSpace
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.flipY = !1),
          (this.texture.generateMipmaps =
            void 0 !== n.generateMipmaps && n.generateMipmaps),
          (this.texture.internalFormat =
            void 0 !== n.internalFormat ? n.internalFormat : null),
          (this.texture.minFilter =
            void 0 !== n.minFilter ? n.minFilter : 1006),
          (this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer),
          (this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer),
          (this.depthTexture =
            void 0 !== n.depthTexture ? n.depthTexture : null),
          (this.samples = void 0 !== n.samples ? n.samples : 0);
      }
      setSize(t, e, n = 1) {
        (this.width === t && this.height === e && this.depth === n) ||
          ((this.width = t),
          (this.height = e),
          (this.depth = n),
          (this.texture.image.width = t),
          (this.texture.image.height = e),
          (this.texture.image.depth = n),
          this.dispose()),
          this.viewport.set(0, 0, t, e),
          this.scissor.set(0, 0, t, e);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        (this.width = t.width),
          (this.height = t.height),
          (this.depth = t.depth),
          this.scissor.copy(t.scissor),
          (this.scissorTest = t.scissorTest),
          this.viewport.copy(t.viewport),
          (this.texture = t.texture.clone()),
          (this.texture.isRenderTargetTexture = !0);
        const e = Object.assign({}, t.texture.image);
        return (
          (this.texture.source = new sd(e)),
          (this.depthBuffer = t.depthBuffer),
          (this.stencilBuffer = t.stencilBuffer),
          null !== t.depthTexture &&
            (this.depthTexture = t.depthTexture.clone()),
          (this.samples = t.samples),
          this
        );
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
    }
    class hd extends ud {
      constructor(t = 1, e = 1, n = {}) {
        super(t, e, n), (this.isWebGLRenderTarget = !0);
      }
    }
    class dd extends ld {
      constructor(t = null, e = 1, n = 1, i = 1) {
        super(null),
          (this.isDataArrayTexture = !0),
          (this.image = {
            data: t,
            width: e,
            height: n,
            depth: i,
          }),
          (this.magFilter = 1003),
          (this.minFilter = 1003),
          (this.wrapR = 1001),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    class pd extends ld {
      constructor(t = null, e = 1, n = 1, i = 1) {
        super(null),
          (this.isData3DTexture = !0),
          (this.image = {
            data: t,
            width: e,
            height: n,
            depth: i,
          }),
          (this.magFilter = 1003),
          (this.minFilter = 1003),
          (this.wrapR = 1001),
          (this.generateMipmaps = !1),
          (this.flipY = !1),
          (this.unpackAlignment = 1);
      }
    }
    class fd {
      constructor(t = 0, e = 0, n = 0, i = 1) {
        (this.isQuaternion = !0),
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._w = i);
      }
      static slerpFlat(t, e, n, i, r, s, o) {
        let a = n[i + 0],
          l = n[i + 1],
          c = n[i + 2],
          u = n[i + 3];
        const h = r[s + 0],
          d = r[s + 1],
          p = r[s + 2],
          f = r[s + 3];
        if (0 === o)
          return (
            (t[e + 0] = a), (t[e + 1] = l), (t[e + 2] = c), void (t[e + 3] = u)
          );
        if (1 === o)
          return (
            (t[e + 0] = h), (t[e + 1] = d), (t[e + 2] = p), void (t[e + 3] = f)
          );
        if (u !== f || a !== h || l !== d || c !== p) {
          let t = 1 - o;
          const e = a * h + l * d + c * p + u * f,
            n = e >= 0 ? 1 : -1,
            i = 1 - e * e;
          if (i > Number.EPSILON) {
            const r = Math.sqrt(i),
              s = Math.atan2(r, e * n);
            (t = Math.sin(t * s) / r), (o = Math.sin(o * s) / r);
          }
          const r = o * n;
          if (
            ((a = a * t + h * r),
            (l = l * t + d * r),
            (c = c * t + p * r),
            (u = u * t + f * r),
            t === 1 - o)
          ) {
            const t = 1 / Math.sqrt(a * a + l * l + c * c + u * u);
            (a *= t), (l *= t), (c *= t), (u *= t);
          }
        }
        (t[e] = a), (t[e + 1] = l), (t[e + 2] = c), (t[e + 3] = u);
      }
      static multiplyQuaternionsFlat(t, e, n, i, r, s) {
        const o = n[i],
          a = n[i + 1],
          l = n[i + 2],
          c = n[i + 3],
          u = r[s],
          h = r[s + 1],
          d = r[s + 2],
          p = r[s + 3];
        return (
          (t[e] = o * p + c * u + a * d - l * h),
          (t[e + 1] = a * p + c * h + l * u - o * d),
          (t[e + 2] = l * p + c * d + o * h - a * u),
          (t[e + 3] = c * p - o * u - a * h - l * d),
          t
        );
      }
      get x() {
        return this._x;
      }
      set x(t) {
        (this._x = t), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(t) {
        (this._y = t), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(t) {
        (this._z = t), this._onChangeCallback();
      }
      get w() {
        return this._w;
      }
      set w(t) {
        (this._w = t), this._onChangeCallback();
      }
      set(t, e, n, i) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._w = i),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copy(t) {
        return (
          (this._x = t.x),
          (this._y = t.y),
          (this._z = t.z),
          (this._w = t.w),
          this._onChangeCallback(),
          this
        );
      }
      setFromEuler(t, e) {
        const n = t._x,
          i = t._y,
          r = t._z,
          s = t._order,
          o = Math.cos,
          a = Math.sin,
          l = o(n / 2),
          c = o(i / 2),
          u = o(r / 2),
          h = a(n / 2),
          d = a(i / 2),
          p = a(r / 2);
        switch (s) {
          case "XYZ":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "YXZ":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          case "ZXY":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "ZYX":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          case "YZX":
            (this._x = h * c * u + l * d * p),
              (this._y = l * d * u + h * c * p),
              (this._z = l * c * p - h * d * u),
              (this._w = l * c * u - h * d * p);
            break;
          case "XZY":
            (this._x = h * c * u - l * d * p),
              (this._y = l * d * u - h * c * p),
              (this._z = l * c * p + h * d * u),
              (this._w = l * c * u + h * d * p);
            break;
          default:
            console.warn(
              "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                s
            );
        }
        return !1 !== e && this._onChangeCallback(), this;
      }
      setFromAxisAngle(t, e) {
        const n = e / 2,
          i = Math.sin(n);
        return (
          (this._x = t.x * i),
          (this._y = t.y * i),
          (this._z = t.z * i),
          (this._w = Math.cos(n)),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(t) {
        const e = t.elements,
          n = e[0],
          i = e[4],
          r = e[8],
          s = e[1],
          o = e[5],
          a = e[9],
          l = e[2],
          c = e[6],
          u = e[10],
          h = n + o + u;
        if (h > 0) {
          const t = 0.5 / Math.sqrt(h + 1);
          (this._w = 0.25 / t),
            (this._x = (c - a) * t),
            (this._y = (r - l) * t),
            (this._z = (s - i) * t);
        } else if (n > o && n > u) {
          const t = 2 * Math.sqrt(1 + n - o - u);
          (this._w = (c - a) / t),
            (this._x = 0.25 * t),
            (this._y = (i + s) / t),
            (this._z = (r + l) / t);
        } else if (o > u) {
          const t = 2 * Math.sqrt(1 + o - n - u);
          (this._w = (r - l) / t),
            (this._x = (i + s) / t),
            (this._y = 0.25 * t),
            (this._z = (a + c) / t);
        } else {
          const t = 2 * Math.sqrt(1 + u - n - o);
          (this._w = (s - i) / t),
            (this._x = (r + l) / t),
            (this._y = (a + c) / t),
            (this._z = 0.25 * t);
        }
        return this._onChangeCallback(), this;
      }
      setFromUnitVectors(t, e) {
        let n = t.dot(e) + 1;
        return (
          n < Number.EPSILON
            ? ((n = 0),
              Math.abs(t.x) > Math.abs(t.z)
                ? ((this._x = -t.y),
                  (this._y = t.x),
                  (this._z = 0),
                  (this._w = n))
                : ((this._x = 0),
                  (this._y = -t.z),
                  (this._z = t.y),
                  (this._w = n)))
            : ((this._x = t.y * e.z - t.z * e.y),
              (this._y = t.z * e.x - t.x * e.z),
              (this._z = t.x * e.y - t.y * e.x),
              (this._w = n)),
          this.normalize()
        );
      }
      angleTo(t) {
        return 2 * Math.acos(Math.abs(Fh(this.dot(t), -1, 1)));
      }
      rotateTowards(t, e) {
        const n = this.angleTo(t);
        if (0 === n) return this;
        const i = Math.min(1, e / n);
        return this.slerp(t, i), this;
      }
      identity() {
        return this.set(0, 0, 0, 1);
      }
      invert() {
        return this.conjugate();
      }
      conjugate() {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this._onChangeCallback(),
          this
        );
      }
      dot(t) {
        return (
          this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        );
      }
      lengthSq() {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      }
      length() {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
        );
      }
      normalize() {
        let t = this.length();
        return (
          0 === t
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((t = 1 / t),
              (this._x = this._x * t),
              (this._y = this._y * t),
              (this._z = this._z * t),
              (this._w = this._w * t)),
          this._onChangeCallback(),
          this
        );
      }
      multiply(t) {
        return this.multiplyQuaternions(this, t);
      }
      premultiply(t) {
        return this.multiplyQuaternions(t, this);
      }
      multiplyQuaternions(t, e) {
        const n = t._x,
          i = t._y,
          r = t._z,
          s = t._w,
          o = e._x,
          a = e._y,
          l = e._z,
          c = e._w;
        return (
          (this._x = n * c + s * o + i * l - r * a),
          (this._y = i * c + s * a + r * o - n * l),
          (this._z = r * c + s * l + n * a - i * o),
          (this._w = s * c - n * o - i * a - r * l),
          this._onChangeCallback(),
          this
        );
      }
      slerp(t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        const n = this._x,
          i = this._y,
          r = this._z,
          s = this._w;
        let o = s * t._w + n * t._x + i * t._y + r * t._z;
        if (
          (o < 0
            ? ((this._w = -t._w),
              (this._x = -t._x),
              (this._y = -t._y),
              (this._z = -t._z),
              (o = -o))
            : this.copy(t),
          o >= 1)
        )
          return (
            (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
          );
        const a = 1 - o * o;
        if (a <= Number.EPSILON) {
          const t = 1 - e;
          return (
            (this._w = t * s + e * this._w),
            (this._x = t * n + e * this._x),
            (this._y = t * i + e * this._y),
            (this._z = t * r + e * this._z),
            this.normalize(),
            this._onChangeCallback(),
            this
          );
        }
        const l = Math.sqrt(a),
          c = Math.atan2(l, o),
          u = Math.sin((1 - e) * c) / l,
          h = Math.sin(e * c) / l;
        return (
          (this._w = s * u + this._w * h),
          (this._x = n * u + this._x * h),
          (this._y = i * u + this._y * h),
          (this._z = r * u + this._z * h),
          this._onChangeCallback(),
          this
        );
      }
      slerpQuaternions(t, e, n) {
        return this.copy(t).slerp(e, n);
      }
      random() {
        const t = Math.random(),
          e = Math.sqrt(1 - t),
          n = Math.sqrt(t),
          i = 2 * Math.PI * Math.random(),
          r = 2 * Math.PI * Math.random();
        return this.set(
          e * Math.cos(i),
          n * Math.sin(r),
          n * Math.cos(r),
          e * Math.sin(i)
        );
      }
      equals(t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._w === this._w
        );
      }
      fromArray(t, e = 0) {
        return (
          (this._x = t[e]),
          (this._y = t[e + 1]),
          (this._z = t[e + 2]),
          (this._w = t[e + 3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._w),
          t
        );
      }
      fromBufferAttribute(t, e) {
        return (
          (this._x = t.getX(e)),
          (this._y = t.getY(e)),
          (this._z = t.getZ(e)),
          (this._w = t.getW(e)),
          this
        );
      }
      toJSON() {
        return this.toArray();
      }
      _onChange(t) {
        return (this._onChangeCallback = t), this;
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w;
      }
    }
    class md {
      constructor(t = 0, e = 0, n = 0) {
        (md.prototype.isVector3 = !0), (this.x = t), (this.y = e), (this.z = n);
      }
      set(t, e, n) {
        return (
          void 0 === n && (n = this.z),
          (this.x = t),
          (this.y = e),
          (this.z = n),
          this
        );
      }
      setScalar(t) {
        return (this.x = t), (this.y = t), (this.z = t), this;
      }
      setX(t) {
        return (this.x = t), this;
      }
      setY(t) {
        return (this.y = t), this;
      }
      setZ(t) {
        return (this.z = t), this;
      }
      setComponent(t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error("index is out of range: " + t);
        }
        return this;
      }
      getComponent(t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out of range: " + t);
        }
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
      copy(t) {
        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
      }
      add(t) {
        return (this.x += t.x), (this.y += t.y), (this.z += t.z), this;
      }
      addScalar(t) {
        return (this.x += t), (this.y += t), (this.z += t), this;
      }
      addVectors(t, e) {
        return (
          (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this
        );
      }
      addScaledVector(t, e) {
        return (
          (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this
        );
      }
      sub(t) {
        return (this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this;
      }
      subScalar(t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), this;
      }
      subVectors(t, e) {
        return (
          (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this
        );
      }
      multiply(t) {
        return (this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this;
      }
      multiplyScalar(t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), this;
      }
      multiplyVectors(t, e) {
        return (
          (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this
        );
      }
      applyEuler(t) {
        return this.applyQuaternion(vd.setFromEuler(t));
      }
      applyAxisAngle(t, e) {
        return this.applyQuaternion(vd.setFromAxisAngle(t, e));
      }
      applyMatrix3(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[3] * n + r[6] * i),
          (this.y = r[1] * e + r[4] * n + r[7] * i),
          (this.z = r[2] * e + r[5] * n + r[8] * i),
          this
        );
      }
      applyNormalMatrix(t) {
        return this.applyMatrix3(t).normalize();
      }
      applyMatrix4(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements,
          s = 1 / (r[3] * e + r[7] * n + r[11] * i + r[15]);
        return (
          (this.x = (r[0] * e + r[4] * n + r[8] * i + r[12]) * s),
          (this.y = (r[1] * e + r[5] * n + r[9] * i + r[13]) * s),
          (this.z = (r[2] * e + r[6] * n + r[10] * i + r[14]) * s),
          this
        );
      }
      applyQuaternion(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.x,
          s = t.y,
          o = t.z,
          a = t.w,
          l = a * e + s * i - o * n,
          c = a * n + o * e - r * i,
          u = a * i + r * n - s * e,
          h = -r * e - s * n - o * i;
        return (
          (this.x = l * a + h * -r + c * -o - u * -s),
          (this.y = c * a + h * -s + u * -r - l * -o),
          (this.z = u * a + h * -o + l * -s - c * -r),
          this
        );
      }
      project(t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(
          t.projectionMatrix
        );
      }
      unproject(t) {
        return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(
          t.matrixWorld
        );
      }
      transformDirection(t) {
        const e = this.x,
          n = this.y,
          i = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[4] * n + r[8] * i),
          (this.y = r[1] * e + r[5] * n + r[9] * i),
          (this.z = r[2] * e + r[6] * n + r[10] * i),
          this.normalize()
        );
      }
      divide(t) {
        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
      }
      divideScalar(t) {
        return this.multiplyScalar(1 / t);
      }
      min(t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      }
      max(t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      }
      clamp(t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      }
      clampScalar(t, e) {
        return (
          (this.x = Math.max(t, Math.min(e, this.x))),
          (this.y = Math.max(t, Math.min(e, this.y))),
          (this.z = Math.max(t, Math.min(e, this.z))),
          this
        );
      }
      clampLength(t, e) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(
          Math.max(t, Math.min(e, n))
        );
      }
      floor() {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      }
      ceil() {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      }
      round() {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      }
      roundToZero() {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      }
      negate() {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      }
      dot(t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      }
      lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
      manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
      normalize() {
        return this.divideScalar(this.length() || 1);
      }
      setLength(t) {
        return this.normalize().multiplyScalar(t);
      }
      lerp(t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          this
        );
      }
      lerpVectors(t, e, n) {
        return (
          (this.x = t.x + (e.x - t.x) * n),
          (this.y = t.y + (e.y - t.y) * n),
          (this.z = t.z + (e.z - t.z) * n),
          this
        );
      }
      cross(t) {
        return this.crossVectors(this, t);
      }
      crossVectors(t, e) {
        const n = t.x,
          i = t.y,
          r = t.z,
          s = e.x,
          o = e.y,
          a = e.z;
        return (
          (this.x = i * a - r * o),
          (this.y = r * s - n * a),
          (this.z = n * o - i * s),
          this
        );
      }
      projectOnVector(t) {
        const e = t.lengthSq();
        if (0 === e) return this.set(0, 0, 0);
        const n = t.dot(this) / e;
        return this.copy(t).multiplyScalar(n);
      }
      projectOnPlane(t) {
        return gd.copy(this).projectOnVector(t), this.sub(gd);
      }
      reflect(t) {
        return this.sub(gd.copy(t).multiplyScalar(2 * this.dot(t)));
      }
      angleTo(t) {
        const e = Math.sqrt(this.lengthSq() * t.lengthSq());
        if (0 === e) return Math.PI / 2;
        const n = this.dot(t) / e;
        return Math.acos(Fh(n, -1, 1));
      }
      distanceTo(t) {
        return Math.sqrt(this.distanceToSquared(t));
      }
      distanceToSquared(t) {
        const e = this.x - t.x,
          n = this.y - t.y,
          i = this.z - t.z;
        return e * e + n * n + i * i;
      }
      manhattanDistanceTo(t) {
        return (
          Math.abs(this.x - t.x) +
          Math.abs(this.y - t.y) +
          Math.abs(this.z - t.z)
        );
      }
      setFromSpherical(t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      }
      setFromSphericalCoords(t, e, n) {
        const i = Math.sin(e) * t;
        return (
          (this.x = i * Math.sin(n)),
          (this.y = Math.cos(e) * t),
          (this.z = i * Math.cos(n)),
          this
        );
      }
      setFromCylindrical(t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      }
      setFromCylindricalCoords(t, e, n) {
        return (
          (this.x = t * Math.sin(e)),
          (this.y = n),
          (this.z = t * Math.cos(e)),
          this
        );
      }
      setFromMatrixPosition(t) {
        const e = t.elements;
        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
      }
      setFromMatrixScale(t) {
        const e = this.setFromMatrixColumn(t, 0).length(),
          n = this.setFromMatrixColumn(t, 1).length(),
          i = this.setFromMatrixColumn(t, 2).length();
        return (this.x = e), (this.y = n), (this.z = i), this;
      }
      setFromMatrixColumn(t, e) {
        return this.fromArray(t.elements, 4 * e);
      }
      setFromMatrix3Column(t, e) {
        return this.fromArray(t.elements, 3 * e);
      }
      setFromEuler(t) {
        return (this.x = t._x), (this.y = t._y), (this.z = t._z), this;
      }
      setFromColor(t) {
        return (this.x = t.r), (this.y = t.g), (this.z = t.b), this;
      }
      equals(t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      }
      fromArray(t, e = 0) {
        return (this.x = t[e]), (this.y = t[e + 1]), (this.z = t[e + 2]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.x), (t[e + 1] = this.y), (t[e + 2] = this.z), t;
      }
      fromBufferAttribute(t, e) {
        return (
          (this.x = t.getX(e)), (this.y = t.getY(e)), (this.z = t.getZ(e)), this
        );
      }
      random() {
        return (
          (this.x = Math.random()),
          (this.y = Math.random()),
          (this.z = Math.random()),
          this
        );
      }
      randomDirection() {
        const t = 2 * (Math.random() - 0.5),
          e = Math.random() * Math.PI * 2,
          n = Math.sqrt(1 - t ** 2);
        return (
          (this.x = n * Math.cos(e)),
          (this.y = n * Math.sin(e)),
          (this.z = t),
          this
        );
      }
      *[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z;
      }
    }
    const gd = new md(),
      vd = new fd();
    class _d {
      constructor(
        t = new md(1 / 0, 1 / 0, 1 / 0),
        e = new md(-1 / 0, -1 / 0, -1 / 0)
      ) {
        (this.isBox3 = !0), (this.min = t), (this.max = e);
      }
      set(t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      }
      setFromArray(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e += 3)
          this.expandByPoint(xd.fromArray(t, e));
        return this;
      }
      setFromBufferAttribute(t) {
        this.makeEmpty();
        for (let e = 0, n = t.count; e < n; e++)
          this.expandByPoint(xd.fromBufferAttribute(t, e));
        return this;
      }
      setFromPoints(t) {
        this.makeEmpty();
        for (let e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
        return this;
      }
      setFromCenterAndSize(t, e) {
        const n = xd.copy(e).multiplyScalar(0.5);
        return this.min.copy(t).sub(n), this.max.copy(t).add(n), this;
      }
      setFromObject(t, e = !1) {
        return this.makeEmpty(), this.expandByObject(t, e);
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      }
      makeEmpty() {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      }
      isEmpty() {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      }
      getCenter(t) {
        return this.isEmpty()
          ? t.set(0, 0, 0)
          : t.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
      getSize(t) {
        return this.isEmpty()
          ? t.set(0, 0, 0)
          : t.subVectors(this.max, this.min);
      }
      expandByPoint(t) {
        return this.min.min(t), this.max.max(t), this;
      }
      expandByVector(t) {
        return this.min.sub(t), this.max.add(t), this;
      }
      expandByScalar(t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      }
      expandByObject(t, e = !1) {
        if ((t.updateWorldMatrix(!1, !1), void 0 !== t.boundingBox))
          null === t.boundingBox && t.computeBoundingBox(),
            bd.copy(t.boundingBox),
            bd.applyMatrix4(t.matrixWorld),
            this.union(bd);
        else {
          const n = t.geometry;
          if (void 0 !== n)
            if (
              e &&
              void 0 !== n.attributes &&
              void 0 !== n.attributes.position
            ) {
              const e = n.attributes.position;
              for (let n = 0, i = e.count; n < i; n++)
                xd.fromBufferAttribute(e, n).applyMatrix4(t.matrixWorld),
                  this.expandByPoint(xd);
            } else
              null === n.boundingBox && n.computeBoundingBox(),
                bd.copy(n.boundingBox),
                bd.applyMatrix4(t.matrixWorld),
                this.union(bd);
        }
        const n = t.children;
        for (let t = 0, i = n.length; t < i; t++) this.expandByObject(n[t], e);
        return this;
      }
      containsPoint(t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      }
      containsBox(t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      }
      getParameter(t, e) {
        return e.set(
          (t.x - this.min.x) / (this.max.x - this.min.x),
          (t.y - this.min.y) / (this.max.y - this.min.y),
          (t.z - this.min.z) / (this.max.z - this.min.z)
        );
      }
      intersectsBox(t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      }
      intersectsSphere(t) {
        return (
          this.clampPoint(t.center, xd),
          xd.distanceToSquared(t.center) <= t.radius * t.radius
        );
      }
      intersectsPlane(t) {
        let e, n;
        return (
          t.normal.x > 0
            ? ((e = t.normal.x * this.min.x), (n = t.normal.x * this.max.x))
            : ((e = t.normal.x * this.max.x), (n = t.normal.x * this.min.x)),
          t.normal.y > 0
            ? ((e += t.normal.y * this.min.y), (n += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (n += t.normal.y * this.min.y)),
          t.normal.z > 0
            ? ((e += t.normal.z * this.min.z), (n += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (n += t.normal.z * this.min.z)),
          e <= -t.constant && n >= -t.constant
        );
      }
      intersectsTriangle(t) {
        if (this.isEmpty()) return !1;
        this.getCenter(Ad),
          Cd.subVectors(this.max, Ad),
          Sd.subVectors(t.a, Ad),
          Ed.subVectors(t.b, Ad),
          Md.subVectors(t.c, Ad),
          Td.subVectors(Ed, Sd),
          wd.subVectors(Md, Ed),
          Dd.subVectors(Sd, Md);
        let e = [
          0,
          -Td.z,
          Td.y,
          0,
          -wd.z,
          wd.y,
          0,
          -Dd.z,
          Dd.y,
          Td.z,
          0,
          -Td.x,
          wd.z,
          0,
          -wd.x,
          Dd.z,
          0,
          -Dd.x,
          -Td.y,
          Td.x,
          0,
          -wd.y,
          wd.x,
          0,
          -Dd.y,
          Dd.x,
          0,
        ];
        return (
          !!Ld(e, Sd, Ed, Md, Cd) &&
          ((e = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
          !!Ld(e, Sd, Ed, Md, Cd) &&
            (Pd.crossVectors(Td, wd),
            (e = [Pd.x, Pd.y, Pd.z]),
            Ld(e, Sd, Ed, Md, Cd)))
        );
      }
      clampPoint(t, e) {
        return e.copy(t).clamp(this.min, this.max);
      }
      distanceToPoint(t) {
        return this.clampPoint(t, xd).distanceTo(t);
      }
      getBoundingSphere(t) {
        return (
          this.isEmpty()
            ? t.makeEmpty()
            : (this.getCenter(t.center),
              (t.radius = 0.5 * this.getSize(xd).length())),
          t
        );
      }
      intersect(t) {
        return (
          this.min.max(t.min),
          this.max.min(t.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      }
      union(t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      }
      applyMatrix4(t) {
        return (
          this.isEmpty() ||
            (yd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            yd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            yd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            yd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            yd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            yd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            yd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            yd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.setFromPoints(yd)),
          this
        );
      }
      translate(t) {
        return this.min.add(t), this.max.add(t), this;
      }
      equals(t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }
    const yd = [
        new md(),
        new md(),
        new md(),
        new md(),
        new md(),
        new md(),
        new md(),
        new md(),
      ],
      xd = new md(),
      bd = new _d(),
      Sd = new md(),
      Ed = new md(),
      Md = new md(),
      Td = new md(),
      wd = new md(),
      Dd = new md(),
      Ad = new md(),
      Cd = new md(),
      Pd = new md(),
      Rd = new md();
    function Ld(t, e, n, i, r) {
      for (let s = 0, o = t.length - 3; s <= o; s += 3) {
        Rd.fromArray(t, s);
        const o =
            r.x * Math.abs(Rd.x) + r.y * Math.abs(Rd.y) + r.z * Math.abs(Rd.z),
          a = e.dot(Rd),
          l = n.dot(Rd),
          c = i.dot(Rd);
        if (Math.max(-Math.max(a, l, c), Math.min(a, l, c)) > o) return !1;
      }
      return !0;
    }
    const Od = new _d(),
      Id = new md(),
      Fd = new md();
    class Ud {
      constructor(t = new md(), e = -1) {
        (this.center = t), (this.radius = e);
      }
      set(t, e) {
        return this.center.copy(t), (this.radius = e), this;
      }
      setFromPoints(t, e) {
        const n = this.center;
        void 0 !== e ? n.copy(e) : Od.setFromPoints(t).getCenter(n);
        let i = 0;
        for (let e = 0, r = t.length; e < r; e++)
          i = Math.max(i, n.distanceToSquared(t[e]));
        return (this.radius = Math.sqrt(i)), this;
      }
      copy(t) {
        return this.center.copy(t.center), (this.radius = t.radius), this;
      }
      isEmpty() {
        return this.radius < 0;
      }
      makeEmpty() {
        return this.center.set(0, 0, 0), (this.radius = -1), this;
      }
      containsPoint(t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      }
      distanceToPoint(t) {
        return t.distanceTo(this.center) - this.radius;
      }
      intersectsSphere(t) {
        const e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      }
      intersectsBox(t) {
        return t.intersectsSphere(this);
      }
      intersectsPlane(t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      }
      clampPoint(t, e) {
        const n = this.center.distanceToSquared(t);
        return (
          e.copy(t),
          n > this.radius * this.radius &&
            (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
          e
        );
      }
      getBoundingBox(t) {
        return this.isEmpty()
          ? (t.makeEmpty(), t)
          : (t.set(this.center, this.center), t.expandByScalar(this.radius), t);
      }
      applyMatrix4(t) {
        return (
          this.center.applyMatrix4(t),
          (this.radius = this.radius * t.getMaxScaleOnAxis()),
          this
        );
      }
      translate(t) {
        return this.center.add(t), this;
      }
      expandByPoint(t) {
        if (this.isEmpty()) return this.center.copy(t), (this.radius = 0), this;
        Id.subVectors(t, this.center);
        const e = Id.lengthSq();
        if (e > this.radius * this.radius) {
          const t = Math.sqrt(e),
            n = 0.5 * (t - this.radius);
          this.center.addScaledVector(Id, n / t), (this.radius += n);
        }
        return this;
      }
      union(t) {
        return t.isEmpty()
          ? this
          : this.isEmpty()
          ? (this.copy(t), this)
          : (!0 === this.center.equals(t.center)
              ? (this.radius = Math.max(this.radius, t.radius))
              : (Fd.subVectors(t.center, this.center).setLength(t.radius),
                this.expandByPoint(Id.copy(t.center).add(Fd)),
                this.expandByPoint(Id.copy(t.center).sub(Fd))),
            this);
      }
      equals(t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Nd = new md(),
      kd = new md(),
      zd = new md(),
      Bd = new md(),
      Hd = new md(),
      Vd = new md(),
      Gd = new md();
    class Wd {
      constructor(t = new md(), e = new md(0, 0, -1)) {
        (this.origin = t), (this.direction = e);
      }
      set(t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      }
      copy(t) {
        return (
          this.origin.copy(t.origin), this.direction.copy(t.direction), this
        );
      }
      at(t, e) {
        return e.copy(this.origin).addScaledVector(this.direction, t);
      }
      lookAt(t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      }
      recast(t) {
        return this.origin.copy(this.at(t, Nd)), this;
      }
      closestPointToPoint(t, e) {
        e.subVectors(t, this.origin);
        const n = e.dot(this.direction);
        return n < 0
          ? e.copy(this.origin)
          : e.copy(this.origin).addScaledVector(this.direction, n);
      }
      distanceToPoint(t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      }
      distanceSqToPoint(t) {
        const e = Nd.subVectors(t, this.origin).dot(this.direction);
        return e < 0
          ? this.origin.distanceToSquared(t)
          : (Nd.copy(this.origin).addScaledVector(this.direction, e),
            Nd.distanceToSquared(t));
      }
      distanceSqToSegment(t, e, n, i) {
        kd.copy(t).add(e).multiplyScalar(0.5),
          zd.copy(e).sub(t).normalize(),
          Bd.copy(this.origin).sub(kd);
        const r = 0.5 * t.distanceTo(e),
          s = -this.direction.dot(zd),
          o = Bd.dot(this.direction),
          a = -Bd.dot(zd),
          l = Bd.lengthSq(),
          c = Math.abs(1 - s * s);
        let u, h, d, p;
        if (c > 0)
          if (((u = s * a - o), (h = s * o - a), (p = r * c), u >= 0))
            if (h >= -p)
              if (h <= p) {
                const t = 1 / c;
                (u *= t),
                  (h *= t),
                  (d = u * (u + s * h + 2 * o) + h * (s * u + h + 2 * a) + l);
              } else
                (h = r),
                  (u = Math.max(0, -(s * h + o))),
                  (d = -u * u + h * (h + 2 * a) + l);
            else
              (h = -r),
                (u = Math.max(0, -(s * h + o))),
                (d = -u * u + h * (h + 2 * a) + l);
          else
            h <= -p
              ? ((u = Math.max(0, -(-s * r + o))),
                (h = u > 0 ? -r : Math.min(Math.max(-r, -a), r)),
                (d = -u * u + h * (h + 2 * a) + l))
              : h <= p
              ? ((u = 0),
                (h = Math.min(Math.max(-r, -a), r)),
                (d = h * (h + 2 * a) + l))
              : ((u = Math.max(0, -(s * r + o))),
                (h = u > 0 ? r : Math.min(Math.max(-r, -a), r)),
                (d = -u * u + h * (h + 2 * a) + l));
        else
          (h = s > 0 ? -r : r),
            (u = Math.max(0, -(s * h + o))),
            (d = -u * u + h * (h + 2 * a) + l);
        return (
          n && n.copy(this.origin).addScaledVector(this.direction, u),
          i && i.copy(kd).addScaledVector(zd, h),
          d
        );
      }
      intersectSphere(t, e) {
        Nd.subVectors(t.center, this.origin);
        const n = Nd.dot(this.direction),
          i = Nd.dot(Nd) - n * n,
          r = t.radius * t.radius;
        if (i > r) return null;
        const s = Math.sqrt(r - i),
          o = n - s,
          a = n + s;
        return a < 0 ? null : o < 0 ? this.at(a, e) : this.at(o, e);
      }
      intersectsSphere(t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      }
      distanceToPlane(t) {
        const e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        const n = -(this.origin.dot(t.normal) + t.constant) / e;
        return n >= 0 ? n : null;
      }
      intersectPlane(t, e) {
        const n = this.distanceToPlane(t);
        return null === n ? null : this.at(n, e);
      }
      intersectsPlane(t) {
        const e = t.distanceToPoint(this.origin);
        if (0 === e) return !0;
        return t.normal.dot(this.direction) * e < 0;
      }
      intersectBox(t, e) {
        let n, i, r, s, o, a;
        const l = 1 / this.direction.x,
          c = 1 / this.direction.y,
          u = 1 / this.direction.z,
          h = this.origin;
        return (
          l >= 0
            ? ((n = (t.min.x - h.x) * l), (i = (t.max.x - h.x) * l))
            : ((n = (t.max.x - h.x) * l), (i = (t.min.x - h.x) * l)),
          c >= 0
            ? ((r = (t.min.y - h.y) * c), (s = (t.max.y - h.y) * c))
            : ((r = (t.max.y - h.y) * c), (s = (t.min.y - h.y) * c)),
          n > s || r > i
            ? null
            : ((r > n || isNaN(n)) && (n = r),
              (s < i || isNaN(i)) && (i = s),
              u >= 0
                ? ((o = (t.min.z - h.z) * u), (a = (t.max.z - h.z) * u))
                : ((o = (t.max.z - h.z) * u), (a = (t.min.z - h.z) * u)),
              n > a || o > i
                ? null
                : ((o > n || n != n) && (n = o),
                  (a < i || i != i) && (i = a),
                  i < 0 ? null : this.at(n >= 0 ? n : i, e)))
        );
      }
      intersectsBox(t) {
        return null !== this.intersectBox(t, Nd);
      }
      intersectTriangle(t, e, n, i, r) {
        Hd.subVectors(e, t), Vd.subVectors(n, t), Gd.crossVectors(Hd, Vd);
        let s,
          o = this.direction.dot(Gd);
        if (o > 0) {
          if (i) return null;
          s = 1;
        } else {
          if (!(o < 0)) return null;
          (s = -1), (o = -o);
        }
        Bd.subVectors(this.origin, t);
        const a = s * this.direction.dot(Vd.crossVectors(Bd, Vd));
        if (a < 0) return null;
        const l = s * this.direction.dot(Hd.cross(Bd));
        if (l < 0) return null;
        if (a + l > o) return null;
        const c = -s * Bd.dot(Gd);
        return c < 0 ? null : this.at(c / o, r);
      }
      applyMatrix4(t) {
        return (
          this.origin.applyMatrix4(t),
          this.direction.transformDirection(t),
          this
        );
      }
      equals(t) {
        return (
          t.origin.equals(this.origin) && t.direction.equals(this.direction)
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class jd {
      constructor(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
        (jd.prototype.isMatrix4 = !0),
          (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
          void 0 !== t &&
            this.set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m);
      }
      set(t, e, n, i, r, s, o, a, l, c, u, h, d, p, f, m) {
        const g = this.elements;
        return (
          (g[0] = t),
          (g[4] = e),
          (g[8] = n),
          (g[12] = i),
          (g[1] = r),
          (g[5] = s),
          (g[9] = o),
          (g[13] = a),
          (g[2] = l),
          (g[6] = c),
          (g[10] = u),
          (g[14] = h),
          (g[3] = d),
          (g[7] = p),
          (g[11] = f),
          (g[15] = m),
          this
        );
      }
      identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      clone() {
        return new jd().fromArray(this.elements);
      }
      copy(t) {
        const e = this.elements,
          n = t.elements;
        return (
          (e[0] = n[0]),
          (e[1] = n[1]),
          (e[2] = n[2]),
          (e[3] = n[3]),
          (e[4] = n[4]),
          (e[5] = n[5]),
          (e[6] = n[6]),
          (e[7] = n[7]),
          (e[8] = n[8]),
          (e[9] = n[9]),
          (e[10] = n[10]),
          (e[11] = n[11]),
          (e[12] = n[12]),
          (e[13] = n[13]),
          (e[14] = n[14]),
          (e[15] = n[15]),
          this
        );
      }
      copyPosition(t) {
        const e = this.elements,
          n = t.elements;
        return (e[12] = n[12]), (e[13] = n[13]), (e[14] = n[14]), this;
      }
      setFromMatrix3(t) {
        const e = t.elements;
        return (
          this.set(
            e[0],
            e[3],
            e[6],
            0,
            e[1],
            e[4],
            e[7],
            0,
            e[2],
            e[5],
            e[8],
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractBasis(t, e, n) {
        return (
          t.setFromMatrixColumn(this, 0),
          e.setFromMatrixColumn(this, 1),
          n.setFromMatrixColumn(this, 2),
          this
        );
      }
      makeBasis(t, e, n) {
        return (
          this.set(
            t.x,
            e.x,
            n.x,
            0,
            t.y,
            e.y,
            n.y,
            0,
            t.z,
            e.z,
            n.z,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      extractRotation(t) {
        const e = this.elements,
          n = t.elements,
          i = 1 / Xd.setFromMatrixColumn(t, 0).length(),
          r = 1 / Xd.setFromMatrixColumn(t, 1).length(),
          s = 1 / Xd.setFromMatrixColumn(t, 2).length();
        return (
          (e[0] = n[0] * i),
          (e[1] = n[1] * i),
          (e[2] = n[2] * i),
          (e[3] = 0),
          (e[4] = n[4] * r),
          (e[5] = n[5] * r),
          (e[6] = n[6] * r),
          (e[7] = 0),
          (e[8] = n[8] * s),
          (e[9] = n[9] * s),
          (e[10] = n[10] * s),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      }
      makeRotationFromEuler(t) {
        const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z,
          s = Math.cos(n),
          o = Math.sin(n),
          a = Math.cos(i),
          l = Math.sin(i),
          c = Math.cos(r),
          u = Math.sin(r);
        if ("XYZ" === t.order) {
          const t = s * c,
            n = s * u,
            i = o * c,
            r = o * u;
          (e[0] = a * c),
            (e[4] = -a * u),
            (e[8] = l),
            (e[1] = n + i * l),
            (e[5] = t - r * l),
            (e[9] = -o * a),
            (e[2] = r - t * l),
            (e[6] = i + n * l),
            (e[10] = s * a);
        } else if ("YXZ" === t.order) {
          const t = a * c,
            n = a * u,
            i = l * c,
            r = l * u;
          (e[0] = t + r * o),
            (e[4] = i * o - n),
            (e[8] = s * l),
            (e[1] = s * u),
            (e[5] = s * c),
            (e[9] = -o),
            (e[2] = n * o - i),
            (e[6] = r + t * o),
            (e[10] = s * a);
        } else if ("ZXY" === t.order) {
          const t = a * c,
            n = a * u,
            i = l * c,
            r = l * u;
          (e[0] = t - r * o),
            (e[4] = -s * u),
            (e[8] = i + n * o),
            (e[1] = n + i * o),
            (e[5] = s * c),
            (e[9] = r - t * o),
            (e[2] = -s * l),
            (e[6] = o),
            (e[10] = s * a);
        } else if ("ZYX" === t.order) {
          const t = s * c,
            n = s * u,
            i = o * c,
            r = o * u;
          (e[0] = a * c),
            (e[4] = i * l - n),
            (e[8] = t * l + r),
            (e[1] = a * u),
            (e[5] = r * l + t),
            (e[9] = n * l - i),
            (e[2] = -l),
            (e[6] = o * a),
            (e[10] = s * a);
        } else if ("YZX" === t.order) {
          const t = s * a,
            n = s * l,
            i = o * a,
            r = o * l;
          (e[0] = a * c),
            (e[4] = r - t * u),
            (e[8] = i * u + n),
            (e[1] = u),
            (e[5] = s * c),
            (e[9] = -o * c),
            (e[2] = -l * c),
            (e[6] = n * u + i),
            (e[10] = t - r * u);
        } else if ("XZY" === t.order) {
          const t = s * a,
            n = s * l,
            i = o * a,
            r = o * l;
          (e[0] = a * c),
            (e[4] = -u),
            (e[8] = l * c),
            (e[1] = t * u + r),
            (e[5] = s * c),
            (e[9] = n * u - i),
            (e[2] = i * u - n),
            (e[6] = o * c),
            (e[10] = r * u + t);
        }
        return (
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      }
      makeRotationFromQuaternion(t) {
        return this.compose(Yd, t, Kd);
      }
      lookAt(t, e, n) {
        const i = this.elements;
        return (
          $d.subVectors(t, e),
          0 === $d.lengthSq() && ($d.z = 1),
          $d.normalize(),
          Zd.crossVectors(n, $d),
          0 === Zd.lengthSq() &&
            (1 === Math.abs(n.z) ? ($d.x += 1e-4) : ($d.z += 1e-4),
            $d.normalize(),
            Zd.crossVectors(n, $d)),
          Zd.normalize(),
          Jd.crossVectors($d, Zd),
          (i[0] = Zd.x),
          (i[4] = Jd.x),
          (i[8] = $d.x),
          (i[1] = Zd.y),
          (i[5] = Jd.y),
          (i[9] = $d.y),
          (i[2] = Zd.z),
          (i[6] = Jd.z),
          (i[10] = $d.z),
          this
        );
      }
      multiply(t) {
        return this.multiplyMatrices(this, t);
      }
      premultiply(t) {
        return this.multiplyMatrices(t, this);
      }
      multiplyMatrices(t, e) {
        const n = t.elements,
          i = e.elements,
          r = this.elements,
          s = n[0],
          o = n[4],
          a = n[8],
          l = n[12],
          c = n[1],
          u = n[5],
          h = n[9],
          d = n[13],
          p = n[2],
          f = n[6],
          m = n[10],
          g = n[14],
          v = n[3],
          _ = n[7],
          y = n[11],
          x = n[15],
          b = i[0],
          S = i[4],
          E = i[8],
          M = i[12],
          T = i[1],
          w = i[5],
          D = i[9],
          A = i[13],
          C = i[2],
          P = i[6],
          R = i[10],
          L = i[14],
          O = i[3],
          I = i[7],
          F = i[11],
          U = i[15];
        return (
          (r[0] = s * b + o * T + a * C + l * O),
          (r[4] = s * S + o * w + a * P + l * I),
          (r[8] = s * E + o * D + a * R + l * F),
          (r[12] = s * M + o * A + a * L + l * U),
          (r[1] = c * b + u * T + h * C + d * O),
          (r[5] = c * S + u * w + h * P + d * I),
          (r[9] = c * E + u * D + h * R + d * F),
          (r[13] = c * M + u * A + h * L + d * U),
          (r[2] = p * b + f * T + m * C + g * O),
          (r[6] = p * S + f * w + m * P + g * I),
          (r[10] = p * E + f * D + m * R + g * F),
          (r[14] = p * M + f * A + m * L + g * U),
          (r[3] = v * b + _ * T + y * C + x * O),
          (r[7] = v * S + _ * w + y * P + x * I),
          (r[11] = v * E + _ * D + y * R + x * F),
          (r[15] = v * M + _ * A + y * L + x * U),
          this
        );
      }
      multiplyScalar(t) {
        const e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      }
      determinant() {
        const t = this.elements,
          e = t[0],
          n = t[4],
          i = t[8],
          r = t[12],
          s = t[1],
          o = t[5],
          a = t[9],
          l = t[13],
          c = t[2],
          u = t[6],
          h = t[10],
          d = t[14];
        return (
          t[3] *
            (+r * a * u -
              i * l * u -
              r * o * h +
              n * l * h +
              i * o * d -
              n * a * d) +
          t[7] *
            (+e * a * d -
              e * l * h +
              r * s * h -
              i * s * d +
              i * l * c -
              r * a * c) +
          t[11] *
            (+e * l * u -
              e * o * d -
              r * s * u +
              n * s * d +
              r * o * c -
              n * l * c) +
          t[15] *
            (-i * o * c -
              e * a * u +
              e * o * h +
              i * s * u -
              n * s * h +
              n * a * c)
        );
      }
      transpose() {
        const t = this.elements;
        let e;
        return (
          (e = t[1]),
          (t[1] = t[4]),
          (t[4] = e),
          (e = t[2]),
          (t[2] = t[8]),
          (t[8] = e),
          (e = t[6]),
          (t[6] = t[9]),
          (t[9] = e),
          (e = t[3]),
          (t[3] = t[12]),
          (t[12] = e),
          (e = t[7]),
          (t[7] = t[13]),
          (t[13] = e),
          (e = t[11]),
          (t[11] = t[14]),
          (t[14] = e),
          this
        );
      }
      setPosition(t, e, n) {
        const i = this.elements;
        return (
          t.isVector3
            ? ((i[12] = t.x), (i[13] = t.y), (i[14] = t.z))
            : ((i[12] = t), (i[13] = e), (i[14] = n)),
          this
        );
      }
      invert() {
        const t = this.elements,
          e = t[0],
          n = t[1],
          i = t[2],
          r = t[3],
          s = t[4],
          o = t[5],
          a = t[6],
          l = t[7],
          c = t[8],
          u = t[9],
          h = t[10],
          d = t[11],
          p = t[12],
          f = t[13],
          m = t[14],
          g = t[15],
          v =
            u * m * l -
            f * h * l +
            f * a * d -
            o * m * d -
            u * a * g +
            o * h * g,
          _ =
            p * h * l -
            c * m * l -
            p * a * d +
            s * m * d +
            c * a * g -
            s * h * g,
          y =
            c * f * l -
            p * u * l +
            p * o * d -
            s * f * d -
            c * o * g +
            s * u * g,
          x =
            p * u * a -
            c * f * a -
            p * o * h +
            s * f * h +
            c * o * m -
            s * u * m,
          b = e * v + n * _ + i * y + r * x;
        if (0 === b)
          return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const S = 1 / b;
        return (
          (t[0] = v * S),
          (t[1] =
            (f * h * r -
              u * m * r -
              f * i * d +
              n * m * d +
              u * i * g -
              n * h * g) *
            S),
          (t[2] =
            (o * m * r -
              f * a * r +
              f * i * l -
              n * m * l -
              o * i * g +
              n * a * g) *
            S),
          (t[3] =
            (u * a * r -
              o * h * r -
              u * i * l +
              n * h * l +
              o * i * d -
              n * a * d) *
            S),
          (t[4] = _ * S),
          (t[5] =
            (c * m * r -
              p * h * r +
              p * i * d -
              e * m * d -
              c * i * g +
              e * h * g) *
            S),
          (t[6] =
            (p * a * r -
              s * m * r -
              p * i * l +
              e * m * l +
              s * i * g -
              e * a * g) *
            S),
          (t[7] =
            (s * h * r -
              c * a * r +
              c * i * l -
              e * h * l -
              s * i * d +
              e * a * d) *
            S),
          (t[8] = y * S),
          (t[9] =
            (p * u * r -
              c * f * r -
              p * n * d +
              e * f * d +
              c * n * g -
              e * u * g) *
            S),
          (t[10] =
            (s * f * r -
              p * o * r +
              p * n * l -
              e * f * l -
              s * n * g +
              e * o * g) *
            S),
          (t[11] =
            (c * o * r -
              s * u * r -
              c * n * l +
              e * u * l +
              s * n * d -
              e * o * d) *
            S),
          (t[12] = x * S),
          (t[13] =
            (c * f * i -
              p * u * i +
              p * n * h -
              e * f * h -
              c * n * m +
              e * u * m) *
            S),
          (t[14] =
            (p * o * i -
              s * f * i -
              p * n * a +
              e * f * a +
              s * n * m -
              e * o * m) *
            S),
          (t[15] =
            (s * u * i -
              c * o * i +
              c * n * a -
              e * u * a -
              s * n * h +
              e * o * h) *
            S),
          this
        );
      }
      scale(t) {
        const e = this.elements,
          n = t.x,
          i = t.y,
          r = t.z;
        return (
          (e[0] *= n),
          (e[4] *= i),
          (e[8] *= r),
          (e[1] *= n),
          (e[5] *= i),
          (e[9] *= r),
          (e[2] *= n),
          (e[6] *= i),
          (e[10] *= r),
          (e[3] *= n),
          (e[7] *= i),
          (e[11] *= r),
          this
        );
      }
      getMaxScaleOnAxis() {
        const t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          i = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, n, i));
      }
      makeTranslation(t, e, n) {
        return (
          t.isVector3
            ? this.set(1, 0, 0, t.x, 0, 1, 0, t.y, 0, 0, 1, t.z, 0, 0, 0, 1)
            : this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1),
          this
        );
      }
      makeRotationX(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationY(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this;
      }
      makeRotationZ(t) {
        const e = Math.cos(t),
          n = Math.sin(t);
        return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      }
      makeRotationAxis(t, e) {
        const n = Math.cos(e),
          i = Math.sin(e),
          r = 1 - n,
          s = t.x,
          o = t.y,
          a = t.z,
          l = r * s,
          c = r * o;
        return (
          this.set(
            l * s + n,
            l * o - i * a,
            l * a + i * o,
            0,
            l * o + i * a,
            c * o + n,
            c * a - i * s,
            0,
            l * a - i * o,
            c * a + i * s,
            r * a * a + n,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      }
      makeScale(t, e, n) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
      }
      makeShear(t, e, n, i, r, s) {
        return this.set(1, n, r, 0, t, 1, s, 0, e, i, 1, 0, 0, 0, 0, 1), this;
      }
      compose(t, e, n) {
        const i = this.elements,
          r = e._x,
          s = e._y,
          o = e._z,
          a = e._w,
          l = r + r,
          c = s + s,
          u = o + o,
          h = r * l,
          d = r * c,
          p = r * u,
          f = s * c,
          m = s * u,
          g = o * u,
          v = a * l,
          _ = a * c,
          y = a * u,
          x = n.x,
          b = n.y,
          S = n.z;
        return (
          (i[0] = (1 - (f + g)) * x),
          (i[1] = (d + y) * x),
          (i[2] = (p - _) * x),
          (i[3] = 0),
          (i[4] = (d - y) * b),
          (i[5] = (1 - (h + g)) * b),
          (i[6] = (m + v) * b),
          (i[7] = 0),
          (i[8] = (p + _) * S),
          (i[9] = (m - v) * S),
          (i[10] = (1 - (h + f)) * S),
          (i[11] = 0),
          (i[12] = t.x),
          (i[13] = t.y),
          (i[14] = t.z),
          (i[15] = 1),
          this
        );
      }
      decompose(t, e, n) {
        const i = this.elements;
        let r = Xd.set(i[0], i[1], i[2]).length();
        const s = Xd.set(i[4], i[5], i[6]).length(),
          o = Xd.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
          (t.x = i[12]),
          (t.y = i[13]),
          (t.z = i[14]),
          qd.copy(this);
        const a = 1 / r,
          l = 1 / s,
          c = 1 / o;
        return (
          (qd.elements[0] *= a),
          (qd.elements[1] *= a),
          (qd.elements[2] *= a),
          (qd.elements[4] *= l),
          (qd.elements[5] *= l),
          (qd.elements[6] *= l),
          (qd.elements[8] *= c),
          (qd.elements[9] *= c),
          (qd.elements[10] *= c),
          e.setFromRotationMatrix(qd),
          (n.x = r),
          (n.y = s),
          (n.z = o),
          this
        );
      }
      makePerspective(t, e, n, i, r, s, o = 2e3) {
        const a = this.elements,
          l = (2 * r) / (e - t),
          c = (2 * r) / (n - i),
          u = (e + t) / (e - t),
          h = (n + i) / (n - i);
        let d, p;
        if (2e3 === o) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
        else {
          if (2001 !== o)
            throw new Error(
              "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o
            );
          (d = -s / (s - r)), (p = (-s * r) / (s - r));
        }
        return (
          (a[0] = l),
          (a[4] = 0),
          (a[8] = u),
          (a[12] = 0),
          (a[1] = 0),
          (a[5] = c),
          (a[9] = h),
          (a[13] = 0),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = d),
          (a[14] = p),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = -1),
          (a[15] = 0),
          this
        );
      }
      makeOrthographic(t, e, n, i, r, s, o = 2e3) {
        const a = this.elements,
          l = 1 / (e - t),
          c = 1 / (n - i),
          u = 1 / (s - r),
          h = (e + t) * l,
          d = (n + i) * c;
        let p, f;
        if (2e3 === o) (p = (s + r) * u), (f = -2 * u);
        else {
          if (2001 !== o)
            throw new Error(
              "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                o
            );
          (p = r * u), (f = -1 * u);
        }
        return (
          (a[0] = 2 * l),
          (a[4] = 0),
          (a[8] = 0),
          (a[12] = -h),
          (a[1] = 0),
          (a[5] = 2 * c),
          (a[9] = 0),
          (a[13] = -d),
          (a[2] = 0),
          (a[6] = 0),
          (a[10] = f),
          (a[14] = -p),
          (a[3] = 0),
          (a[7] = 0),
          (a[11] = 0),
          (a[15] = 1),
          this
        );
      }
      equals(t) {
        const e = this.elements,
          n = t.elements;
        for (let t = 0; t < 16; t++) if (e[t] !== n[t]) return !1;
        return !0;
      }
      fromArray(t, e = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = t[n + e];
        return this;
      }
      toArray(t = [], e = 0) {
        const n = this.elements;
        return (
          (t[e] = n[0]),
          (t[e + 1] = n[1]),
          (t[e + 2] = n[2]),
          (t[e + 3] = n[3]),
          (t[e + 4] = n[4]),
          (t[e + 5] = n[5]),
          (t[e + 6] = n[6]),
          (t[e + 7] = n[7]),
          (t[e + 8] = n[8]),
          (t[e + 9] = n[9]),
          (t[e + 10] = n[10]),
          (t[e + 11] = n[11]),
          (t[e + 12] = n[12]),
          (t[e + 13] = n[13]),
          (t[e + 14] = n[14]),
          (t[e + 15] = n[15]),
          t
        );
      }
    }
    const Xd = new md(),
      qd = new jd(),
      Yd = new md(0, 0, 0),
      Kd = new md(1, 1, 1),
      Zd = new md(),
      Jd = new md(),
      $d = new md(),
      Qd = new jd(),
      tp = new fd();
    class ep {
      constructor(t = 0, e = 0, n = 0, i = ep.DEFAULT_ORDER) {
        (this.isEuler = !0),
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._order = i);
      }
      get x() {
        return this._x;
      }
      set x(t) {
        (this._x = t), this._onChangeCallback();
      }
      get y() {
        return this._y;
      }
      set y(t) {
        (this._y = t), this._onChangeCallback();
      }
      get z() {
        return this._z;
      }
      set z(t) {
        (this._z = t), this._onChangeCallback();
      }
      get order() {
        return this._order;
      }
      set order(t) {
        (this._order = t), this._onChangeCallback();
      }
      set(t, e, n, i = this._order) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = n),
          (this._order = i),
          this._onChangeCallback(),
          this
        );
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
      copy(t) {
        return (
          (this._x = t._x),
          (this._y = t._y),
          (this._z = t._z),
          (this._order = t._order),
          this._onChangeCallback(),
          this
        );
      }
      setFromRotationMatrix(t, e = this._order, n = !0) {
        const i = t.elements,
          r = i[0],
          s = i[4],
          o = i[8],
          a = i[1],
          l = i[5],
          c = i[9],
          u = i[2],
          h = i[6],
          d = i[10];
        switch (e) {
          case "XYZ":
            (this._y = Math.asin(Fh(o, -1, 1))),
              Math.abs(o) < 0.9999999
                ? ((this._x = Math.atan2(-c, d)), (this._z = Math.atan2(-s, r)))
                : ((this._x = Math.atan2(h, l)), (this._z = 0));
            break;
          case "YXZ":
            (this._x = Math.asin(-Fh(c, -1, 1))),
              Math.abs(c) < 0.9999999
                ? ((this._y = Math.atan2(o, d)), (this._z = Math.atan2(a, l)))
                : ((this._y = Math.atan2(-u, r)), (this._z = 0));
            break;
          case "ZXY":
            (this._x = Math.asin(Fh(h, -1, 1))),
              Math.abs(h) < 0.9999999
                ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-s, l)))
                : ((this._y = 0), (this._z = Math.atan2(a, r)));
            break;
          case "ZYX":
            (this._y = Math.asin(-Fh(u, -1, 1))),
              Math.abs(u) < 0.9999999
                ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(a, r)))
                : ((this._x = 0), (this._z = Math.atan2(-s, l)));
            break;
          case "YZX":
            (this._z = Math.asin(Fh(a, -1, 1))),
              Math.abs(a) < 0.9999999
                ? ((this._x = Math.atan2(-c, l)), (this._y = Math.atan2(-u, r)))
                : ((this._x = 0), (this._y = Math.atan2(o, d)));
            break;
          case "XZY":
            (this._z = Math.asin(-Fh(s, -1, 1))),
              Math.abs(s) < 0.9999999
                ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(o, r)))
                : ((this._x = Math.atan2(-c, d)), (this._y = 0));
            break;
          default:
            console.warn(
              "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                e
            );
        }
        return (this._order = e), !0 === n && this._onChangeCallback(), this;
      }
      setFromQuaternion(t, e, n) {
        return (
          Qd.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Qd, e, n)
        );
      }
      setFromVector3(t, e = this._order) {
        return this.set(t.x, t.y, t.z, e);
      }
      reorder(t) {
        return tp.setFromEuler(this), this.setFromQuaternion(tp, t);
      }
      equals(t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._order === this._order
        );
      }
      fromArray(t) {
        return (
          (this._x = t[0]),
          (this._y = t[1]),
          (this._z = t[2]),
          void 0 !== t[3] && (this._order = t[3]),
          this._onChangeCallback(),
          this
        );
      }
      toArray(t = [], e = 0) {
        return (
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._order),
          t
        );
      }
      _onChange(t) {
        return (this._onChangeCallback = t), this;
      }
      _onChangeCallback() {}
      *[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order;
      }
    }
    ep.DEFAULT_ORDER = "XYZ";
    class np {
      constructor() {
        this.mask = 1;
      }
      set(t) {
        this.mask = ((1 << t) | 0) >>> 0;
      }
      enable(t) {
        this.mask |= (1 << t) | 0;
      }
      enableAll() {
        this.mask = -1;
      }
      toggle(t) {
        this.mask ^= (1 << t) | 0;
      }
      disable(t) {
        this.mask &= ~((1 << t) | 0);
      }
      disableAll() {
        this.mask = 0;
      }
      test(t) {
        return 0 != (this.mask & t.mask);
      }
      isEnabled(t) {
        return 0 != (this.mask & ((1 << t) | 0));
      }
    }
    let ip = 0;
    const rp = new md(),
      sp = new fd(),
      op = new jd(),
      ap = new md(),
      lp = new md(),
      cp = new md(),
      up = new fd(),
      hp = new md(1, 0, 0),
      dp = new md(0, 1, 0),
      pp = new md(0, 0, 1),
      fp = {
        type: "added",
      },
      mp = {
        type: "removed",
      };
    class gp extends Ph {
      constructor() {
        super(),
          (this.isObject3D = !0),
          Object.defineProperty(this, "id", {
            value: ip++,
          }),
          (this.uuid = Ih()),
          (this.name = ""),
          (this.type = "Object3D"),
          (this.parent = null),
          (this.children = []),
          (this.up = gp.DEFAULT_UP.clone());
        const t = new md(),
          e = new ep(),
          n = new fd(),
          i = new md(1, 1, 1);
        e._onChange(function () {
          n.setFromEuler(e, !1);
        }),
          n._onChange(function () {
            e.setFromQuaternion(n, void 0, !1);
          }),
          Object.defineProperties(this, {
            position: {
              configurable: !0,
              enumerable: !0,
              value: t,
            },
            rotation: {
              configurable: !0,
              enumerable: !0,
              value: e,
            },
            quaternion: {
              configurable: !0,
              enumerable: !0,
              value: n,
            },
            scale: {
              configurable: !0,
              enumerable: !0,
              value: i,
            },
            modelViewMatrix: {
              value: new jd(),
            },
            normalMatrix: {
              value: new Gh(),
            },
          }),
          (this.matrix = new jd()),
          (this.matrixWorld = new jd()),
          (this.matrixAutoUpdate = gp.DEFAULT_MATRIX_AUTO_UPDATE),
          (this.matrixWorldNeedsUpdate = !1),
          (this.matrixWorldAutoUpdate = gp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
          (this.layers = new np()),
          (this.visible = !0),
          (this.castShadow = !1),
          (this.receiveShadow = !1),
          (this.frustumCulled = !0),
          (this.renderOrder = 0),
          (this.animations = []),
          (this.userData = {});
      }
      onBeforeRender() {}
      onAfterRender() {}
      applyMatrix4(t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          this.matrix.premultiply(t),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
      applyQuaternion(t) {
        return this.quaternion.premultiply(t), this;
      }
      setRotationFromAxisAngle(t, e) {
        this.quaternion.setFromAxisAngle(t, e);
      }
      setRotationFromEuler(t) {
        this.quaternion.setFromEuler(t, !0);
      }
      setRotationFromMatrix(t) {
        this.quaternion.setFromRotationMatrix(t);
      }
      setRotationFromQuaternion(t) {
        this.quaternion.copy(t);
      }
      rotateOnAxis(t, e) {
        return sp.setFromAxisAngle(t, e), this.quaternion.multiply(sp), this;
      }
      rotateOnWorldAxis(t, e) {
        return sp.setFromAxisAngle(t, e), this.quaternion.premultiply(sp), this;
      }
      rotateX(t) {
        return this.rotateOnAxis(hp, t);
      }
      rotateY(t) {
        return this.rotateOnAxis(dp, t);
      }
      rotateZ(t) {
        return this.rotateOnAxis(pp, t);
      }
      translateOnAxis(t, e) {
        return (
          rp.copy(t).applyQuaternion(this.quaternion),
          this.position.add(rp.multiplyScalar(e)),
          this
        );
      }
      translateX(t) {
        return this.translateOnAxis(hp, t);
      }
      translateY(t) {
        return this.translateOnAxis(dp, t);
      }
      translateZ(t) {
        return this.translateOnAxis(pp, t);
      }
      localToWorld(t) {
        return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld);
      }
      worldToLocal(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          t.applyMatrix4(op.copy(this.matrixWorld).invert())
        );
      }
      lookAt(t, e, n) {
        t.isVector3 ? ap.copy(t) : ap.set(t, e, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
          lp.setFromMatrixPosition(this.matrixWorld),
          this.isCamera || this.isLight
            ? op.lookAt(lp, ap, this.up)
            : op.lookAt(ap, lp, this.up),
          this.quaternion.setFromRotationMatrix(op),
          i &&
            (op.extractRotation(i.matrixWorld),
            sp.setFromRotationMatrix(op),
            this.quaternion.premultiply(sp.invert()));
      }
      add(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this;
        }
        return t === this
          ? (console.error(
              "THREE.Object3D.add: object can't be added as a child of itself.",
              t
            ),
            this)
          : (t && t.isObject3D
              ? (null !== t.parent && t.parent.remove(t),
                (t.parent = this),
                this.children.push(t),
                t.dispatchEvent(fp))
              : console.error(
                  "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                  t
                ),
            this);
      }
      remove(t) {
        if (arguments.length > 1) {
          for (let t = 0; t < arguments.length; t++) this.remove(arguments[t]);
          return this;
        }
        const e = this.children.indexOf(t);
        return (
          -1 !== e &&
            ((t.parent = null),
            this.children.splice(e, 1),
            t.dispatchEvent(mp)),
          this
        );
      }
      removeFromParent() {
        const t = this.parent;
        return null !== t && t.remove(this), this;
      }
      clear() {
        for (let t = 0; t < this.children.length; t++) {
          const e = this.children[t];
          (e.parent = null), e.dispatchEvent(mp);
        }
        return (this.children.length = 0), this;
      }
      attach(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          op.copy(this.matrixWorld).invert(),
          null !== t.parent &&
            (t.parent.updateWorldMatrix(!0, !1),
            op.multiply(t.parent.matrixWorld)),
          t.applyMatrix4(op),
          this.add(t),
          t.updateWorldMatrix(!1, !0),
          this
        );
      }
      getObjectById(t) {
        return this.getObjectByProperty("id", t);
      }
      getObjectByName(t) {
        return this.getObjectByProperty("name", t);
      }
      getObjectByProperty(t, e) {
        if (this[t] === e) return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
          const i = this.children[n].getObjectByProperty(t, e);
          if (void 0 !== i) return i;
        }
      }
      getObjectsByProperty(t, e) {
        let n = [];
        this[t] === e && n.push(this);
        for (let i = 0, r = this.children.length; i < r; i++) {
          const r = this.children[i].getObjectsByProperty(t, e);
          r.length > 0 && (n = n.concat(r));
        }
        return n;
      }
      getWorldPosition(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          t.setFromMatrixPosition(this.matrixWorld)
        );
      }
      getWorldQuaternion(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(lp, t, cp),
          t
        );
      }
      getWorldScale(t) {
        return (
          this.updateWorldMatrix(!0, !1),
          this.matrixWorld.decompose(lp, up, t),
          t
        );
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize();
      }
      raycast() {}
      traverse(t) {
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) e[n].traverse(t);
      }
      traverseVisible(t) {
        if (!1 === this.visible) return;
        t(this);
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) e[n].traverseVisible(t);
      }
      traverseAncestors(t) {
        const e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t));
      }
      updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      }
      updateMatrixWorld(t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || t) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix
                ),
            (this.matrixWorldNeedsUpdate = !1),
            (t = !0));
        const e = this.children;
        for (let n = 0, i = e.length; n < i; n++) {
          const i = e[n];
          (!0 !== i.matrixWorldAutoUpdate && !0 !== t) ||
            i.updateMatrixWorld(t);
        }
      }
      updateWorldMatrix(t, e) {
        const n = this.parent;
        if (
          (!0 === t &&
            null !== n &&
            !0 === n.matrixWorldAutoUpdate &&
            n.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix
              ),
          !0 === e)
        ) {
          const t = this.children;
          for (let e = 0, n = t.length; e < n; e++) {
            const n = t[e];
            !0 === n.matrixWorldAutoUpdate && n.updateWorldMatrix(!1, !0);
          }
        }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t,
          n = {};
        e &&
          ((t = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {},
          }),
          (n.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        const i = {};
        function r(e, n) {
          return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid;
        }
        if (
          ((i.uuid = this.uuid),
          (i.type = this.type),
          "" !== this.name && (i.name = this.name),
          !0 === this.castShadow && (i.castShadow = !0),
          !0 === this.receiveShadow && (i.receiveShadow = !0),
          !1 === this.visible && (i.visible = !1),
          !1 === this.frustumCulled && (i.frustumCulled = !1),
          0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
          Object.keys(this.userData).length > 0 && (i.userData = this.userData),
          (i.layers = this.layers.mask),
          (i.matrix = this.matrix.toArray()),
          (i.up = this.up.toArray()),
          !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
          this.isInstancedMesh &&
            ((i.type = "InstancedMesh"),
            (i.count = this.count),
            (i.instanceMatrix = this.instanceMatrix.toJSON()),
            null !== this.instanceColor &&
              (i.instanceColor = this.instanceColor.toJSON())),
          this.isScene)
        )
          this.background &&
            (this.background.isColor
              ? (i.background = this.background.toJSON())
              : this.background.isTexture &&
                (i.background = this.background.toJSON(t).uuid)),
            this.environment &&
              this.environment.isTexture &&
              !0 !== this.environment.isRenderTargetTexture &&
              (i.environment = this.environment.toJSON(t).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
          i.geometry = r(t.geometries, this.geometry);
          const e = this.geometry.parameters;
          if (void 0 !== e && void 0 !== e.shapes) {
            const n = e.shapes;
            if (Array.isArray(n))
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                r(t.shapes, i);
              }
            else r(t.shapes, n);
          }
        }
        if (
          (this.isSkinnedMesh &&
            ((i.bindMode = this.bindMode),
            (i.bindMatrix = this.bindMatrix.toArray()),
            void 0 !== this.skeleton &&
              (r(t.skeletons, this.skeleton),
              (i.skeleton = this.skeleton.uuid))),
          void 0 !== this.material)
        )
          if (Array.isArray(this.material)) {
            const e = [];
            for (let n = 0, i = this.material.length; n < i; n++)
              e.push(r(t.materials, this.material[n]));
            i.material = e;
          } else i.material = r(t.materials, this.material);
        if (this.children.length > 0) {
          i.children = [];
          for (let e = 0; e < this.children.length; e++)
            i.children.push(this.children[e].toJSON(t).object);
        }
        if (this.animations.length > 0) {
          i.animations = [];
          for (let e = 0; e < this.animations.length; e++) {
            const n = this.animations[e];
            i.animations.push(r(t.animations, n));
          }
        }
        if (e) {
          const e = s(t.geometries),
            i = s(t.materials),
            r = s(t.textures),
            o = s(t.images),
            a = s(t.shapes),
            l = s(t.skeletons),
            c = s(t.animations),
            u = s(t.nodes);
          e.length > 0 && (n.geometries = e),
            i.length > 0 && (n.materials = i),
            r.length > 0 && (n.textures = r),
            o.length > 0 && (n.images = o),
            a.length > 0 && (n.shapes = a),
            l.length > 0 && (n.skeletons = l),
            c.length > 0 && (n.animations = c),
            u.length > 0 && (n.nodes = u);
        }
        return (n.object = i), n;
        function s(t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
      }
      clone(t) {
        return new this.constructor().copy(this, t);
      }
      copy(t, e = !0) {
        if (
          ((this.name = t.name),
          this.up.copy(t.up),
          this.position.copy(t.position),
          (this.rotation.order = t.rotation.order),
          this.quaternion.copy(t.quaternion),
          this.scale.copy(t.scale),
          this.matrix.copy(t.matrix),
          this.matrixWorld.copy(t.matrixWorld),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
          (this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate),
          (this.layers.mask = t.layers.mask),
          (this.visible = t.visible),
          (this.castShadow = t.castShadow),
          (this.receiveShadow = t.receiveShadow),
          (this.frustumCulled = t.frustumCulled),
          (this.renderOrder = t.renderOrder),
          (this.animations = t.animations.slice()),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          !0 === e)
        )
          for (let e = 0; e < t.children.length; e++) {
            const n = t.children[e];
            this.add(n.clone());
          }
        return this;
      }
    }
    (gp.DEFAULT_UP = new md(0, 1, 0)),
      (gp.DEFAULT_MATRIX_AUTO_UPDATE = !0),
      (gp.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
    const vp = new md(),
      _p = new md(),
      yp = new md(),
      xp = new md(),
      bp = new md(),
      Sp = new md(),
      Ep = new md(),
      Mp = new md(),
      Tp = new md(),
      wp = new md();
    let Dp = !1;
    class Ap {
      constructor(t = new md(), e = new md(), n = new md()) {
        (this.a = t), (this.b = e), (this.c = n);
      }
      static getNormal(t, e, n, i) {
        i.subVectors(n, e), vp.subVectors(t, e), i.cross(vp);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
      }
      static getBarycoord(t, e, n, i, r) {
        vp.subVectors(i, e), _p.subVectors(n, e), yp.subVectors(t, e);
        const s = vp.dot(vp),
          o = vp.dot(_p),
          a = vp.dot(yp),
          l = _p.dot(_p),
          c = _p.dot(yp),
          u = s * l - o * o;
        if (0 === u) return r.set(-2, -1, -1);
        const h = 1 / u,
          d = (l * a - o * c) * h,
          p = (s * c - o * a) * h;
        return r.set(1 - d - p, p, d);
      }
      static containsPoint(t, e, n, i) {
        return (
          this.getBarycoord(t, e, n, i, xp),
          xp.x >= 0 && xp.y >= 0 && xp.x + xp.y <= 1
        );
      }
      static getUV(t, e, n, i, r, s, o, a) {
        return (
          !1 === Dp &&
            (console.warn(
              "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
            ),
            (Dp = !0)),
          this.getInterpolation(t, e, n, i, r, s, o, a)
        );
      }
      static getInterpolation(t, e, n, i, r, s, o, a) {
        return (
          this.getBarycoord(t, e, n, i, xp),
          a.setScalar(0),
          a.addScaledVector(r, xp.x),
          a.addScaledVector(s, xp.y),
          a.addScaledVector(o, xp.z),
          a
        );
      }
      static isFrontFacing(t, e, n, i) {
        return (
          vp.subVectors(n, e), _p.subVectors(t, e), vp.cross(_p).dot(i) < 0
        );
      }
      set(t, e, n) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(n), this;
      }
      setFromPointsAndIndices(t, e, n, i) {
        return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[i]), this;
      }
      setFromAttributeAndIndices(t, e, n, i) {
        return (
          this.a.fromBufferAttribute(t, e),
          this.b.fromBufferAttribute(t, n),
          this.c.fromBufferAttribute(t, i),
          this
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
      }
      getArea() {
        return (
          vp.subVectors(this.c, this.b),
          _p.subVectors(this.a, this.b),
          0.5 * vp.cross(_p).length()
        );
      }
      getMidpoint(t) {
        return t
          .addVectors(this.a, this.b)
          .add(this.c)
          .multiplyScalar(1 / 3);
      }
      getNormal(t) {
        return Ap.getNormal(this.a, this.b, this.c, t);
      }
      getPlane(t) {
        return t.setFromCoplanarPoints(this.a, this.b, this.c);
      }
      getBarycoord(t, e) {
        return Ap.getBarycoord(t, this.a, this.b, this.c, e);
      }
      getUV(t, e, n, i, r) {
        return (
          !1 === Dp &&
            (console.warn(
              "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
            ),
            (Dp = !0)),
          Ap.getInterpolation(t, this.a, this.b, this.c, e, n, i, r)
        );
      }
      getInterpolation(t, e, n, i, r) {
        return Ap.getInterpolation(t, this.a, this.b, this.c, e, n, i, r);
      }
      containsPoint(t) {
        return Ap.containsPoint(t, this.a, this.b, this.c);
      }
      isFrontFacing(t) {
        return Ap.isFrontFacing(this.a, this.b, this.c, t);
      }
      intersectsBox(t) {
        return t.intersectsTriangle(this);
      }
      closestPointToPoint(t, e) {
        const n = this.a,
          i = this.b,
          r = this.c;
        let s, o;
        bp.subVectors(i, n), Sp.subVectors(r, n), Mp.subVectors(t, n);
        const a = bp.dot(Mp),
          l = Sp.dot(Mp);
        if (a <= 0 && l <= 0) return e.copy(n);
        Tp.subVectors(t, i);
        const c = bp.dot(Tp),
          u = Sp.dot(Tp);
        if (c >= 0 && u <= c) return e.copy(i);
        const h = a * u - c * l;
        if (h <= 0 && a >= 0 && c <= 0)
          return (s = a / (a - c)), e.copy(n).addScaledVector(bp, s);
        wp.subVectors(t, r);
        const d = bp.dot(wp),
          p = Sp.dot(wp);
        if (p >= 0 && d <= p) return e.copy(r);
        const f = d * l - a * p;
        if (f <= 0 && l >= 0 && p <= 0)
          return (o = l / (l - p)), e.copy(n).addScaledVector(Sp, o);
        const m = c * p - d * u;
        if (m <= 0 && u - c >= 0 && d - p >= 0)
          return (
            Ep.subVectors(r, i),
            (o = (u - c) / (u - c + (d - p))),
            e.copy(i).addScaledVector(Ep, o)
          );
        const g = 1 / (m + f + h);
        return (
          (s = f * g),
          (o = h * g),
          e.copy(n).addScaledVector(bp, s).addScaledVector(Sp, o)
        );
      }
      equals(t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      }
    }
    let Cp = 0;
    class Pp extends Ph {
      constructor() {
        super(),
          (this.isMaterial = !0),
          Object.defineProperty(this, "id", {
            value: Cp++,
          }),
          (this.uuid = Ih()),
          (this.name = ""),
          (this.type = "Material"),
          (this.blending = 1),
          (this.side = 0),
          (this.vertexColors = !1),
          (this.opacity = 1),
          (this.transparent = !1),
          (this.alphaHash = !1),
          (this.blendSrc = 204),
          (this.blendDst = 205),
          (this.blendEquation = 100),
          (this.blendSrcAlpha = null),
          (this.blendDstAlpha = null),
          (this.blendEquationAlpha = null),
          (this.depthFunc = 3),
          (this.depthTest = !0),
          (this.depthWrite = !0),
          (this.stencilWriteMask = 255),
          (this.stencilFunc = 519),
          (this.stencilRef = 0),
          (this.stencilFuncMask = 255),
          (this.stencilFail = 7680),
          (this.stencilZFail = 7680),
          (this.stencilZPass = 7680),
          (this.stencilWrite = !1),
          (this.clippingPlanes = null),
          (this.clipIntersection = !1),
          (this.clipShadows = !1),
          (this.shadowSide = null),
          (this.colorWrite = !0),
          (this.precision = null),
          (this.polygonOffset = !1),
          (this.polygonOffsetFactor = 0),
          (this.polygonOffsetUnits = 0),
          (this.dithering = !1),
          (this.alphaToCoverage = !1),
          (this.premultipliedAlpha = !1),
          (this.forceSinglePass = !1),
          (this.visible = !0),
          (this.toneMapped = !0),
          (this.userData = {}),
          (this.version = 0),
          (this._alphaTest = 0);
      }
      get alphaTest() {
        return this._alphaTest;
      }
      set alphaTest(t) {
        this._alphaTest > 0 != t > 0 && this.version++, (this._alphaTest = t);
      }
      onBuild() {}
      onBeforeRender() {}
      onBeforeCompile() {}
      customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
      setValues(t) {
        if (void 0 !== t)
          for (const e in t) {
            const n = t[e];
            if (void 0 === n) {
              console.warn(
                `THREE.Material: parameter '${e}' has value of undefined.`
              );
              continue;
            }
            const i = this[e];
            void 0 !== i
              ? i && i.isColor
                ? i.set(n)
                : i && i.isVector3 && n && n.isVector3
                ? i.copy(n)
                : (this[e] = n)
              : console.warn(
                  `THREE.Material: '${e}' is not a property of THREE.${this.type}.`
                );
          }
      }
      toJSON(t) {
        const e = void 0 === t || "string" == typeof t;
        e &&
          (t = {
            textures: {},
            images: {},
          });
        const n = {
          metadata: {
            version: 4.6,
            type: "Material",
            generator: "Material.toJSON",
          },
        };
        function i(t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            delete i.metadata, e.push(i);
          }
          return e;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          this.color && this.color.isColor && (n.color = this.color.getHex()),
          void 0 !== this.roughness && (n.roughness = this.roughness),
          void 0 !== this.metalness && (n.metalness = this.metalness),
          void 0 !== this.sheen && (n.sheen = this.sheen),
          this.sheenColor &&
            this.sheenColor.isColor &&
            (n.sheenColor = this.sheenColor.getHex()),
          void 0 !== this.sheenRoughness &&
            (n.sheenRoughness = this.sheenRoughness),
          this.emissive &&
            this.emissive.isColor &&
            (n.emissive = this.emissive.getHex()),
          this.emissiveIntensity &&
            1 !== this.emissiveIntensity &&
            (n.emissiveIntensity = this.emissiveIntensity),
          this.specular &&
            this.specular.isColor &&
            (n.specular = this.specular.getHex()),
          void 0 !== this.specularIntensity &&
            (n.specularIntensity = this.specularIntensity),
          this.specularColor &&
            this.specularColor.isColor &&
            (n.specularColor = this.specularColor.getHex()),
          void 0 !== this.shininess && (n.shininess = this.shininess),
          void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
          void 0 !== this.clearcoatRoughness &&
            (n.clearcoatRoughness = this.clearcoatRoughness),
          this.clearcoatMap &&
            this.clearcoatMap.isTexture &&
            (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid),
          this.clearcoatRoughnessMap &&
            this.clearcoatRoughnessMap.isTexture &&
            (n.clearcoatRoughnessMap =
              this.clearcoatRoughnessMap.toJSON(t).uuid),
          this.clearcoatNormalMap &&
            this.clearcoatNormalMap.isTexture &&
            ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid),
            (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
          void 0 !== this.iridescence && (n.iridescence = this.iridescence),
          void 0 !== this.iridescenceIOR &&
            (n.iridescenceIOR = this.iridescenceIOR),
          void 0 !== this.iridescenceThicknessRange &&
            (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
          this.iridescenceMap &&
            this.iridescenceMap.isTexture &&
            (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid),
          this.iridescenceThicknessMap &&
            this.iridescenceThicknessMap.isTexture &&
            (n.iridescenceThicknessMap =
              this.iridescenceThicknessMap.toJSON(t).uuid),
          void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
          void 0 !== this.anisotropyRotation &&
            (n.anisotropyRotation = this.anisotropyRotation),
          this.anisotropyMap &&
            this.anisotropyMap.isTexture &&
            (n.anisotropyMap = this.anisotropyMap.toJSON(t).uuid),
          this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid),
          this.matcap &&
            this.matcap.isTexture &&
            (n.matcap = this.matcap.toJSON(t).uuid),
          this.alphaMap &&
            this.alphaMap.isTexture &&
            (n.alphaMap = this.alphaMap.toJSON(t).uuid),
          this.lightMap &&
            this.lightMap.isTexture &&
            ((n.lightMap = this.lightMap.toJSON(t).uuid),
            (n.lightMapIntensity = this.lightMapIntensity)),
          this.aoMap &&
            this.aoMap.isTexture &&
            ((n.aoMap = this.aoMap.toJSON(t).uuid),
            (n.aoMapIntensity = this.aoMapIntensity)),
          this.bumpMap &&
            this.bumpMap.isTexture &&
            ((n.bumpMap = this.bumpMap.toJSON(t).uuid),
            (n.bumpScale = this.bumpScale)),
          this.normalMap &&
            this.normalMap.isTexture &&
            ((n.normalMap = this.normalMap.toJSON(t).uuid),
            (n.normalMapType = this.normalMapType),
            (n.normalScale = this.normalScale.toArray())),
          this.displacementMap &&
            this.displacementMap.isTexture &&
            ((n.displacementMap = this.displacementMap.toJSON(t).uuid),
            (n.displacementScale = this.displacementScale),
            (n.displacementBias = this.displacementBias)),
          this.roughnessMap &&
            this.roughnessMap.isTexture &&
            (n.roughnessMap = this.roughnessMap.toJSON(t).uuid),
          this.metalnessMap &&
            this.metalnessMap.isTexture &&
            (n.metalnessMap = this.metalnessMap.toJSON(t).uuid),
          this.emissiveMap &&
            this.emissiveMap.isTexture &&
            (n.emissiveMap = this.emissiveMap.toJSON(t).uuid),
          this.specularMap &&
            this.specularMap.isTexture &&
            (n.specularMap = this.specularMap.toJSON(t).uuid),
          this.specularIntensityMap &&
            this.specularIntensityMap.isTexture &&
            (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid),
          this.specularColorMap &&
            this.specularColorMap.isTexture &&
            (n.specularColorMap = this.specularColorMap.toJSON(t).uuid),
          this.envMap &&
            this.envMap.isTexture &&
            ((n.envMap = this.envMap.toJSON(t).uuid),
            void 0 !== this.combine && (n.combine = this.combine)),
          void 0 !== this.envMapIntensity &&
            (n.envMapIntensity = this.envMapIntensity),
          void 0 !== this.reflectivity && (n.reflectivity = this.reflectivity),
          void 0 !== this.refractionRatio &&
            (n.refractionRatio = this.refractionRatio),
          this.gradientMap &&
            this.gradientMap.isTexture &&
            (n.gradientMap = this.gradientMap.toJSON(t).uuid),
          void 0 !== this.transmission && (n.transmission = this.transmission),
          this.transmissionMap &&
            this.transmissionMap.isTexture &&
            (n.transmissionMap = this.transmissionMap.toJSON(t).uuid),
          void 0 !== this.thickness && (n.thickness = this.thickness),
          this.thicknessMap &&
            this.thicknessMap.isTexture &&
            (n.thicknessMap = this.thicknessMap.toJSON(t).uuid),
          void 0 !== this.attenuationDistance &&
            this.attenuationDistance !== 1 / 0 &&
            (n.attenuationDistance = this.attenuationDistance),
          void 0 !== this.attenuationColor &&
            (n.attenuationColor = this.attenuationColor.getHex()),
          void 0 !== this.size && (n.size = this.size),
          null !== this.shadowSide && (n.shadowSide = this.shadowSide),
          void 0 !== this.sizeAttenuation &&
            (n.sizeAttenuation = this.sizeAttenuation),
          1 !== this.blending && (n.blending = this.blending),
          0 !== this.side && (n.side = this.side),
          this.vertexColors && (n.vertexColors = !0),
          this.opacity < 1 && (n.opacity = this.opacity),
          !0 === this.transparent && (n.transparent = this.transparent),
          (n.depthFunc = this.depthFunc),
          (n.depthTest = this.depthTest),
          (n.depthWrite = this.depthWrite),
          (n.colorWrite = this.colorWrite),
          (n.stencilWrite = this.stencilWrite),
          (n.stencilWriteMask = this.stencilWriteMask),
          (n.stencilFunc = this.stencilFunc),
          (n.stencilRef = this.stencilRef),
          (n.stencilFuncMask = this.stencilFuncMask),
          (n.stencilFail = this.stencilFail),
          (n.stencilZFail = this.stencilZFail),
          (n.stencilZPass = this.stencilZPass),
          void 0 !== this.rotation &&
            0 !== this.rotation &&
            (n.rotation = this.rotation),
          !0 === this.polygonOffset && (n.polygonOffset = !0),
          0 !== this.polygonOffsetFactor &&
            (n.polygonOffsetFactor = this.polygonOffsetFactor),
          0 !== this.polygonOffsetUnits &&
            (n.polygonOffsetUnits = this.polygonOffsetUnits),
          void 0 !== this.linewidth &&
            1 !== this.linewidth &&
            (n.linewidth = this.linewidth),
          void 0 !== this.dashSize && (n.dashSize = this.dashSize),
          void 0 !== this.gapSize && (n.gapSize = this.gapSize),
          void 0 !== this.scale && (n.scale = this.scale),
          !0 === this.dithering && (n.dithering = !0),
          this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
          !0 === this.alphaHash && (n.alphaHash = this.alphaHash),
          !0 === this.alphaToCoverage &&
            (n.alphaToCoverage = this.alphaToCoverage),
          !0 === this.premultipliedAlpha &&
            (n.premultipliedAlpha = this.premultipliedAlpha),
          !0 === this.forceSinglePass &&
            (n.forceSinglePass = this.forceSinglePass),
          !0 === this.wireframe && (n.wireframe = this.wireframe),
          this.wireframeLinewidth > 1 &&
            (n.wireframeLinewidth = this.wireframeLinewidth),
          "round" !== this.wireframeLinecap &&
            (n.wireframeLinecap = this.wireframeLinecap),
          "round" !== this.wireframeLinejoin &&
            (n.wireframeLinejoin = this.wireframeLinejoin),
          !0 === this.flatShading && (n.flatShading = this.flatShading),
          !1 === this.visible && (n.visible = !1),
          !1 === this.toneMapped && (n.toneMapped = !1),
          !1 === this.fog && (n.fog = !1),
          Object.keys(this.userData).length > 0 && (n.userData = this.userData),
          e)
        ) {
          const e = i(t.textures),
            r = i(t.images);
          e.length > 0 && (n.textures = e), r.length > 0 && (n.images = r);
        }
        return n;
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        (this.name = t.name),
          (this.blending = t.blending),
          (this.side = t.side),
          (this.vertexColors = t.vertexColors),
          (this.opacity = t.opacity),
          (this.transparent = t.transparent),
          (this.blendSrc = t.blendSrc),
          (this.blendDst = t.blendDst),
          (this.blendEquation = t.blendEquation),
          (this.blendSrcAlpha = t.blendSrcAlpha),
          (this.blendDstAlpha = t.blendDstAlpha),
          (this.blendEquationAlpha = t.blendEquationAlpha),
          (this.depthFunc = t.depthFunc),
          (this.depthTest = t.depthTest),
          (this.depthWrite = t.depthWrite),
          (this.stencilWriteMask = t.stencilWriteMask),
          (this.stencilFunc = t.stencilFunc),
          (this.stencilRef = t.stencilRef),
          (this.stencilFuncMask = t.stencilFuncMask),
          (this.stencilFail = t.stencilFail),
          (this.stencilZFail = t.stencilZFail),
          (this.stencilZPass = t.stencilZPass),
          (this.stencilWrite = t.stencilWrite);
        const e = t.clippingPlanes;
        let n = null;
        if (null !== e) {
          const t = e.length;
          n = new Array(t);
          for (let i = 0; i !== t; ++i) n[i] = e[i].clone();
        }
        return (
          (this.clippingPlanes = n),
          (this.clipIntersection = t.clipIntersection),
          (this.clipShadows = t.clipShadows),
          (this.shadowSide = t.shadowSide),
          (this.colorWrite = t.colorWrite),
          (this.precision = t.precision),
          (this.polygonOffset = t.polygonOffset),
          (this.polygonOffsetFactor = t.polygonOffsetFactor),
          (this.polygonOffsetUnits = t.polygonOffsetUnits),
          (this.dithering = t.dithering),
          (this.alphaTest = t.alphaTest),
          (this.alphaHash = t.alphaHash),
          (this.alphaToCoverage = t.alphaToCoverage),
          (this.premultipliedAlpha = t.premultipliedAlpha),
          (this.forceSinglePass = t.forceSinglePass),
          (this.visible = t.visible),
          (this.toneMapped = t.toneMapped),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          this
        );
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
    }
    const Rp = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074,
      },
      Lp = {
        h: 0,
        s: 0,
        l: 0,
      },
      Op = {
        h: 0,
        s: 0,
        l: 0,
      };
    function Ip(t, e, n) {
      return (
        n < 0 && (n += 1),
        n > 1 && (n -= 1),
        n < 1 / 6
          ? t + 6 * (e - t) * n
          : n < 0.5
          ? e
          : n < 2 / 3
          ? t + 6 * (e - t) * (2 / 3 - n)
          : t
      );
    }
    class Fp {
      constructor(t, e, n) {
        return (
          (this.isColor = !0),
          (this.r = 1),
          (this.g = 1),
          (this.b = 1),
          this.set(t, e, n)
        );
      }
      set(t, e, n) {
        if (void 0 === e && void 0 === n) {
          const e = t;
          e && e.isColor
            ? this.copy(e)
            : "number" == typeof e
            ? this.setHex(e)
            : "string" == typeof e && this.setStyle(e);
        } else this.setRGB(t, e, n);
        return this;
      }
      setScalar(t) {
        return (this.r = t), (this.g = t), (this.b = t), this;
      }
      setHex(t, e = "srgb") {
        return (
          (t = Math.floor(t)),
          (this.r = ((t >> 16) & 255) / 255),
          (this.g = ((t >> 8) & 255) / 255),
          (this.b = (255 & t) / 255),
          ed.toWorkingColorSpace(this, e),
          this
        );
      }
      setRGB(t, e, n, i = ed.workingColorSpace) {
        return (
          (this.r = t),
          (this.g = e),
          (this.b = n),
          ed.toWorkingColorSpace(this, i),
          this
        );
      }
      setHSL(t, e, n, i = ed.workingColorSpace) {
        if (((t = Uh(t, 1)), (e = Fh(e, 0, 1)), (n = Fh(n, 0, 1)), 0 === e))
          this.r = this.g = this.b = n;
        else {
          const i = n <= 0.5 ? n * (1 + e) : n + e - n * e,
            r = 2 * n - i;
          (this.r = Ip(r, i, t + 1 / 3)),
            (this.g = Ip(r, i, t)),
            (this.b = Ip(r, i, t - 1 / 3));
        }
        return ed.toWorkingColorSpace(this, i), this;
      }
      setStyle(t, e = "srgb") {
        function n(e) {
          void 0 !== e &&
            parseFloat(e) < 1 &&
            console.warn(
              "THREE.Color: Alpha component of " + t + " will be ignored."
            );
        }
        let i;
        if ((i = /^(\w+)\(([^\)]*)\)/.exec(t))) {
          let r;
          const s = i[1],
            o = i[2];
          switch (s) {
            case "rgb":
            case "rgba":
              if (
                (r =
                  /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    o
                  ))
              )
                return (
                  n(r[4]),
                  this.setRGB(
                    Math.min(255, parseInt(r[1], 10)) / 255,
                    Math.min(255, parseInt(r[2], 10)) / 255,
                    Math.min(255, parseInt(r[3], 10)) / 255,
                    e
                  )
                );
              if (
                (r =
                  /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    o
                  ))
              )
                return (
                  n(r[4]),
                  this.setRGB(
                    Math.min(100, parseInt(r[1], 10)) / 100,
                    Math.min(100, parseInt(r[2], 10)) / 100,
                    Math.min(100, parseInt(r[3], 10)) / 100,
                    e
                  )
                );
              break;
            case "hsl":
            case "hsla":
              if (
                (r =
                  /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                    o
                  ))
              )
                return (
                  n(r[4]),
                  this.setHSL(
                    parseFloat(r[1]) / 360,
                    parseFloat(r[2]) / 100,
                    parseFloat(r[3]) / 100,
                    e
                  )
                );
              break;
            default:
              console.warn("THREE.Color: Unknown color model " + t);
          }
        } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(t))) {
          const n = i[1],
            r = n.length;
          if (3 === r)
            return this.setRGB(
              parseInt(n.charAt(0), 16) / 15,
              parseInt(n.charAt(1), 16) / 15,
              parseInt(n.charAt(2), 16) / 15,
              e
            );
          if (6 === r) return this.setHex(parseInt(n, 16), e);
          console.warn("THREE.Color: Invalid hex color " + t);
        } else if (t && t.length > 0) return this.setColorName(t, e);
        return this;
      }
      setColorName(t, e = "srgb") {
        const n = Rp[t.toLowerCase()];
        return (
          void 0 !== n
            ? this.setHex(n, e)
            : console.warn("THREE.Color: Unknown color " + t),
          this
        );
      }
      clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
      copy(t) {
        return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
      }
      copySRGBToLinear(t) {
        return (this.r = Kh(t.r)), (this.g = Kh(t.g)), (this.b = Kh(t.b)), this;
      }
      copyLinearToSRGB(t) {
        return (this.r = Zh(t.r)), (this.g = Zh(t.g)), (this.b = Zh(t.b)), this;
      }
      convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this;
      }
      convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this;
      }
      getHex(t = "srgb") {
        return (
          ed.fromWorkingColorSpace(Up.copy(this), t),
          65536 * Math.round(Fh(255 * Up.r, 0, 255)) +
            256 * Math.round(Fh(255 * Up.g, 0, 255)) +
            Math.round(Fh(255 * Up.b, 0, 255))
        );
      }
      getHexString(t = "srgb") {
        return ("000000" + this.getHex(t).toString(16)).slice(-6);
      }
      getHSL(t, e = ed.workingColorSpace) {
        ed.fromWorkingColorSpace(Up.copy(this), e);
        const n = Up.r,
          i = Up.g,
          r = Up.b,
          s = Math.max(n, i, r),
          o = Math.min(n, i, r);
        let a, l;
        const c = (o + s) / 2;
        if (o === s) (a = 0), (l = 0);
        else {
          const t = s - o;
          switch (((l = c <= 0.5 ? t / (s + o) : t / (2 - s - o)), s)) {
            case n:
              a = (i - r) / t + (i < r ? 6 : 0);
              break;
            case i:
              a = (r - n) / t + 2;
              break;
            case r:
              a = (n - i) / t + 4;
          }
          a /= 6;
        }
        return (t.h = a), (t.s = l), (t.l = c), t;
      }
      getRGB(t, e = ed.workingColorSpace) {
        return (
          ed.fromWorkingColorSpace(Up.copy(this), e),
          (t.r = Up.r),
          (t.g = Up.g),
          (t.b = Up.b),
          t
        );
      }
      getStyle(t = "srgb") {
        ed.fromWorkingColorSpace(Up.copy(this), t);
        const e = Up.r,
          n = Up.g,
          i = Up.b;
        return "srgb" !== t
          ? `color(${t} ${e.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
          : `rgb(${Math.round(255 * e)},${Math.round(255 * n)},${Math.round(
              255 * i
            )})`;
      }
      offsetHSL(t, e, n) {
        return (
          this.getHSL(Lp),
          (Lp.h += t),
          (Lp.s += e),
          (Lp.l += n),
          this.setHSL(Lp.h, Lp.s, Lp.l),
          this
        );
      }
      add(t) {
        return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
      }
      addColors(t, e) {
        return (
          (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this
        );
      }
      addScalar(t) {
        return (this.r += t), (this.g += t), (this.b += t), this;
      }
      sub(t) {
        return (
          (this.r = Math.max(0, this.r - t.r)),
          (this.g = Math.max(0, this.g - t.g)),
          (this.b = Math.max(0, this.b - t.b)),
          this
        );
      }
      multiply(t) {
        return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
      }
      multiplyScalar(t) {
        return (this.r *= t), (this.g *= t), (this.b *= t), this;
      }
      lerp(t, e) {
        return (
          (this.r += (t.r - this.r) * e),
          (this.g += (t.g - this.g) * e),
          (this.b += (t.b - this.b) * e),
          this
        );
      }
      lerpColors(t, e, n) {
        return (
          (this.r = t.r + (e.r - t.r) * n),
          (this.g = t.g + (e.g - t.g) * n),
          (this.b = t.b + (e.b - t.b) * n),
          this
        );
      }
      lerpHSL(t, e) {
        this.getHSL(Lp), t.getHSL(Op);
        const n = Nh(Lp.h, Op.h, e),
          i = Nh(Lp.s, Op.s, e),
          r = Nh(Lp.l, Op.l, e);
        return this.setHSL(n, i, r), this;
      }
      setFromVector3(t) {
        return (this.r = t.x), (this.g = t.y), (this.b = t.z), this;
      }
      applyMatrix3(t) {
        const e = this.r,
          n = this.g,
          i = this.b,
          r = t.elements;
        return (
          (this.r = r[0] * e + r[3] * n + r[6] * i),
          (this.g = r[1] * e + r[4] * n + r[7] * i),
          (this.b = r[2] * e + r[5] * n + r[8] * i),
          this
        );
      }
      equals(t) {
        return t.r === this.r && t.g === this.g && t.b === this.b;
      }
      fromArray(t, e = 0) {
        return (this.r = t[e]), (this.g = t[e + 1]), (this.b = t[e + 2]), this;
      }
      toArray(t = [], e = 0) {
        return (t[e] = this.r), (t[e + 1] = this.g), (t[e + 2] = this.b), t;
      }
      fromBufferAttribute(t, e) {
        return (
          (this.r = t.getX(e)), (this.g = t.getY(e)), (this.b = t.getZ(e)), this
        );
      }
      toJSON() {
        return this.getHex();
      }
      *[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b;
      }
    }
    const Up = new Fp();
    Fp.NAMES = Rp;
    class Np extends Pp {
      constructor(t) {
        super(),
          (this.isMeshBasicMaterial = !0),
          (this.type = "MeshBasicMaterial"),
          (this.color = new Fp(16777215)),
          (this.map = null),
          (this.lightMap = null),
          (this.lightMapIntensity = 1),
          (this.aoMap = null),
          (this.aoMapIntensity = 1),
          (this.specularMap = null),
          (this.alphaMap = null),
          (this.envMap = null),
          (this.combine = 0),
          (this.reflectivity = 1),
          (this.refractionRatio = 0.98),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.wireframeLinecap = "round"),
          (this.wireframeLinejoin = "round"),
          (this.fog = !0),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          this.color.copy(t.color),
          (this.map = t.map),
          (this.lightMap = t.lightMap),
          (this.lightMapIntensity = t.lightMapIntensity),
          (this.aoMap = t.aoMap),
          (this.aoMapIntensity = t.aoMapIntensity),
          (this.specularMap = t.specularMap),
          (this.alphaMap = t.alphaMap),
          (this.envMap = t.envMap),
          (this.combine = t.combine),
          (this.reflectivity = t.reflectivity),
          (this.refractionRatio = t.refractionRatio),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.wireframeLinecap = t.wireframeLinecap),
          (this.wireframeLinejoin = t.wireframeLinejoin),
          (this.fog = t.fog),
          this
        );
      }
    }
    const kp = new md(),
      zp = new Vh();
    class Bp {
      constructor(t, e, n = !1) {
        if (Array.isArray(t))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array."
          );
        (this.isBufferAttribute = !0),
          (this.name = ""),
          (this.array = t),
          (this.itemSize = e),
          (this.count = void 0 !== t ? t.length / e : 0),
          (this.normalized = n),
          (this.usage = 35044),
          (this.updateRange = {
            offset: 0,
            count: -1,
          }),
          (this.gpuType = 1015),
          (this.version = 0);
      }
      onUploadCallback() {}
      set needsUpdate(t) {
        !0 === t && this.version++;
      }
      setUsage(t) {
        return (this.usage = t), this;
      }
      copy(t) {
        return (
          (this.name = t.name),
          (this.array = new t.array.constructor(t.array)),
          (this.itemSize = t.itemSize),
          (this.count = t.count),
          (this.normalized = t.normalized),
          (this.usage = t.usage),
          (this.gpuType = t.gpuType),
          this
        );
      }
      copyAt(t, e, n) {
        (t *= this.itemSize), (n *= e.itemSize);
        for (let i = 0, r = this.itemSize; i < r; i++)
          this.array[t + i] = e.array[n + i];
        return this;
      }
      copyArray(t) {
        return this.array.set(t), this;
      }
      applyMatrix3(t) {
        if (2 === this.itemSize)
          for (let e = 0, n = this.count; e < n; e++)
            zp.fromBufferAttribute(this, e),
              zp.applyMatrix3(t),
              this.setXY(e, zp.x, zp.y);
        else if (3 === this.itemSize)
          for (let e = 0, n = this.count; e < n; e++)
            kp.fromBufferAttribute(this, e),
              kp.applyMatrix3(t),
              this.setXYZ(e, kp.x, kp.y, kp.z);
        return this;
      }
      applyMatrix4(t) {
        for (let e = 0, n = this.count; e < n; e++)
          kp.fromBufferAttribute(this, e),
            kp.applyMatrix4(t),
            this.setXYZ(e, kp.x, kp.y, kp.z);
        return this;
      }
      applyNormalMatrix(t) {
        for (let e = 0, n = this.count; e < n; e++)
          kp.fromBufferAttribute(this, e),
            kp.applyNormalMatrix(t),
            this.setXYZ(e, kp.x, kp.y, kp.z);
        return this;
      }
      transformDirection(t) {
        for (let e = 0, n = this.count; e < n; e++)
          kp.fromBufferAttribute(this, e),
            kp.transformDirection(t),
            this.setXYZ(e, kp.x, kp.y, kp.z);
        return this;
      }
      set(t, e = 0) {
        return this.array.set(t, e), this;
      }
      getComponent(t, e) {
        let n = this.array[t * this.itemSize + e];
        return this.normalized && (n = Bh(n, this.array)), n;
      }
      setComponent(t, e, n) {
        return (
          this.normalized && (n = Hh(n, this.array)),
          (this.array[t * this.itemSize + e] = n),
          this
        );
      }
      getX(t) {
        let e = this.array[t * this.itemSize];
        return this.normalized && (e = Bh(e, this.array)), e;
      }
      setX(t, e) {
        return (
          this.normalized && (e = Hh(e, this.array)),
          (this.array[t * this.itemSize] = e),
          this
        );
      }
      getY(t) {
        let e = this.array[t * this.itemSize + 1];
        return this.normalized && (e = Bh(e, this.array)), e;
      }
      setY(t, e) {
        return (
          this.normalized && (e = Hh(e, this.array)),
          (this.array[t * this.itemSize + 1] = e),
          this
        );
      }
      getZ(t) {
        let e = this.array[t * this.itemSize + 2];
        return this.normalized && (e = Bh(e, this.array)), e;
      }
      setZ(t, e) {
        return (
          this.normalized && (e = Hh(e, this.array)),
          (this.array[t * this.itemSize + 2] = e),
          this
        );
      }
      getW(t) {
        let e = this.array[t * this.itemSize + 3];
        return this.normalized && (e = Bh(e, this.array)), e;
      }
      setW(t, e) {
        return (
          this.normalized && (e = Hh(e, this.array)),
          (this.array[t * this.itemSize + 3] = e),
          this
        );
      }
      setXY(t, e, n) {
        return (
          (t *= this.itemSize),
          this.normalized && ((e = Hh(e, this.array)), (n = Hh(n, this.array))),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          this
        );
      }
      setXYZ(t, e, n, i) {
        return (
          (t *= this.itemSize),
          this.normalized &&
            ((e = Hh(e, this.array)),
            (n = Hh(n, this.array)),
            (i = Hh(i, this.array))),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          (this.array[t + 2] = i),
          this
        );
      }
      setXYZW(t, e, n, i, r) {
        return (
          (t *= this.itemSize),
          this.normalized &&
            ((e = Hh(e, this.array)),
            (n = Hh(n, this.array)),
            (i = Hh(i, this.array)),
            (r = Hh(r, this.array))),
          (this.array[t + 0] = e),
          (this.array[t + 1] = n),
          (this.array[t + 2] = i),
          (this.array[t + 3] = r),
          this
        );
      }
      onUpload(t) {
        return (this.onUploadCallback = t), this;
      }
      clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
      toJSON() {
        const t = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized,
        };
        return (
          "" !== this.name && (t.name = this.name),
          35044 !== this.usage && (t.usage = this.usage),
          (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
            (t.updateRange = this.updateRange),
          t
        );
      }
    }
    class Hp extends Bp {
      constructor(t, e, n) {
        super(new Uint16Array(t), e, n);
      }
    }
    class Vp extends Bp {
      constructor(t, e, n) {
        super(new Uint32Array(t), e, n);
      }
    }
    class Gp extends Bp {
      constructor(t, e, n) {
        super(new Float32Array(t), e, n);
      }
    }
    let Wp = 0;
    const jp = new jd(),
      Xp = new gp(),
      qp = new md(),
      Yp = new _d(),
      Kp = new _d(),
      Zp = new md();
    class Jp extends Ph {
      constructor() {
        super(),
          (this.isBufferGeometry = !0),
          Object.defineProperty(this, "id", {
            value: Wp++,
          }),
          (this.uuid = Ih()),
          (this.name = ""),
          (this.type = "BufferGeometry"),
          (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.morphTargetsRelative = !1),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null),
          (this.drawRange = {
            start: 0,
            count: 1 / 0,
          }),
          (this.userData = {});
      }
      getIndex() {
        return this.index;
      }
      setIndex(t) {
        return (
          Array.isArray(t)
            ? (this.index = new (jh(t) ? Vp : Hp)(t, 1))
            : (this.index = t),
          this
        );
      }
      getAttribute(t) {
        return this.attributes[t];
      }
      setAttribute(t, e) {
        return (this.attributes[t] = e), this;
      }
      deleteAttribute(t) {
        return delete this.attributes[t], this;
      }
      hasAttribute(t) {
        return void 0 !== this.attributes[t];
      }
      addGroup(t, e, n = 0) {
        this.groups.push({
          start: t,
          count: e,
          materialIndex: n,
        });
      }
      clearGroups() {
        this.groups = [];
      }
      setDrawRange(t, e) {
        (this.drawRange.start = t), (this.drawRange.count = e);
      }
      applyMatrix4(t) {
        const e = this.attributes.position;
        void 0 !== e && (e.applyMatrix4(t), (e.needsUpdate = !0));
        const n = this.attributes.normal;
        if (void 0 !== n) {
          const e = new Gh().getNormalMatrix(t);
          n.applyNormalMatrix(e), (n.needsUpdate = !0);
        }
        const i = this.attributes.tangent;
        return (
          void 0 !== i && (i.transformDirection(t), (i.needsUpdate = !0)),
          null !== this.boundingBox && this.computeBoundingBox(),
          null !== this.boundingSphere && this.computeBoundingSphere(),
          this
        );
      }
      applyQuaternion(t) {
        return jp.makeRotationFromQuaternion(t), this.applyMatrix4(jp), this;
      }
      rotateX(t) {
        return jp.makeRotationX(t), this.applyMatrix4(jp), this;
      }
      rotateY(t) {
        return jp.makeRotationY(t), this.applyMatrix4(jp), this;
      }
      rotateZ(t) {
        return jp.makeRotationZ(t), this.applyMatrix4(jp), this;
      }
      translate(t, e, n) {
        return jp.makeTranslation(t, e, n), this.applyMatrix4(jp), this;
      }
      scale(t, e, n) {
        return jp.makeScale(t, e, n), this.applyMatrix4(jp), this;
      }
      lookAt(t) {
        return (
          Xp.lookAt(t), Xp.updateMatrix(), this.applyMatrix4(Xp.matrix), this
        );
      }
      center() {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(qp).negate(),
          this.translate(qp.x, qp.y, qp.z),
          this
        );
      }
      setFromPoints(t) {
        const e = [];
        for (let n = 0, i = t.length; n < i; n++) {
          const i = t[n];
          e.push(i.x, i.y, i.z || 0);
        }
        return this.setAttribute("position", new Gp(e, 3)), this;
      }
      computeBoundingBox() {
        null === this.boundingBox && (this.boundingBox = new _d());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingBox.set(
              new md(-1 / 0, -1 / 0, -1 / 0),
              new md(1 / 0, 1 / 0, 1 / 0)
            )
          );
        if (void 0 !== t) {
          if ((this.boundingBox.setFromBufferAttribute(t), e))
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              Yp.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (Zp.addVectors(this.boundingBox.min, Yp.min),
                    this.boundingBox.expandByPoint(Zp),
                    Zp.addVectors(this.boundingBox.max, Yp.max),
                    this.boundingBox.expandByPoint(Zp))
                  : (this.boundingBox.expandByPoint(Yp.min),
                    this.boundingBox.expandByPoint(Yp.max));
            }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
      }
      computeBoundingSphere() {
        null === this.boundingSphere && (this.boundingSphere = new Ud());
        const t = this.attributes.position,
          e = this.morphAttributes.position;
        if (t && t.isGLBufferAttribute)
          return (
            console.error(
              'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
              this
            ),
            void this.boundingSphere.set(new md(), 1 / 0)
          );
        if (t) {
          const n = this.boundingSphere.center;
          if ((Yp.setFromBufferAttribute(t), e))
            for (let t = 0, n = e.length; t < n; t++) {
              const n = e[t];
              Kp.setFromBufferAttribute(n),
                this.morphTargetsRelative
                  ? (Zp.addVectors(Yp.min, Kp.min),
                    Yp.expandByPoint(Zp),
                    Zp.addVectors(Yp.max, Kp.max),
                    Yp.expandByPoint(Zp))
                  : (Yp.expandByPoint(Kp.min), Yp.expandByPoint(Kp.max));
            }
          Yp.getCenter(n);
          let i = 0;
          for (let e = 0, r = t.count; e < r; e++)
            Zp.fromBufferAttribute(t, e),
              (i = Math.max(i, n.distanceToSquared(Zp)));
          if (e)
            for (let r = 0, s = e.length; r < s; r++) {
              const s = e[r],
                o = this.morphTargetsRelative;
              for (let e = 0, r = s.count; e < r; e++)
                Zp.fromBufferAttribute(s, e),
                  o && (qp.fromBufferAttribute(t, e), Zp.add(qp)),
                  (i = Math.max(i, n.distanceToSquared(Zp)));
            }
          (this.boundingSphere.radius = Math.sqrt(i)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      }
      computeTangents() {
        const t = this.index,
          e = this.attributes;
        if (
          null === t ||
          void 0 === e.position ||
          void 0 === e.normal ||
          void 0 === e.uv
        )
          return void console.error(
            "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
          );
        const n = t.array,
          i = e.position.array,
          r = e.normal.array,
          s = e.uv.array,
          o = i.length / 3;
        !1 === this.hasAttribute("tangent") &&
          this.setAttribute("tangent", new Bp(new Float32Array(4 * o), 4));
        const a = this.getAttribute("tangent").array,
          l = [],
          c = [];
        for (let t = 0; t < o; t++) (l[t] = new md()), (c[t] = new md());
        const u = new md(),
          h = new md(),
          d = new md(),
          p = new Vh(),
          f = new Vh(),
          m = new Vh(),
          g = new md(),
          v = new md();
        function _(t, e, n) {
          u.fromArray(i, 3 * t),
            h.fromArray(i, 3 * e),
            d.fromArray(i, 3 * n),
            p.fromArray(s, 2 * t),
            f.fromArray(s, 2 * e),
            m.fromArray(s, 2 * n),
            h.sub(u),
            d.sub(u),
            f.sub(p),
            m.sub(p);
          const r = 1 / (f.x * m.y - m.x * f.y);
          isFinite(r) &&
            (g
              .copy(h)
              .multiplyScalar(m.y)
              .addScaledVector(d, -f.y)
              .multiplyScalar(r),
            v
              .copy(d)
              .multiplyScalar(f.x)
              .addScaledVector(h, -m.x)
              .multiplyScalar(r),
            l[t].add(g),
            l[e].add(g),
            l[n].add(g),
            c[t].add(v),
            c[e].add(v),
            c[n].add(v));
        }
        let y = this.groups;
        0 === y.length &&
          (y = [
            {
              start: 0,
              count: n.length,
            },
          ]);
        for (let t = 0, e = y.length; t < e; ++t) {
          const e = y[t],
            i = e.start;
          for (let t = i, r = i + e.count; t < r; t += 3)
            _(n[t + 0], n[t + 1], n[t + 2]);
        }
        const x = new md(),
          b = new md(),
          S = new md(),
          E = new md();
        function M(t) {
          S.fromArray(r, 3 * t), E.copy(S);
          const e = l[t];
          x.copy(e),
            x.sub(S.multiplyScalar(S.dot(e))).normalize(),
            b.crossVectors(E, e);
          const n = b.dot(c[t]) < 0 ? -1 : 1;
          (a[4 * t] = x.x),
            (a[4 * t + 1] = x.y),
            (a[4 * t + 2] = x.z),
            (a[4 * t + 3] = n);
        }
        for (let t = 0, e = y.length; t < e; ++t) {
          const e = y[t],
            i = e.start;
          for (let t = i, r = i + e.count; t < r; t += 3)
            M(n[t + 0]), M(n[t + 1]), M(n[t + 2]);
        }
      }
      computeVertexNormals() {
        const t = this.index,
          e = this.getAttribute("position");
        if (void 0 !== e) {
          let n = this.getAttribute("normal");
          if (void 0 === n)
            (n = new Bp(new Float32Array(3 * e.count), 3)),
              this.setAttribute("normal", n);
          else for (let t = 0, e = n.count; t < e; t++) n.setXYZ(t, 0, 0, 0);
          const i = new md(),
            r = new md(),
            s = new md(),
            o = new md(),
            a = new md(),
            l = new md(),
            c = new md(),
            u = new md();
          if (t)
            for (let h = 0, d = t.count; h < d; h += 3) {
              const d = t.getX(h + 0),
                p = t.getX(h + 1),
                f = t.getX(h + 2);
              i.fromBufferAttribute(e, d),
                r.fromBufferAttribute(e, p),
                s.fromBufferAttribute(e, f),
                c.subVectors(s, r),
                u.subVectors(i, r),
                c.cross(u),
                o.fromBufferAttribute(n, d),
                a.fromBufferAttribute(n, p),
                l.fromBufferAttribute(n, f),
                o.add(c),
                a.add(c),
                l.add(c),
                n.setXYZ(d, o.x, o.y, o.z),
                n.setXYZ(p, a.x, a.y, a.z),
                n.setXYZ(f, l.x, l.y, l.z);
            }
          else
            for (let t = 0, o = e.count; t < o; t += 3)
              i.fromBufferAttribute(e, t + 0),
                r.fromBufferAttribute(e, t + 1),
                s.fromBufferAttribute(e, t + 2),
                c.subVectors(s, r),
                u.subVectors(i, r),
                c.cross(u),
                n.setXYZ(t + 0, c.x, c.y, c.z),
                n.setXYZ(t + 1, c.x, c.y, c.z),
                n.setXYZ(t + 2, c.x, c.y, c.z);
          this.normalizeNormals(), (n.needsUpdate = !0);
        }
      }
      normalizeNormals() {
        const t = this.attributes.normal;
        for (let e = 0, n = t.count; e < n; e++)
          Zp.fromBufferAttribute(t, e),
            Zp.normalize(),
            t.setXYZ(e, Zp.x, Zp.y, Zp.z);
      }
      toNonIndexed() {
        function t(t, e) {
          const n = t.array,
            i = t.itemSize,
            r = t.normalized,
            s = new n.constructor(e.length * i);
          let o = 0,
            a = 0;
          for (let r = 0, l = e.length; r < l; r++) {
            o = t.isInterleavedBufferAttribute
              ? e[r] * t.data.stride + t.offset
              : e[r] * i;
            for (let t = 0; t < i; t++) s[a++] = n[o++];
          }
          return new Bp(s, i, r);
        }
        if (null === this.index)
          return (
            console.warn(
              "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
            ),
            this
          );
        const e = new Jp(),
          n = this.index.array,
          i = this.attributes;
        for (const r in i) {
          const s = t(i[r], n);
          e.setAttribute(r, s);
        }
        const r = this.morphAttributes;
        for (const i in r) {
          const s = [],
            o = r[i];
          for (let e = 0, i = o.length; e < i; e++) {
            const i = t(o[e], n);
            s.push(i);
          }
          e.morphAttributes[i] = s;
        }
        e.morphTargetsRelative = this.morphTargetsRelative;
        const s = this.groups;
        for (let t = 0, n = s.length; t < n; t++) {
          const n = s[t];
          e.addGroup(n.start, n.count, n.materialIndex);
        }
        return e;
      }
      toJSON() {
        const t = {
          metadata: {
            version: 4.6,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON",
          },
        };
        if (
          ((t.uuid = this.uuid),
          (t.type = this.type),
          "" !== this.name && (t.name = this.name),
          Object.keys(this.userData).length > 0 && (t.userData = this.userData),
          void 0 !== this.parameters)
        ) {
          const e = this.parameters;
          for (const n in e) void 0 !== e[n] && (t[n] = e[n]);
          return t;
        }
        t.data = {
          attributes: {},
        };
        const e = this.index;
        null !== e &&
          (t.data.index = {
            type: e.array.constructor.name,
            array: Array.prototype.slice.call(e.array),
          });
        const n = this.attributes;
        for (const e in n) {
          const i = n[e];
          t.data.attributes[e] = i.toJSON(t.data);
        }
        const i = {};
        let r = !1;
        for (const e in this.morphAttributes) {
          const n = this.morphAttributes[e],
            s = [];
          for (let e = 0, i = n.length; e < i; e++) {
            const i = n[e];
            s.push(i.toJSON(t.data));
          }
          s.length > 0 && ((i[e] = s), (r = !0));
        }
        r &&
          ((t.data.morphAttributes = i),
          (t.data.morphTargetsRelative = this.morphTargetsRelative));
        const s = this.groups;
        s.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(s)));
        const o = this.boundingSphere;
        return (
          null !== o &&
            (t.data.boundingSphere = {
              center: o.center.toArray(),
              radius: o.radius,
            }),
          t
        );
      }
      clone() {
        return new this.constructor().copy(this);
      }
      copy(t) {
        (this.index = null),
          (this.attributes = {}),
          (this.morphAttributes = {}),
          (this.groups = []),
          (this.boundingBox = null),
          (this.boundingSphere = null);
        const e = {};
        this.name = t.name;
        const n = t.index;
        null !== n && this.setIndex(n.clone(e));
        const i = t.attributes;
        for (const t in i) {
          const n = i[t];
          this.setAttribute(t, n.clone(e));
        }
        const r = t.morphAttributes;
        for (const t in r) {
          const n = [],
            i = r[t];
          for (let t = 0, r = i.length; t < r; t++) n.push(i[t].clone(e));
          this.morphAttributes[t] = n;
        }
        this.morphTargetsRelative = t.morphTargetsRelative;
        const s = t.groups;
        for (let t = 0, e = s.length; t < e; t++) {
          const e = s[t];
          this.addGroup(e.start, e.count, e.materialIndex);
        }
        const o = t.boundingBox;
        null !== o && (this.boundingBox = o.clone());
        const a = t.boundingSphere;
        return (
          null !== a && (this.boundingSphere = a.clone()),
          (this.drawRange.start = t.drawRange.start),
          (this.drawRange.count = t.drawRange.count),
          (this.userData = t.userData),
          this
        );
      }
      dispose() {
        this.dispatchEvent({
          type: "dispose",
        });
      }
    }
    const $p = new jd(),
      Qp = new Wd(),
      tf = new Ud(),
      ef = new md(),
      nf = new md(),
      rf = new md(),
      sf = new md(),
      of = new md(),
      af = new md(),
      lf = new Vh(),
      cf = new Vh(),
      uf = new Vh(),
      hf = new md(),
      df = new md(),
      pf = new md(),
      ff = new md(),
      mf = new md();
    class gf extends gp {
      constructor(t = new Jp(), e = new Np()) {
        super(),
          (this.isMesh = !0),
          (this.type = "Mesh"),
          (this.geometry = t),
          (this.material = e),
          this.updateMorphTargets();
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          void 0 !== t.morphTargetInfluences &&
            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              t.morphTargetDictionary
            )),
          (this.material = t.material),
          (this.geometry = t.geometry),
          this
        );
      }
      updateMorphTargets() {
        const t = this.geometry.morphAttributes,
          e = Object.keys(t);
        if (e.length > 0) {
          const n = t[e[0]];
          if (void 0 !== n) {
            (this.morphTargetInfluences = []),
              (this.morphTargetDictionary = {});
            for (let t = 0, e = n.length; t < e; t++) {
              const e = n[t].name || String(t);
              this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[e] = t);
            }
          }
        }
      }
      getVertexPosition(t, e) {
        const n = this.geometry,
          i = n.attributes.position,
          r = n.morphAttributes.position,
          s = n.morphTargetsRelative;
        e.fromBufferAttribute(i, t);
        const o = this.morphTargetInfluences;
        if (r && o) {
          af.set(0, 0, 0);
          for (let n = 0, i = r.length; n < i; n++) {
            const i = o[n],
              a = r[n];
            0 !== i &&
              (of.fromBufferAttribute(a, t),
              s ? af.addScaledVector(of, i) : af.addScaledVector(of.sub(e), i));
          }
          e.add(af);
        }
        return e;
      }
      raycast(t, e) {
        const n = this.geometry,
          i = this.material,
          r = this.matrixWorld;
        if (void 0 !== i) {
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            tf.copy(n.boundingSphere),
            tf.applyMatrix4(r),
            Qp.copy(t.ray).recast(t.near),
            !1 === tf.containsPoint(Qp.origin))
          ) {
            if (null === Qp.intersectSphere(tf, ef)) return;
            if (Qp.origin.distanceToSquared(ef) > (t.far - t.near) ** 2) return;
          }
          $p.copy(r).invert(),
            Qp.copy(t.ray).applyMatrix4($p),
            (null !== n.boundingBox &&
              !1 === Qp.intersectsBox(n.boundingBox)) ||
              this._computeIntersections(t, e, Qp);
        }
      }
      _computeIntersections(t, e, n) {
        let i;
        const r = this.geometry,
          s = this.material,
          o = r.index,
          a = r.attributes.position,
          l = r.attributes.uv,
          c = r.attributes.uv1,
          u = r.attributes.normal,
          h = r.groups,
          d = r.drawRange;
        if (null !== o)
          if (Array.isArray(s))
            for (let r = 0, a = h.length; r < a; r++) {
              const a = h[r],
                p = s[a.materialIndex];
              for (
                let r = Math.max(a.start, d.start),
                  s = Math.min(
                    o.count,
                    Math.min(a.start + a.count, d.start + d.count)
                  );
                r < s;
                r += 3
              ) {
                (i = vf(
                  this,
                  p,
                  t,
                  n,
                  l,
                  c,
                  u,
                  o.getX(r),
                  o.getX(r + 1),
                  o.getX(r + 2)
                )),
                  i &&
                    ((i.faceIndex = Math.floor(r / 3)),
                    (i.face.materialIndex = a.materialIndex),
                    e.push(i));
              }
            }
          else {
            for (
              let r = Math.max(0, d.start),
                a = Math.min(o.count, d.start + d.count);
              r < a;
              r += 3
            ) {
              (i = vf(
                this,
                s,
                t,
                n,
                l,
                c,
                u,
                o.getX(r),
                o.getX(r + 1),
                o.getX(r + 2)
              )),
                i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
            }
          }
        else if (void 0 !== a)
          if (Array.isArray(s))
            for (let r = 0, o = h.length; r < o; r++) {
              const o = h[r],
                p = s[o.materialIndex];
              for (
                let r = Math.max(o.start, d.start),
                  s = Math.min(
                    a.count,
                    Math.min(o.start + o.count, d.start + d.count)
                  );
                r < s;
                r += 3
              ) {
                (i = vf(this, p, t, n, l, c, u, r, r + 1, r + 2)),
                  i &&
                    ((i.faceIndex = Math.floor(r / 3)),
                    (i.face.materialIndex = o.materialIndex),
                    e.push(i));
              }
            }
          else {
            for (
              let r = Math.max(0, d.start),
                o = Math.min(a.count, d.start + d.count);
              r < o;
              r += 3
            ) {
              (i = vf(this, s, t, n, l, c, u, r, r + 1, r + 2)),
                i && ((i.faceIndex = Math.floor(r / 3)), e.push(i));
            }
          }
      }
    }
    function vf(t, e, n, i, r, s, o, a, l, c) {
      t.getVertexPosition(a, nf),
        t.getVertexPosition(l, rf),
        t.getVertexPosition(c, sf);
      const u = (function (t, e, n, i, r, s, o, a) {
        let l;
        if (
          ((l =
            1 === e.side
              ? i.intersectTriangle(o, s, r, !0, a)
              : i.intersectTriangle(r, s, o, 0 === e.side, a)),
          null === l)
        )
          return null;
        mf.copy(a), mf.applyMatrix4(t.matrixWorld);
        const c = n.ray.origin.distanceTo(mf);
        return c < n.near || c > n.far
          ? null
          : {
              distance: c,
              point: mf.clone(),
              object: t,
            };
      })(t, e, n, i, nf, rf, sf, ff);
      if (u) {
        r &&
          (lf.fromBufferAttribute(r, a),
          cf.fromBufferAttribute(r, l),
          uf.fromBufferAttribute(r, c),
          (u.uv = Ap.getInterpolation(ff, nf, rf, sf, lf, cf, uf, new Vh()))),
          s &&
            (lf.fromBufferAttribute(s, a),
            cf.fromBufferAttribute(s, l),
            uf.fromBufferAttribute(s, c),
            (u.uv1 = Ap.getInterpolation(ff, nf, rf, sf, lf, cf, uf, new Vh())),
            (u.uv2 = u.uv1)),
          o &&
            (hf.fromBufferAttribute(o, a),
            df.fromBufferAttribute(o, l),
            pf.fromBufferAttribute(o, c),
            (u.normal = Ap.getInterpolation(
              ff,
              nf,
              rf,
              sf,
              hf,
              df,
              pf,
              new md()
            )),
            u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
        const t = {
          a: a,
          b: l,
          c: c,
          normal: new md(),
          materialIndex: 0,
        };
        Ap.getNormal(nf, rf, sf, t.normal), (u.face = t);
      }
      return u;
    }
    class _f extends Jp {
      constructor(t = 1, e = 1, n = 1, i = 1, r = 1, s = 1) {
        super(),
          (this.type = "BoxGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: s,
          });
        const o = this;
        (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
        const a = [],
          l = [],
          c = [],
          u = [];
        let h = 0,
          d = 0;
        function p(t, e, n, i, r, s, p, f, m, g, v) {
          const _ = s / m,
            y = p / g,
            x = s / 2,
            b = p / 2,
            S = f / 2,
            E = m + 1,
            M = g + 1;
          let T = 0,
            w = 0;
          const D = new md();
          for (let s = 0; s < M; s++) {
            const o = s * y - b;
            for (let a = 0; a < E; a++) {
              const h = a * _ - x;
              (D[t] = h * i),
                (D[e] = o * r),
                (D[n] = S),
                l.push(D.x, D.y, D.z),
                (D[t] = 0),
                (D[e] = 0),
                (D[n] = f > 0 ? 1 : -1),
                c.push(D.x, D.y, D.z),
                u.push(a / m),
                u.push(1 - s / g),
                (T += 1);
            }
          }
          for (let t = 0; t < g; t++)
            for (let e = 0; e < m; e++) {
              const n = h + e + E * t,
                i = h + e + E * (t + 1),
                r = h + (e + 1) + E * (t + 1),
                s = h + (e + 1) + E * t;
              a.push(n, i, s), a.push(i, r, s), (w += 6);
            }
          o.addGroup(d, w, v), (d += w), (h += T);
        }
        p("z", "y", "x", -1, -1, n, e, t, s, r, 0),
          p("z", "y", "x", 1, -1, n, e, -t, s, r, 1),
          p("x", "z", "y", 1, 1, t, n, e, i, s, 2),
          p("x", "z", "y", 1, -1, t, n, -e, i, s, 3),
          p("x", "y", "z", 1, -1, t, e, n, i, r, 4),
          p("x", "y", "z", -1, -1, t, e, -n, i, r, 5),
          this.setIndex(a),
          this.setAttribute("position", new Gp(l, 3)),
          this.setAttribute("normal", new Gp(c, 3)),
          this.setAttribute("uv", new Gp(u, 2));
      }
      copy(t) {
        return (
          super.copy(t),
          (this.parameters = Object.assign({}, t.parameters)),
          this
        );
      }
      static fromJSON(t) {
        return new _f(
          t.width,
          t.height,
          t.depth,
          t.widthSegments,
          t.heightSegments,
          t.depthSegments
        );
      }
    }
    function yf(t) {
      const e = {};
      for (const n in t) {
        e[n] = {};
        for (const i in t[n]) {
          const r = t[n][i];
          r &&
          (r.isColor ||
            r.isMatrix3 ||
            r.isMatrix4 ||
            r.isVector2 ||
            r.isVector3 ||
            r.isVector4 ||
            r.isTexture ||
            r.isQuaternion)
            ? r.isRenderTargetTexture
              ? (console.warn(
                  "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                ),
                (e[n][i] = null))
              : (e[n][i] = r.clone())
            : Array.isArray(r)
            ? (e[n][i] = r.slice())
            : (e[n][i] = r);
        }
      }
      return e;
    }
    function xf(t) {
      const e = {};
      for (let n = 0; n < t.length; n++) {
        const i = yf(t[n]);
        for (const t in i) e[t] = i[t];
      }
      return e;
    }
    function bf(t) {
      return null === t.getRenderTarget() ? t.outputColorSpace : "srgb-linear";
    }
    const Sf = {
      clone: yf,
      merge: xf,
    };
    class Ef extends Pp {
      constructor(t) {
        super(),
          (this.isShaderMaterial = !0),
          (this.type = "ShaderMaterial"),
          (this.defines = {}),
          (this.uniforms = {}),
          (this.uniformsGroups = []),
          (this.vertexShader =
            "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
          (this.fragmentShader =
            "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
          (this.linewidth = 1),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          (this.fog = !1),
          (this.lights = !1),
          (this.clipping = !1),
          (this.forceSinglePass = !0),
          (this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1,
          }),
          (this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0],
          }),
          (this.index0AttributeName = void 0),
          (this.uniformsNeedUpdate = !1),
          (this.glslVersion = null),
          void 0 !== t && this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.fragmentShader = t.fragmentShader),
          (this.vertexShader = t.vertexShader),
          (this.uniforms = yf(t.uniforms)),
          (this.uniformsGroups = (function (t) {
            const e = [];
            for (let n = 0; n < t.length; n++) e.push(t[n].clone());
            return e;
          })(t.uniformsGroups)),
          (this.defines = Object.assign({}, t.defines)),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          (this.fog = t.fog),
          (this.lights = t.lights),
          (this.clipping = t.clipping),
          (this.extensions = Object.assign({}, t.extensions)),
          (this.glslVersion = t.glslVersion),
          this
        );
      }
      toJSON(t) {
        const e = super.toJSON(t);
        (e.glslVersion = this.glslVersion), (e.uniforms = {});
        for (const n in this.uniforms) {
          const i = this.uniforms[n].value;
          i && i.isTexture
            ? (e.uniforms[n] = {
                type: "t",
                value: i.toJSON(t).uuid,
              })
            : i && i.isColor
            ? (e.uniforms[n] = {
                type: "c",
                value: i.getHex(),
              })
            : i && i.isVector2
            ? (e.uniforms[n] = {
                type: "v2",
                value: i.toArray(),
              })
            : i && i.isVector3
            ? (e.uniforms[n] = {
                type: "v3",
                value: i.toArray(),
              })
            : i && i.isVector4
            ? (e.uniforms[n] = {
                type: "v4",
                value: i.toArray(),
              })
            : i && i.isMatrix3
            ? (e.uniforms[n] = {
                type: "m3",
                value: i.toArray(),
              })
            : i && i.isMatrix4
            ? (e.uniforms[n] = {
                type: "m4",
                value: i.toArray(),
              })
            : (e.uniforms[n] = {
                value: i,
              });
        }
        Object.keys(this.defines).length > 0 && (e.defines = this.defines),
          (e.vertexShader = this.vertexShader),
          (e.fragmentShader = this.fragmentShader),
          (e.lights = this.lights),
          (e.clipping = this.clipping);
        const n = {};
        for (const t in this.extensions)
          !0 === this.extensions[t] && (n[t] = !0);
        return Object.keys(n).length > 0 && (e.extensions = n), e;
      }
    }
    class Mf extends gp {
      constructor() {
        super(),
          (this.isCamera = !0),
          (this.type = "Camera"),
          (this.matrixWorldInverse = new jd()),
          (this.projectionMatrix = new jd()),
          (this.projectionMatrixInverse = new jd()),
          (this.coordinateSystem = 2e3);
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          this.matrixWorldInverse.copy(t.matrixWorldInverse),
          this.projectionMatrix.copy(t.projectionMatrix),
          this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
          (this.coordinateSystem = t.coordinateSystem),
          this
        );
      }
      getWorldDirection(t) {
        this.updateWorldMatrix(!0, !1);
        const e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize();
      }
      updateMatrixWorld(t) {
        super.updateMatrixWorld(t),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      updateWorldMatrix(t, e) {
        super.updateWorldMatrix(t, e),
          this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    class Tf extends Mf {
      constructor(t = 50, e = 1, n = 0.1, i = 2e3) {
        super(),
          (this.isPerspectiveCamera = !0),
          (this.type = "PerspectiveCamera"),
          (this.fov = t),
          (this.zoom = 1),
          (this.near = n),
          (this.far = i),
          (this.focus = 10),
          (this.aspect = e),
          (this.view = null),
          (this.filmGauge = 35),
          (this.filmOffset = 0),
          this.updateProjectionMatrix();
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          (this.fov = t.fov),
          (this.zoom = t.zoom),
          (this.near = t.near),
          (this.far = t.far),
          (this.focus = t.focus),
          (this.aspect = t.aspect),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          (this.filmGauge = t.filmGauge),
          (this.filmOffset = t.filmOffset),
          this
        );
      }
      setFocalLength(t) {
        const e = (0.5 * this.getFilmHeight()) / t;
        (this.fov = 2 * Oh * Math.atan(e)), this.updateProjectionMatrix();
      }
      getFocalLength() {
        const t = Math.tan(0.5 * Lh * this.fov);
        return (0.5 * this.getFilmHeight()) / t;
      }
      getEffectiveFOV() {
        return 2 * Oh * Math.atan(Math.tan(0.5 * Lh * this.fov) / this.zoom);
      }
      getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1);
      }
      getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1);
      }
      setViewOffset(t, e, n, i, r, s) {
        (this.aspect = t / e),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = this.near;
        let e = (t * Math.tan(0.5 * Lh * this.fov)) / this.zoom,
          n = 2 * e,
          i = this.aspect * n,
          r = -0.5 * i;
        const s = this.view;
        if (null !== this.view && this.view.enabled) {
          const t = s.fullWidth,
            o = s.fullHeight;
          (r += (s.offsetX * i) / t),
            (e -= (s.offsetY * n) / o),
            (i *= s.width / t),
            (n *= s.height / o);
        }
        const o = this.filmOffset;
        0 !== o && (r += (t * o) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + i,
            e,
            e - n,
            t,
            this.far,
            this.coordinateSystem
          ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          (e.object.fov = this.fov),
          (e.object.zoom = this.zoom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          (e.object.focus = this.focus),
          (e.object.aspect = this.aspect),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          (e.object.filmGauge = this.filmGauge),
          (e.object.filmOffset = this.filmOffset),
          e
        );
      }
    }
    class wf extends gp {
      constructor(t, e, n) {
        super(),
          (this.type = "CubeCamera"),
          (this.renderTarget = n),
          (this.coordinateSystem = null);
        const i = new Tf(-90, 1, t, e);
        (i.layers = this.layers), this.add(i);
        const r = new Tf(-90, 1, t, e);
        (r.layers = this.layers), this.add(r);
        const s = new Tf(-90, 1, t, e);
        (s.layers = this.layers), this.add(s);
        const o = new Tf(-90, 1, t, e);
        (o.layers = this.layers), this.add(o);
        const a = new Tf(-90, 1, t, e);
        (a.layers = this.layers), this.add(a);
        const l = new Tf(-90, 1, t, e);
        (l.layers = this.layers), this.add(l);
      }
      updateCoordinateSystem() {
        const t = this.coordinateSystem,
          e = this.children.concat(),
          [n, i, r, s, o, a] = e;
        for (const t of e) this.remove(t);
        if (2e3 === t)
          n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            i.up.set(0, 1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, 0, -1),
            r.lookAt(0, 1, 0),
            s.up.set(0, 0, 1),
            s.lookAt(0, -1, 0),
            o.up.set(0, 1, 0),
            o.lookAt(0, 0, 1),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, -1);
        else {
          if (2001 !== t)
            throw new Error(
              "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                t
            );
          n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            i.up.set(0, -1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 0, 1),
            r.lookAt(0, 1, 0),
            s.up.set(0, 0, -1),
            s.lookAt(0, -1, 0),
            o.up.set(0, -1, 0),
            o.lookAt(0, 0, 1),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, -1);
        }
        for (const t of e) this.add(t), t.updateMatrixWorld();
      }
      update(t, e) {
        null === this.parent && this.updateMatrixWorld();
        const n = this.renderTarget;
        this.coordinateSystem !== t.coordinateSystem &&
          ((this.coordinateSystem = t.coordinateSystem),
          this.updateCoordinateSystem());
        const [i, r, s, o, a, l] = this.children,
          c = t.getRenderTarget(),
          u = t.xr.enabled;
        t.xr.enabled = !1;
        const h = n.texture.generateMipmaps;
        (n.texture.generateMipmaps = !1),
          t.setRenderTarget(n, 0),
          t.render(e, i),
          t.setRenderTarget(n, 1),
          t.render(e, r),
          t.setRenderTarget(n, 2),
          t.render(e, s),
          t.setRenderTarget(n, 3),
          t.render(e, o),
          t.setRenderTarget(n, 4),
          t.render(e, a),
          (n.texture.generateMipmaps = h),
          t.setRenderTarget(n, 5),
          t.render(e, l),
          t.setRenderTarget(c),
          (t.xr.enabled = u),
          (n.texture.needsPMREMUpdate = !0);
      }
    }
    class Df extends ld {
      constructor(t, e, n, i, r, s, o, a, l, c) {
        super(
          (t = void 0 !== t ? t : []),
          (e = void 0 !== e ? e : 301),
          n,
          i,
          r,
          s,
          o,
          a,
          l,
          c
        ),
          (this.isCubeTexture = !0),
          (this.flipY = !1);
      }
      get images() {
        return this.image;
      }
      set images(t) {
        this.image = t;
      }
    }
    class Af extends hd {
      constructor(t = 1, e = {}) {
        super(t, t, e), (this.isWebGLCubeRenderTarget = !0);
        const n = {
            width: t,
            height: t,
            depth: 1,
          },
          i = [n, n, n, n, n, n];
        void 0 !== e.encoding &&
          (Yh(
            "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
          ),
          (e.colorSpace = 3001 === e.encoding ? "srgb" : "")),
          (this.texture = new Df(
            i,
            e.mapping,
            e.wrapS,
            e.wrapT,
            e.magFilter,
            e.minFilter,
            e.format,
            e.type,
            e.anisotropy,
            e.colorSpace
          )),
          (this.texture.isRenderTargetTexture = !0),
          (this.texture.generateMipmaps =
            void 0 !== e.generateMipmaps && e.generateMipmaps),
          (this.texture.minFilter =
            void 0 !== e.minFilter ? e.minFilter : 1006);
      }
      fromEquirectangularTexture(t, e) {
        (this.texture.type = e.type),
          (this.texture.colorSpace = e.colorSpace),
          (this.texture.generateMipmaps = e.generateMipmaps),
          (this.texture.minFilter = e.minFilter),
          (this.texture.magFilter = e.magFilter);
        const n = {
            uniforms: {
              tEquirect: {
                value: null,
              },
            },
            vertexShader:
              "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
            fragmentShader:
              "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
          },
          i = new _f(5, 5, 5),
          r = new Ef({
            name: "CubemapFromEquirect",
            uniforms: yf(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: 1,
            blending: 0,
          });
        r.uniforms.tEquirect.value = e;
        const s = new gf(i, r),
          o = e.minFilter;
        1008 === e.minFilter && (e.minFilter = 1006);
        return (
          new wf(1, 10, this).update(t, s),
          (e.minFilter = o),
          s.geometry.dispose(),
          s.material.dispose(),
          this
        );
      }
      clear(t, e, n, i) {
        const r = t.getRenderTarget();
        for (let r = 0; r < 6; r++)
          t.setRenderTarget(this, r), t.clear(e, n, i);
        t.setRenderTarget(r);
      }
    }
    const Cf = new md(),
      Pf = new md(),
      Rf = new Gh();
    class Lf {
      constructor(t = new md(1, 0, 0), e = 0) {
        (this.isPlane = !0), (this.normal = t), (this.constant = e);
      }
      set(t, e) {
        return this.normal.copy(t), (this.constant = e), this;
      }
      setComponents(t, e, n, i) {
        return this.normal.set(t, e, n), (this.constant = i), this;
      }
      setFromNormalAndCoplanarPoint(t, e) {
        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
      }
      setFromCoplanarPoints(t, e, n) {
        const i = Cf.subVectors(n, e).cross(Pf.subVectors(t, e)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, t), this;
      }
      copy(t) {
        return this.normal.copy(t.normal), (this.constant = t.constant), this;
      }
      normalize() {
        const t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), (this.constant *= t), this;
      }
      negate() {
        return (this.constant *= -1), this.normal.negate(), this;
      }
      distanceToPoint(t) {
        return this.normal.dot(t) + this.constant;
      }
      distanceToSphere(t) {
        return this.distanceToPoint(t.center) - t.radius;
      }
      projectPoint(t, e) {
        return e.copy(t).addScaledVector(this.normal, -this.distanceToPoint(t));
      }
      intersectLine(t, e) {
        const n = t.delta(Cf),
          i = this.normal.dot(n);
        if (0 === i)
          return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : null;
        const r = -(t.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1 ? null : e.copy(t.start).addScaledVector(n, r);
      }
      intersectsLine(t) {
        const e = this.distanceToPoint(t.start),
          n = this.distanceToPoint(t.end);
        return (e < 0 && n > 0) || (n < 0 && e > 0);
      }
      intersectsBox(t) {
        return t.intersectsPlane(this);
      }
      intersectsSphere(t) {
        return t.intersectsPlane(this);
      }
      coplanarPoint(t) {
        return t.copy(this.normal).multiplyScalar(-this.constant);
      }
      applyMatrix4(t, e) {
        const n = e || Rf.getNormalMatrix(t),
          i = this.coplanarPoint(Cf).applyMatrix4(t),
          r = this.normal.applyMatrix3(n).normalize();
        return (this.constant = -i.dot(r)), this;
      }
      translate(t) {
        return (this.constant -= t.dot(this.normal)), this;
      }
      equals(t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    const Of = new Ud(),
      If = new md();
    class Ff {
      constructor(
        t = new Lf(),
        e = new Lf(),
        n = new Lf(),
        i = new Lf(),
        r = new Lf(),
        s = new Lf()
      ) {
        this.planes = [t, e, n, i, r, s];
      }
      set(t, e, n, i, r, s) {
        const o = this.planes;
        return (
          o[0].copy(t),
          o[1].copy(e),
          o[2].copy(n),
          o[3].copy(i),
          o[4].copy(r),
          o[5].copy(s),
          this
        );
      }
      copy(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) e[n].copy(t.planes[n]);
        return this;
      }
      setFromProjectionMatrix(t, e = 2e3) {
        const n = this.planes,
          i = t.elements,
          r = i[0],
          s = i[1],
          o = i[2],
          a = i[3],
          l = i[4],
          c = i[5],
          u = i[6],
          h = i[7],
          d = i[8],
          p = i[9],
          f = i[10],
          m = i[11],
          g = i[12],
          v = i[13],
          _ = i[14],
          y = i[15];
        if (
          (n[0].setComponents(a - r, h - l, m - d, y - g).normalize(),
          n[1].setComponents(a + r, h + l, m + d, y + g).normalize(),
          n[2].setComponents(a + s, h + c, m + p, y + v).normalize(),
          n[3].setComponents(a - s, h - c, m - p, y - v).normalize(),
          n[4].setComponents(a - o, h - u, m - f, y - _).normalize(),
          2e3 === e)
        )
          n[5].setComponents(a + o, h + u, m + f, y + _).normalize();
        else {
          if (2001 !== e)
            throw new Error(
              "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                e
            );
          n[5].setComponents(o, u, f, _).normalize();
        }
        return this;
      }
      intersectsObject(t) {
        if (void 0 !== t.boundingSphere)
          null === t.boundingSphere && t.computeBoundingSphere(),
            Of.copy(t.boundingSphere).applyMatrix4(t.matrixWorld);
        else {
          const e = t.geometry;
          null === e.boundingSphere && e.computeBoundingSphere(),
            Of.copy(e.boundingSphere).applyMatrix4(t.matrixWorld);
        }
        return this.intersectsSphere(Of);
      }
      intersectsSprite(t) {
        return (
          Of.center.set(0, 0, 0),
          (Of.radius = 0.7071067811865476),
          Of.applyMatrix4(t.matrixWorld),
          this.intersectsSphere(Of)
        );
      }
      intersectsSphere(t) {
        const e = this.planes,
          n = t.center,
          i = -t.radius;
        for (let t = 0; t < 6; t++) {
          if (e[t].distanceToPoint(n) < i) return !1;
        }
        return !0;
      }
      intersectsBox(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) {
          const i = e[n];
          if (
            ((If.x = i.normal.x > 0 ? t.max.x : t.min.x),
            (If.y = i.normal.y > 0 ? t.max.y : t.min.y),
            (If.z = i.normal.z > 0 ? t.max.z : t.min.z),
            i.distanceToPoint(If) < 0)
          )
            return !1;
        }
        return !0;
      }
      containsPoint(t) {
        const e = this.planes;
        for (let n = 0; n < 6; n++) if (e[n].distanceToPoint(t) < 0) return !1;
        return !0;
      }
      clone() {
        return new this.constructor().copy(this);
      }
    }
    function Uf() {
      let t = null,
        e = !1,
        n = null,
        i = null;
      function r(e, s) {
        n(e, s), (i = t.requestAnimationFrame(r));
      }
      return {
        start: function () {
          !0 !== e &&
            null !== n &&
            ((i = t.requestAnimationFrame(r)), (e = !0));
        },
        stop: function () {
          t.cancelAnimationFrame(i), (e = !1);
        },
        setAnimationLoop: function (t) {
          n = t;
        },
        setContext: function (e) {
          t = e;
        },
      };
    }
    function Nf(t, e) {
      const n = e.isWebGL2,
        i = new WeakMap();
      return {
        get: function (t) {
          return t.isInterleavedBufferAttribute && (t = t.data), i.get(t);
        },
        remove: function (e) {
          e.isInterleavedBufferAttribute && (e = e.data);
          const n = i.get(e);
          n && (t.deleteBuffer(n.buffer), i.delete(e));
        },
        update: function (e, r) {
          if (e.isGLBufferAttribute) {
            const t = i.get(e);
            return void (
              (!t || t.version < e.version) &&
              i.set(e, {
                buffer: e.buffer,
                type: e.type,
                bytesPerElement: e.elementSize,
                version: e.version,
              })
            );
          }
          e.isInterleavedBufferAttribute && (e = e.data);
          const s = i.get(e);
          void 0 === s
            ? i.set(
                e,
                (function (e, i) {
                  const r = e.array,
                    s = e.usage,
                    o = t.createBuffer();
                  let a;
                  if (
                    (t.bindBuffer(i, o),
                    t.bufferData(i, r, s),
                    e.onUploadCallback(),
                    r instanceof Float32Array)
                  )
                    a = t.FLOAT;
                  else if (r instanceof Uint16Array)
                    if (e.isFloat16BufferAttribute) {
                      if (!n)
                        throw new Error(
                          "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                        );
                      a = t.HALF_FLOAT;
                    } else a = t.UNSIGNED_SHORT;
                  else if (r instanceof Int16Array) a = t.SHORT;
                  else if (r instanceof Uint32Array) a = t.UNSIGNED_INT;
                  else if (r instanceof Int32Array) a = t.INT;
                  else if (r instanceof Int8Array) a = t.BYTE;
                  else if (r instanceof Uint8Array) a = t.UNSIGNED_BYTE;
                  else {
                    if (!(r instanceof Uint8ClampedArray))
                      throw new Error(
                        "THREE.WebGLAttributes: Unsupported buffer data format: " +
                          r
                      );
                    a = t.UNSIGNED_BYTE;
                  }
                  return {
                    buffer: o,
                    type: a,
                    bytesPerElement: r.BYTES_PER_ELEMENT,
                    version: e.version,
                  };
                })(e, r)
              )
            : s.version < e.version &&
              (!(function (e, i, r) {
                const s = i.array,
                  o = i.updateRange;
                t.bindBuffer(r, e),
                  -1 === o.count
                    ? t.bufferSubData(r, 0, s)
                    : (n
                        ? t.bufferSubData(
                            r,
                            o.offset * s.BYTES_PER_ELEMENT,
                            s,
                            o.offset,
                            o.count
                          )
                        : t.bufferSubData(
                            r,
                            o.offset * s.BYTES_PER_ELEMENT,
                            s.subarray(o.offset, o.offset + o.count)
                          ),
                      (o.count = -1)),
                  i.onUploadCallback();
              })(s.buffer, e, r),
              (s.version = e.version));
        },
      };
    }
    class kf extends Jp {
      constructor(t = 1, e = 1, n = 1, i = 1) {
        super(),
          (this.type = "PlaneGeometry"),
          (this.parameters = {
            width: t,
            height: e,
            widthSegments: n,
            heightSegments: i,
          });
        const r = t / 2,
          s = e / 2,
          o = Math.floor(n),
          a = Math.floor(i),
          l = o + 1,
          c = a + 1,
          u = t / o,
          h = e / a,
          d = [],
          p = [],
          f = [],
          m = [];
        for (let t = 0; t < c; t++) {
          const e = t * h - s;
          for (let n = 0; n < l; n++) {
            const i = n * u - r;
            p.push(i, -e, 0), f.push(0, 0, 1), m.push(n / o), m.push(1 - t / a);
          }
        }
        for (let t = 0; t < a; t++)
          for (let e = 0; e < o; e++) {
            const n = e + l * t,
              i = e + l * (t + 1),
              r = e + 1 + l * (t + 1),
              s = e + 1 + l * t;
            d.push(n, i, s), d.push(i, r, s);
          }
        this.setIndex(d),
          this.setAttribute("position", new Gp(p, 3)),
          this.setAttribute("normal", new Gp(f, 3)),
          this.setAttribute("uv", new Gp(m, 2));
      }
      copy(t) {
        return (
          super.copy(t),
          (this.parameters = Object.assign({}, t.parameters)),
          this
        );
      }
      static fromJSON(t) {
        return new kf(t.width, t.height, t.widthSegments, t.heightSegments);
      }
    }
    const zf = {
        alphahash_fragment:
          "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
        alphahash_pars_fragment:
          "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
        alphamap_fragment:
          "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
        alphamap_pars_fragment:
          "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment:
          "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
        alphatest_pars_fragment:
          "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
        aomap_fragment:
          "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
        aomap_pars_fragment:
          "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex:
          "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
        beginnormal_vertex:
          "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
        bsdfs:
          "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
        iridescence_fragment:
          "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
        bumpmap_pars_fragment:
          "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
        clipping_planes_vertex:
          "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
        color_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
        color_vertex:
          "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
        common:
          "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
        cube_uv_reflection_fragment:
          "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
        defaultnormal_vertex:
          "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
        displacementmap_pars_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex:
          "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment:
          "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        colorspace_fragment:
          "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        colorspace_pars_fragment:
          "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
        envmap_fragment:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_common_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
        envmap_pars_fragment:
          "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex:
          "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment:
          "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
        envmap_vertex:
          "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
        fog_fragment:
          "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment:
          "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment:
          "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
        lightmap_fragment:
          "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
        lightmap_pars_fragment:
          "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_fragment:
          "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
        lights_lambert_pars_fragment:
          "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
        lights_pars_begin:
          "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
        lights_toon_fragment:
          "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
        lights_toon_pars_fragment:
          "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
        lights_phong_fragment:
          "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment:
          "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
        lights_physical_fragment:
          "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
        lights_physical_pars_fragment:
          "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin:
          "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps:
          "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
        lights_fragment_end:
          "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment:
          "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
        logdepthbuf_pars_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex:
          "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
        map_fragment:
          "#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, vMapUv );\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment:
          "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
        map_particle_pars_fragment:
          "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        metalnessmap_fragment:
          "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment:
          "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphcolor_vertex:
          "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
        morphnormal_vertex:
          "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
        morphtarget_pars_vertex:
          "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
        morphtarget_vertex:
          "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
        normal_fragment_begin:
          "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
        normal_fragment_maps:
          "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
        normal_pars_fragment:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_pars_vertex:
          "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
        normal_vertex:
          "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
        normalmap_pars_fragment:
          "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
        clearcoat_normal_fragment_begin:
          "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
        clearcoat_normal_fragment_maps:
          "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
        clearcoat_pars_fragment:
          "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
        iridescence_pars_fragment:
          "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
        opaque_fragment:
          "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
        packing:
          "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
        premultiplied_alpha_fragment:
          "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex:
          "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment:
          "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment:
          "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment:
          "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment:
          "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment:
          "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex:
          "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
        shadowmap_vertex:
          "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
        shadowmask_pars_fragment:
          "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex:
          "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex:
          "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
        skinning_vertex:
          "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex:
          "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
        specularmap_fragment:
          "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment:
          "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment:
          "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment:
          "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
        transmission_fragment:
          "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
        transmission_pars_fragment:
          "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
        uv_pars_fragment:
          "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
        uv_pars_vertex:
          "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
        uv_vertex:
          "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
        worldpos_vertex:
          "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
        background_vert:
          "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        background_frag:
          "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        backgroundCube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        backgroundCube_frag:
          "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        cube_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        cube_frag:
          "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        depth_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
        depth_frag:
          "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
        distanceRGBA_vert:
          "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        distanceRGBA_frag:
          "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        equirect_vert:
          "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        equirect_frag:
          "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
        linedashed_vert:
          "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        linedashed_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        meshbasic_vert:
          "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert:
          "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag:
          "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshmatcap_vert:
          "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshmatcap_frag:
          "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshnormal_vert:
          "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        meshnormal_frag:
          "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
        meshphong_vert:
          "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphong_frag:
          "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert:
          "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
        meshphysical_frag:
          "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshtoon_vert:
          "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshtoon_frag:
          "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        points_vert:
          "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        points_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
        shadow_vert:
          "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag:
          "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert:
          "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag:
          "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
      },
      Bf = {
        common: {
          diffuse: {
            value: new Fp(16777215),
          },
          opacity: {
            value: 1,
          },
          map: {
            value: null,
          },
          mapTransform: {
            value: new Gh(),
          },
          alphaMap: {
            value: null,
          },
          alphaMapTransform: {
            value: new Gh(),
          },
          alphaTest: {
            value: 0,
          },
        },
        specularmap: {
          specularMap: {
            value: null,
          },
          specularMapTransform: {
            value: new Gh(),
          },
        },
        envmap: {
          envMap: {
            value: null,
          },
          flipEnvMap: {
            value: -1,
          },
          reflectivity: {
            value: 1,
          },
          ior: {
            value: 1.5,
          },
          refractionRatio: {
            value: 0.98,
          },
        },
        aomap: {
          aoMap: {
            value: null,
          },
          aoMapIntensity: {
            value: 1,
          },
          aoMapTransform: {
            value: new Gh(),
          },
        },
        lightmap: {
          lightMap: {
            value: null,
          },
          lightMapIntensity: {
            value: 1,
          },
          lightMapTransform: {
            value: new Gh(),
          },
        },
        bumpmap: {
          bumpMap: {
            value: null,
          },
          bumpMapTransform: {
            value: new Gh(),
          },
          bumpScale: {
            value: 1,
          },
        },
        normalmap: {
          normalMap: {
            value: null,
          },
          normalMapTransform: {
            value: new Gh(),
          },
          normalScale: {
            value: new Vh(1, 1),
          },
        },
        displacementmap: {
          displacementMap: {
            value: null,
          },
          displacementMapTransform: {
            value: new Gh(),
          },
          displacementScale: {
            value: 1,
          },
          displacementBias: {
            value: 0,
          },
        },
        emissivemap: {
          emissiveMap: {
            value: null,
          },
          emissiveMapTransform: {
            value: new Gh(),
          },
        },
        metalnessmap: {
          metalnessMap: {
            value: null,
          },
          metalnessMapTransform: {
            value: new Gh(),
          },
        },
        roughnessmap: {
          roughnessMap: {
            value: null,
          },
          roughnessMapTransform: {
            value: new Gh(),
          },
        },
        gradientmap: {
          gradientMap: {
            value: null,
          },
        },
        fog: {
          fogDensity: {
            value: 25e-5,
          },
          fogNear: {
            value: 1,
          },
          fogFar: {
            value: 2e3,
          },
          fogColor: {
            value: new Fp(16777215),
          },
        },
        lights: {
          ambientLightColor: {
            value: [],
          },
          lightProbe: {
            value: [],
          },
          directionalLights: {
            value: [],
            properties: {
              direction: {},
              color: {},
            },
          },
          directionalLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          directionalShadowMap: {
            value: [],
          },
          directionalShadowMatrix: {
            value: [],
          },
          spotLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              direction: {},
              distance: {},
              coneCos: {},
              penumbraCos: {},
              decay: {},
            },
          },
          spotLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
            },
          },
          spotLightMap: {
            value: [],
          },
          spotShadowMap: {
            value: [],
          },
          spotLightMatrix: {
            value: [],
          },
          pointLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              decay: {},
              distance: {},
            },
          },
          pointLightShadows: {
            value: [],
            properties: {
              shadowBias: {},
              shadowNormalBias: {},
              shadowRadius: {},
              shadowMapSize: {},
              shadowCameraNear: {},
              shadowCameraFar: {},
            },
          },
          pointShadowMap: {
            value: [],
          },
          pointShadowMatrix: {
            value: [],
          },
          hemisphereLights: {
            value: [],
            properties: {
              direction: {},
              skyColor: {},
              groundColor: {},
            },
          },
          rectAreaLights: {
            value: [],
            properties: {
              color: {},
              position: {},
              width: {},
              height: {},
            },
          },
          ltc_1: {
            value: null,
          },
          ltc_2: {
            value: null,
          },
        },
        points: {
          diffuse: {
            value: new Fp(16777215),
          },
          opacity: {
            value: 1,
          },
          size: {
            value: 1,
          },
          scale: {
            value: 1,
          },
          map: {
            value: null,
          },
          alphaMap: {
            value: null,
          },
          alphaMapTransform: {
            value: new Gh(),
          },
          alphaTest: {
            value: 0,
          },
          uvTransform: {
            value: new Gh(),
          },
        },
        sprite: {
          diffuse: {
            value: new Fp(16777215),
          },
          opacity: {
            value: 1,
          },
          center: {
            value: new Vh(0.5, 0.5),
          },
          rotation: {
            value: 0,
          },
          map: {
            value: null,
          },
          mapTransform: {
            value: new Gh(),
          },
          alphaMap: {
            value: null,
          },
          alphaMapTransform: {
            value: new Gh(),
          },
          alphaTest: {
            value: 0,
          },
        },
      },
      Hf = {
        basic: {
          uniforms: xf([
            Bf.common,
            Bf.specularmap,
            Bf.envmap,
            Bf.aomap,
            Bf.lightmap,
            Bf.fog,
          ]),
          vertexShader: zf.meshbasic_vert,
          fragmentShader: zf.meshbasic_frag,
        },
        lambert: {
          uniforms: xf([
            Bf.common,
            Bf.specularmap,
            Bf.envmap,
            Bf.aomap,
            Bf.lightmap,
            Bf.emissivemap,
            Bf.bumpmap,
            Bf.normalmap,
            Bf.displacementmap,
            Bf.fog,
            Bf.lights,
            {
              emissive: {
                value: new Fp(0),
              },
            },
          ]),
          vertexShader: zf.meshlambert_vert,
          fragmentShader: zf.meshlambert_frag,
        },
        phong: {
          uniforms: xf([
            Bf.common,
            Bf.specularmap,
            Bf.envmap,
            Bf.aomap,
            Bf.lightmap,
            Bf.emissivemap,
            Bf.bumpmap,
            Bf.normalmap,
            Bf.displacementmap,
            Bf.fog,
            Bf.lights,
            {
              emissive: {
                value: new Fp(0),
              },
              specular: {
                value: new Fp(1118481),
              },
              shininess: {
                value: 30,
              },
            },
          ]),
          vertexShader: zf.meshphong_vert,
          fragmentShader: zf.meshphong_frag,
        },
        standard: {
          uniforms: xf([
            Bf.common,
            Bf.envmap,
            Bf.aomap,
            Bf.lightmap,
            Bf.emissivemap,
            Bf.bumpmap,
            Bf.normalmap,
            Bf.displacementmap,
            Bf.roughnessmap,
            Bf.metalnessmap,
            Bf.fog,
            Bf.lights,
            {
              emissive: {
                value: new Fp(0),
              },
              roughness: {
                value: 1,
              },
              metalness: {
                value: 0,
              },
              envMapIntensity: {
                value: 1,
              },
            },
          ]),
          vertexShader: zf.meshphysical_vert,
          fragmentShader: zf.meshphysical_frag,
        },
        toon: {
          uniforms: xf([
            Bf.common,
            Bf.aomap,
            Bf.lightmap,
            Bf.emissivemap,
            Bf.bumpmap,
            Bf.normalmap,
            Bf.displacementmap,
            Bf.gradientmap,
            Bf.fog,
            Bf.lights,
            {
              emissive: {
                value: new Fp(0),
              },
            },
          ]),
          vertexShader: zf.meshtoon_vert,
          fragmentShader: zf.meshtoon_frag,
        },
        matcap: {
          uniforms: xf([
            Bf.common,
            Bf.bumpmap,
            Bf.normalmap,
            Bf.displacementmap,
            Bf.fog,
            {
              matcap: {
                value: null,
              },
            },
          ]),
          vertexShader: zf.meshmatcap_vert,
          fragmentShader: zf.meshmatcap_frag,
        },
        points: {
          uniforms: xf([Bf.points, Bf.fog]),
          vertexShader: zf.points_vert,
          fragmentShader: zf.points_frag,
        },
        dashed: {
          uniforms: xf([
            Bf.common,
            Bf.fog,
            {
              scale: {
                value: 1,
              },
              dashSize: {
                value: 1,
              },
              totalSize: {
                value: 2,
              },
            },
          ]),
          vertexShader: zf.linedashed_vert,
          fragmentShader: zf.linedashed_frag,
        },
        depth: {
          uniforms: xf([Bf.common, Bf.displacementmap]),
          vertexShader: zf.depth_vert,
          fragmentShader: zf.depth_frag,
        },
        normal: {
          uniforms: xf([
            Bf.common,
            Bf.bumpmap,
            Bf.normalmap,
            Bf.displacementmap,
            {
              opacity: {
                value: 1,
              },
            },
          ]),
          vertexShader: zf.meshnormal_vert,
          fragmentShader: zf.meshnormal_frag,
        },
        sprite: {
          uniforms: xf([Bf.sprite, Bf.fog]),
          vertexShader: zf.sprite_vert,
          fragmentShader: zf.sprite_frag,
        },
        background: {
          uniforms: {
            uvTransform: {
              value: new Gh(),
            },
            t2D: {
              value: null,
            },
            backgroundIntensity: {
              value: 1,
            },
          },
          vertexShader: zf.background_vert,
          fragmentShader: zf.background_frag,
        },
        backgroundCube: {
          uniforms: {
            envMap: {
              value: null,
            },
            flipEnvMap: {
              value: -1,
            },
            backgroundBlurriness: {
              value: 0,
            },
            backgroundIntensity: {
              value: 1,
            },
          },
          vertexShader: zf.backgroundCube_vert,
          fragmentShader: zf.backgroundCube_frag,
        },
        cube: {
          uniforms: {
            tCube: {
              value: null,
            },
            tFlip: {
              value: -1,
            },
            opacity: {
              value: 1,
            },
          },
          vertexShader: zf.cube_vert,
          fragmentShader: zf.cube_frag,
        },
        equirect: {
          uniforms: {
            tEquirect: {
              value: null,
            },
          },
          vertexShader: zf.equirect_vert,
          fragmentShader: zf.equirect_frag,
        },
        distanceRGBA: {
          uniforms: xf([
            Bf.common,
            Bf.displacementmap,
            {
              referencePosition: {
                value: new md(),
              },
              nearDistance: {
                value: 1,
              },
              farDistance: {
                value: 1e3,
              },
            },
          ]),
          vertexShader: zf.distanceRGBA_vert,
          fragmentShader: zf.distanceRGBA_frag,
        },
        shadow: {
          uniforms: xf([
            Bf.lights,
            Bf.fog,
            {
              color: {
                value: new Fp(0),
              },
              opacity: {
                value: 1,
              },
            },
          ]),
          vertexShader: zf.shadow_vert,
          fragmentShader: zf.shadow_frag,
        },
      };
    Hf.physical = {
      uniforms: xf([
        Hf.standard.uniforms,
        {
          clearcoat: {
            value: 0,
          },
          clearcoatMap: {
            value: null,
          },
          clearcoatMapTransform: {
            value: new Gh(),
          },
          clearcoatNormalMap: {
            value: null,
          },
          clearcoatNormalMapTransform: {
            value: new Gh(),
          },
          clearcoatNormalScale: {
            value: new Vh(1, 1),
          },
          clearcoatRoughness: {
            value: 0,
          },
          clearcoatRoughnessMap: {
            value: null,
          },
          clearcoatRoughnessMapTransform: {
            value: new Gh(),
          },
          iridescence: {
            value: 0,
          },
          iridescenceMap: {
            value: null,
          },
          iridescenceMapTransform: {
            value: new Gh(),
          },
          iridescenceIOR: {
            value: 1.3,
          },
          iridescenceThicknessMinimum: {
            value: 100,
          },
          iridescenceThicknessMaximum: {
            value: 400,
          },
          iridescenceThicknessMap: {
            value: null,
          },
          iridescenceThicknessMapTransform: {
            value: new Gh(),
          },
          sheen: {
            value: 0,
          },
          sheenColor: {
            value: new Fp(0),
          },
          sheenColorMap: {
            value: null,
          },
          sheenColorMapTransform: {
            value: new Gh(),
          },
          sheenRoughness: {
            value: 1,
          },
          sheenRoughnessMap: {
            value: null,
          },
          sheenRoughnessMapTransform: {
            value: new Gh(),
          },
          transmission: {
            value: 0,
          },
          transmissionMap: {
            value: null,
          },
          transmissionMapTransform: {
            value: new Gh(),
          },
          transmissionSamplerSize: {
            value: new Vh(),
          },
          transmissionSamplerMap: {
            value: null,
          },
          thickness: {
            value: 0,
          },
          thicknessMap: {
            value: null,
          },
          thicknessMapTransform: {
            value: new Gh(),
          },
          attenuationDistance: {
            value: 0,
          },
          attenuationColor: {
            value: new Fp(0),
          },
          specularColor: {
            value: new Fp(1, 1, 1),
          },
          specularColorMap: {
            value: null,
          },
          specularColorMapTransform: {
            value: new Gh(),
          },
          specularIntensity: {
            value: 1,
          },
          specularIntensityMap: {
            value: null,
          },
          specularIntensityMapTransform: {
            value: new Gh(),
          },
          anisotropyVector: {
            value: new Vh(),
          },
          anisotropyMap: {
            value: null,
          },
          anisotropyMapTransform: {
            value: new Gh(),
          },
        },
      ]),
      vertexShader: zf.meshphysical_vert,
      fragmentShader: zf.meshphysical_frag,
    };
    const Vf = {
      r: 0,
      b: 0,
      g: 0,
    };
    function Gf(t, e, n, i, r, s, o) {
      const a = new Fp(0);
      let l,
        c,
        u = !0 === s ? 0 : 1,
        h = null,
        d = 0,
        p = null;
      function f(e, n) {
        e.getRGB(Vf, bf(t)), i.buffers.color.setClear(Vf.r, Vf.g, Vf.b, n, o);
      }
      return {
        getClearColor: function () {
          return a;
        },
        setClearColor: function (t, e = 1) {
          a.set(t), (u = e), f(a, u);
        },
        getClearAlpha: function () {
          return u;
        },
        setClearAlpha: function (t) {
          (u = t), f(a, u);
        },
        render: function (s, m) {
          let g = !1,
            v = !0 === m.isScene ? m.background : null;
          if (v && v.isTexture) {
            v = (m.backgroundBlurriness > 0 ? n : e).get(v);
          }
          switch (
            (null === v ? f(a, u) : v && v.isColor && (f(v, 1), (g = !0)),
            t.xr.getEnvironmentBlendMode())
          ) {
            case "opaque":
              g = !0;
              break;
            case "additive":
              i.buffers.color.setClear(0, 0, 0, 1, o), (g = !0);
              break;
            case "alpha-blend":
              i.buffers.color.setClear(0, 0, 0, 0, o), (g = !0);
          }
          (t.autoClear || g) &&
            t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
            v && (v.isCubeTexture || 306 === v.mapping)
              ? (void 0 === c &&
                  ((c = new gf(
                    new _f(1, 1, 1),
                    new Ef({
                      name: "BackgroundCubeMaterial",
                      uniforms: yf(Hf.backgroundCube.uniforms),
                      vertexShader: Hf.backgroundCube.vertexShader,
                      fragmentShader: Hf.backgroundCube.fragmentShader,
                      side: 1,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  c.geometry.deleteAttribute("normal"),
                  c.geometry.deleteAttribute("uv"),
                  (c.onBeforeRender = function (t, e, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(c.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  r.update(c)),
                (c.material.uniforms.envMap.value = v),
                (c.material.uniforms.flipEnvMap.value =
                  v.isCubeTexture && !1 === v.isRenderTargetTexture ? -1 : 1),
                (c.material.uniforms.backgroundBlurriness.value =
                  m.backgroundBlurriness),
                (c.material.uniforms.backgroundIntensity.value =
                  m.backgroundIntensity),
                (c.material.toneMapped = "srgb" !== v.colorSpace),
                (h === v && d === v.version && p === t.toneMapping) ||
                  ((c.material.needsUpdate = !0),
                  (h = v),
                  (d = v.version),
                  (p = t.toneMapping)),
                c.layers.enableAll(),
                s.unshift(c, c.geometry, c.material, 0, 0, null))
              : v &&
                v.isTexture &&
                (void 0 === l &&
                  ((l = new gf(
                    new kf(2, 2),
                    new Ef({
                      name: "BackgroundMaterial",
                      uniforms: yf(Hf.background.uniforms),
                      vertexShader: Hf.background.vertexShader,
                      fragmentShader: Hf.background.fragmentShader,
                      side: 0,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  l.geometry.deleteAttribute("normal"),
                  Object.defineProperty(l.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  r.update(l)),
                (l.material.uniforms.t2D.value = v),
                (l.material.uniforms.backgroundIntensity.value =
                  m.backgroundIntensity),
                (l.material.toneMapped = "srgb" !== v.colorSpace),
                !0 === v.matrixAutoUpdate && v.updateMatrix(),
                l.material.uniforms.uvTransform.value.copy(v.matrix),
                (h === v && d === v.version && p === t.toneMapping) ||
                  ((l.material.needsUpdate = !0),
                  (h = v),
                  (d = v.version),
                  (p = t.toneMapping)),
                l.layers.enableAll(),
                s.unshift(l, l.geometry, l.material, 0, 0, null));
        },
      };
    }
    function Wf(t, e, n, i) {
      const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
        s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
        o = i.isWebGL2 || null !== s,
        a = {},
        l = p(null);
      let c = l,
        u = !1;
      function h(e) {
        return i.isWebGL2 ? t.bindVertexArray(e) : s.bindVertexArrayOES(e);
      }
      function d(e) {
        return i.isWebGL2 ? t.deleteVertexArray(e) : s.deleteVertexArrayOES(e);
      }
      function p(t) {
        const e = [],
          n = [],
          i = [];
        for (let t = 0; t < r; t++) (e[t] = 0), (n[t] = 0), (i[t] = 0);
        return {
          geometry: null,
          program: null,
          wireframe: !1,
          newAttributes: e,
          enabledAttributes: n,
          attributeDivisors: i,
          object: t,
          attributes: {},
          index: null,
        };
      }
      function f() {
        const t = c.newAttributes;
        for (let e = 0, n = t.length; e < n; e++) t[e] = 0;
      }
      function m(t) {
        g(t, 0);
      }
      function g(n, r) {
        const s = c.newAttributes,
          o = c.enabledAttributes,
          a = c.attributeDivisors;
        if (
          ((s[n] = 1),
          0 === o[n] && (t.enableVertexAttribArray(n), (o[n] = 1)),
          a[n] !== r)
        ) {
          (i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
            i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
          ](n, r),
            (a[n] = r);
        }
      }
      function v() {
        const e = c.newAttributes,
          n = c.enabledAttributes;
        for (let i = 0, r = n.length; i < r; i++)
          n[i] !== e[i] && (t.disableVertexAttribArray(i), (n[i] = 0));
      }
      function _(e, n, i, r, s, o, a) {
        !0 === a
          ? t.vertexAttribIPointer(e, n, i, s, o)
          : t.vertexAttribPointer(e, n, i, r, s, o);
      }
      function y() {
        x(), (u = !0), c !== l && ((c = l), h(c.object));
      }
      function x() {
        (l.geometry = null), (l.program = null), (l.wireframe = !1);
      }
      return {
        setup: function (r, l, d, y, x) {
          let b = !1;
          if (o) {
            const e = (function (e, n, r) {
              const o = !0 === r.wireframe;
              let l = a[e.id];
              void 0 === l && ((l = {}), (a[e.id] = l));
              let c = l[n.id];
              void 0 === c && ((c = {}), (l[n.id] = c));
              let u = c[o];
              void 0 === u &&
                ((u = p(
                  i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES()
                )),
                (c[o] = u));
              return u;
            })(y, d, l);
            c !== e && ((c = e), h(c.object)),
              (b = (function (t, e, n, i) {
                const r = c.attributes,
                  s = e.attributes;
                let o = 0;
                const a = n.getAttributes();
                for (const e in a) {
                  if (a[e].location >= 0) {
                    const n = r[e];
                    let i = s[e];
                    if (
                      (void 0 === i &&
                        ("instanceMatrix" === e &&
                          t.instanceMatrix &&
                          (i = t.instanceMatrix),
                        "instanceColor" === e &&
                          t.instanceColor &&
                          (i = t.instanceColor)),
                      void 0 === n)
                    )
                      return !0;
                    if (n.attribute !== i) return !0;
                    if (i && n.data !== i.data) return !0;
                    o++;
                  }
                }
                return c.attributesNum !== o || c.index !== i;
              })(r, y, d, x)),
              b &&
                (function (t, e, n, i) {
                  const r = {},
                    s = e.attributes;
                  let o = 0;
                  const a = n.getAttributes();
                  for (const e in a) {
                    if (a[e].location >= 0) {
                      let n = s[e];
                      void 0 === n &&
                        ("instanceMatrix" === e &&
                          t.instanceMatrix &&
                          (n = t.instanceMatrix),
                        "instanceColor" === e &&
                          t.instanceColor &&
                          (n = t.instanceColor));
                      const i = {};
                      (i.attribute = n),
                        n && n.data && (i.data = n.data),
                        (r[e] = i),
                        o++;
                    }
                  }
                  (c.attributes = r), (c.attributesNum = o), (c.index = i);
                })(r, y, d, x);
          } else {
            const t = !0 === l.wireframe;
            (c.geometry === y.id && c.program === d.id && c.wireframe === t) ||
              ((c.geometry = y.id),
              (c.program = d.id),
              (c.wireframe = t),
              (b = !0));
          }
          null !== x && n.update(x, t.ELEMENT_ARRAY_BUFFER),
            (b || u) &&
              ((u = !1),
              (function (r, s, o, a) {
                if (
                  !1 === i.isWebGL2 &&
                  (r.isInstancedMesh || a.isInstancedBufferGeometry) &&
                  null === e.get("ANGLE_instanced_arrays")
                )
                  return;
                f();
                const l = a.attributes,
                  c = o.getAttributes(),
                  u = s.defaultAttributeValues;
                for (const e in c) {
                  const s = c[e];
                  if (s.location >= 0) {
                    let o = l[e];
                    if (
                      (void 0 === o &&
                        ("instanceMatrix" === e &&
                          r.instanceMatrix &&
                          (o = r.instanceMatrix),
                        "instanceColor" === e &&
                          r.instanceColor &&
                          (o = r.instanceColor)),
                      void 0 !== o)
                    ) {
                      const e = o.normalized,
                        l = o.itemSize,
                        c = n.get(o);
                      if (void 0 === c) continue;
                      const u = c.buffer,
                        h = c.type,
                        d = c.bytesPerElement,
                        p =
                          !0 === i.isWebGL2 &&
                          (h === t.INT ||
                            h === t.UNSIGNED_INT ||
                            1013 === o.gpuType);
                      if (o.isInterleavedBufferAttribute) {
                        const n = o.data,
                          i = n.stride,
                          c = o.offset;
                        if (n.isInstancedInterleavedBuffer) {
                          for (let t = 0; t < s.locationSize; t++)
                            g(s.location + t, n.meshPerAttribute);
                          !0 !== r.isInstancedMesh &&
                            void 0 === a._maxInstanceCount &&
                            (a._maxInstanceCount =
                              n.meshPerAttribute * n.count);
                        } else
                          for (let t = 0; t < s.locationSize; t++)
                            m(s.location + t);
                        t.bindBuffer(t.ARRAY_BUFFER, u);
                        for (let t = 0; t < s.locationSize; t++)
                          _(
                            s.location + t,
                            l / s.locationSize,
                            h,
                            e,
                            i * d,
                            (c + (l / s.locationSize) * t) * d,
                            p
                          );
                      } else {
                        if (o.isInstancedBufferAttribute) {
                          for (let t = 0; t < s.locationSize; t++)
                            g(s.location + t, o.meshPerAttribute);
                          !0 !== r.isInstancedMesh &&
                            void 0 === a._maxInstanceCount &&
                            (a._maxInstanceCount =
                              o.meshPerAttribute * o.count);
                        } else
                          for (let t = 0; t < s.locationSize; t++)
                            m(s.location + t);
                        t.bindBuffer(t.ARRAY_BUFFER, u);
                        for (let t = 0; t < s.locationSize; t++)
                          _(
                            s.location + t,
                            l / s.locationSize,
                            h,
                            e,
                            l * d,
                            (l / s.locationSize) * t * d,
                            p
                          );
                      }
                    } else if (void 0 !== u) {
                      const n = u[e];
                      if (void 0 !== n)
                        switch (n.length) {
                          case 2:
                            t.vertexAttrib2fv(s.location, n);
                            break;
                          case 3:
                            t.vertexAttrib3fv(s.location, n);
                            break;
                          case 4:
                            t.vertexAttrib4fv(s.location, n);
                            break;
                          default:
                            t.vertexAttrib1fv(s.location, n);
                        }
                    }
                  }
                }
                v();
              })(r, l, d, y),
              null !== x &&
                t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(x).buffer));
        },
        reset: y,
        resetDefaultState: x,
        dispose: function () {
          y();
          for (const t in a) {
            const e = a[t];
            for (const t in e) {
              const n = e[t];
              for (const t in n) d(n[t].object), delete n[t];
              delete e[t];
            }
            delete a[t];
          }
        },
        releaseStatesOfGeometry: function (t) {
          if (void 0 === a[t.id]) return;
          const e = a[t.id];
          for (const t in e) {
            const n = e[t];
            for (const t in n) d(n[t].object), delete n[t];
            delete e[t];
          }
          delete a[t.id];
        },
        releaseStatesOfProgram: function (t) {
          for (const e in a) {
            const n = a[e];
            if (void 0 === n[t.id]) continue;
            const i = n[t.id];
            for (const t in i) d(i[t].object), delete i[t];
            delete n[t.id];
          }
        },
        initAttributes: f,
        enableAttribute: m,
        disableUnusedAttributes: v,
      };
    }
    function jf(t, e, n, i) {
      const r = i.isWebGL2;
      let s;
      (this.setMode = function (t) {
        s = t;
      }),
        (this.render = function (e, i) {
          t.drawArrays(s, e, i), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, o, a) {
          if (0 === a) return;
          let l, c;
          if (r) (l = t), (c = "drawArraysInstanced");
          else if (
            ((l = e.get("ANGLE_instanced_arrays")),
            (c = "drawArraysInstancedANGLE"),
            null === l)
          )
            return void console.error(
              "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          l[c](s, i, o, a), n.update(o, s, a);
        });
    }
    function Xf(t, e, n) {
      let i;
      function r(e) {
        if ("highp" === e) {
          if (
            t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
              .precision > 0 &&
            t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
              .precision > 0
          )
            return "highp";
          e = "mediump";
        }
        return "mediump" === e &&
          t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
            .precision > 0 &&
          t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
            .precision > 0
          ? "mediump"
          : "lowp";
      }
      const s =
        "undefined" != typeof WebGL2RenderingContext &&
        "WebGL2RenderingContext" === t.constructor.name;
      let o = void 0 !== n.precision ? n.precision : "highp";
      const a = r(o);
      a !== o &&
        (console.warn(
          "THREE.WebGLRenderer:",
          o,
          "not supported, using",
          a,
          "instead."
        ),
        (o = a));
      const l = s || e.has("WEBGL_draw_buffers"),
        c = !0 === n.logarithmicDepthBuffer,
        u = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
        h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        d = t.getParameter(t.MAX_TEXTURE_SIZE),
        p = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
        f = t.getParameter(t.MAX_VERTEX_ATTRIBS),
        m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
        g = t.getParameter(t.MAX_VARYING_VECTORS),
        v = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
        _ = h > 0,
        y = s || e.has("OES_texture_float");
      return {
        isWebGL2: s,
        drawBuffers: l,
        getMaxAnisotropy: function () {
          if (void 0 !== i) return i;
          if (!0 === e.has("EXT_texture_filter_anisotropic")) {
            const n = e.get("EXT_texture_filter_anisotropic");
            i = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
          } else i = 0;
          return i;
        },
        getMaxPrecision: r,
        precision: o,
        logarithmicDepthBuffer: c,
        maxTextures: u,
        maxVertexTextures: h,
        maxTextureSize: d,
        maxCubemapSize: p,
        maxAttributes: f,
        maxVertexUniforms: m,
        maxVaryings: g,
        maxFragmentUniforms: v,
        vertexTextures: _,
        floatFragmentTextures: y,
        floatVertexTextures: _ && y,
        maxSamples: s ? t.getParameter(t.MAX_SAMPLES) : 0,
      };
    }
    function qf(t) {
      const e = this;
      let n = null,
        i = 0,
        r = !1,
        s = !1;
      const o = new Lf(),
        a = new Gh(),
        l = {
          value: null,
          needsUpdate: !1,
        };
      function c(t, n, i, r) {
        const s = null !== t ? t.length : 0;
        let c = null;
        if (0 !== s) {
          if (((c = l.value), !0 !== r || null === c)) {
            const e = i + 4 * s,
              r = n.matrixWorldInverse;
            a.getNormalMatrix(r),
              (null === c || c.length < e) && (c = new Float32Array(e));
            for (let e = 0, n = i; e !== s; ++e, n += 4)
              o.copy(t[e]).applyMatrix4(r, a),
                o.normal.toArray(c, n),
                (c[n + 3] = o.constant);
          }
          (l.value = c), (l.needsUpdate = !0);
        }
        return (e.numPlanes = s), (e.numIntersection = 0), c;
      }
      (this.uniform = l),
        (this.numPlanes = 0),
        (this.numIntersection = 0),
        (this.init = function (t, e) {
          const n = 0 !== t.length || e || 0 !== i || r;
          return (r = e), (i = t.length), n;
        }),
        (this.beginShadows = function () {
          (s = !0), c(null);
        }),
        (this.endShadows = function () {
          s = !1;
        }),
        (this.setGlobalState = function (t, e) {
          n = c(t, e, 0);
        }),
        (this.setState = function (o, a, u) {
          const h = o.clippingPlanes,
            d = o.clipIntersection,
            p = o.clipShadows,
            f = t.get(o);
          if (!r || null === h || 0 === h.length || (s && !p))
            s
              ? c(null)
              : (function () {
                  l.value !== n && ((l.value = n), (l.needsUpdate = i > 0));
                  (e.numPlanes = i), (e.numIntersection = 0);
                })();
          else {
            const t = s ? 0 : i,
              e = 4 * t;
            let r = f.clippingState || null;
            (l.value = r), (r = c(h, a, e, u));
            for (let t = 0; t !== e; ++t) r[t] = n[t];
            (f.clippingState = r),
              (this.numIntersection = d ? this.numPlanes : 0),
              (this.numPlanes += t);
          }
        });
    }
    function Yf(t) {
      let e = new WeakMap();
      function n(t, e) {
        return (
          303 === e ? (t.mapping = 301) : 304 === e && (t.mapping = 302), t
        );
      }
      function i(t) {
        const n = t.target;
        n.removeEventListener("dispose", i);
        const r = e.get(n);
        void 0 !== r && (e.delete(n), r.dispose());
      }
      return {
        get: function (r) {
          if (r && r.isTexture && !1 === r.isRenderTargetTexture) {
            const s = r.mapping;
            if (303 === s || 304 === s) {
              if (e.has(r)) {
                return n(e.get(r).texture, r.mapping);
              }
              {
                const s = r.image;
                if (s && s.height > 0) {
                  const o = new Af(s.height / 2);
                  return (
                    o.fromEquirectangularTexture(t, r),
                    e.set(r, o),
                    r.addEventListener("dispose", i),
                    n(o.texture, r.mapping)
                  );
                }
                return null;
              }
            }
          }
          return r;
        },
        dispose: function () {
          e = new WeakMap();
        },
      };
    }
    class Kf extends Mf {
      constructor(t = -1, e = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
        super(),
          (this.isOrthographicCamera = !0),
          (this.type = "OrthographicCamera"),
          (this.zoom = 1),
          (this.view = null),
          (this.left = t),
          (this.right = e),
          (this.top = n),
          (this.bottom = i),
          (this.near = r),
          (this.far = s),
          this.updateProjectionMatrix();
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          (this.left = t.left),
          (this.right = t.right),
          (this.top = t.top),
          (this.bottom = t.bottom),
          (this.near = t.near),
          (this.far = t.far),
          (this.zoom = t.zoom),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          this
        );
      }
      setViewOffset(t, e, n, i, r, s) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = n),
          (this.view.offsetY = i),
          (this.view.width = r),
          (this.view.height = s),
          this.updateProjectionMatrix();
      }
      clearViewOffset() {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      }
      updateProjectionMatrix() {
        const t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          n = (this.right + this.left) / 2,
          i = (this.top + this.bottom) / 2;
        let r = n - t,
          s = n + t,
          o = i + e,
          a = i - e;
        if (null !== this.view && this.view.enabled) {
          const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
            e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          (r += t * this.view.offsetX),
            (s = r + t * this.view.width),
            (o -= e * this.view.offsetY),
            (a = o - e * this.view.height);
        }
        this.projectionMatrix.makeOrthographic(
          r,
          s,
          o,
          a,
          this.near,
          this.far,
          this.coordinateSystem
        ),
          this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          (e.object.zoom = this.zoom),
          (e.object.left = this.left),
          (e.object.right = this.right),
          (e.object.top = this.top),
          (e.object.bottom = this.bottom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          e
        );
      }
    }
    const Zf = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
      Jf = new Kf(),
      $f = new Fp();
    let Qf = null;
    const tm = (1 + Math.sqrt(5)) / 2,
      em = 1 / tm,
      nm = [
        new md(1, 1, 1),
        new md(-1, 1, 1),
        new md(1, 1, -1),
        new md(-1, 1, -1),
        new md(0, tm, em),
        new md(0, tm, -em),
        new md(em, 0, tm),
        new md(-em, 0, tm),
        new md(tm, em, 0),
        new md(-tm, em, 0),
      ];
    class im {
      constructor(t) {
        (this._renderer = t),
          (this._pingPongRenderTarget = null),
          (this._lodMax = 0),
          (this._cubeSize = 0),
          (this._lodPlanes = []),
          (this._sizeLods = []),
          (this._sigmas = []),
          (this._blurMaterial = null),
          (this._cubemapMaterial = null),
          (this._equirectMaterial = null),
          this._compileMaterial(this._blurMaterial);
      }
      fromScene(t, e = 0, n = 0.1, i = 100) {
        (Qf = this._renderer.getRenderTarget()), this._setSize(256);
        const r = this._allocateTargets();
        return (
          (r.depthBuffer = !0),
          this._sceneToCubeUV(t, n, i, r),
          e > 0 && this._blur(r, 0, 0, e),
          this._applyPMREM(r),
          this._cleanup(r),
          r
        );
      }
      fromEquirectangular(t, e = null) {
        return this._fromTexture(t, e);
      }
      fromCubemap(t, e = null) {
        return this._fromTexture(t, e);
      }
      compileCubemapShader() {
        null === this._cubemapMaterial &&
          ((this._cubemapMaterial = am()),
          this._compileMaterial(this._cubemapMaterial));
      }
      compileEquirectangularShader() {
        null === this._equirectMaterial &&
          ((this._equirectMaterial = om()),
          this._compileMaterial(this._equirectMaterial));
      }
      dispose() {
        this._dispose(),
          null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
          null !== this._equirectMaterial && this._equirectMaterial.dispose();
      }
      _setSize(t) {
        (this._lodMax = Math.floor(Math.log2(t))),
          (this._cubeSize = Math.pow(2, this._lodMax));
      }
      _dispose() {
        null !== this._blurMaterial && this._blurMaterial.dispose(),
          null !== this._pingPongRenderTarget &&
            this._pingPongRenderTarget.dispose();
        for (let t = 0; t < this._lodPlanes.length; t++)
          this._lodPlanes[t].dispose();
      }
      _cleanup(t) {
        this._renderer.setRenderTarget(Qf),
          (t.scissorTest = !1),
          sm(t, 0, 0, t.width, t.height);
      }
      _fromTexture(t, e) {
        301 === t.mapping || 302 === t.mapping
          ? this._setSize(
              0 === t.image.length
                ? 16
                : t.image[0].width || t.image[0].image.width
            )
          : this._setSize(t.image.width / 4),
          (Qf = this._renderer.getRenderTarget());
        const n = e || this._allocateTargets();
        return (
          this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
        );
      }
      _allocateTargets() {
        const t = 3 * Math.max(this._cubeSize, 112),
          e = 4 * this._cubeSize,
          n = {
            magFilter: 1006,
            minFilter: 1006,
            generateMipmaps: !1,
            type: 1016,
            format: 1023,
            colorSpace: "srgb-linear",
            depthBuffer: !1,
          },
          i = rm(t, e, n);
        if (
          null === this._pingPongRenderTarget ||
          this._pingPongRenderTarget.width !== t ||
          this._pingPongRenderTarget.height !== e
        ) {
          null !== this._pingPongRenderTarget && this._dispose(),
            (this._pingPongRenderTarget = rm(t, e, n));
          const { _lodMax: i } = this;
          ({
            sizeLods: this._sizeLods,
            lodPlanes: this._lodPlanes,
            sigmas: this._sigmas,
          } = (function (t) {
            const e = [],
              n = [],
              i = [];
            let r = t;
            const s = t - 4 + 1 + Zf.length;
            for (let o = 0; o < s; o++) {
              const s = Math.pow(2, r);
              n.push(s);
              let a = 1 / s;
              o > t - 4 ? (a = Zf[o - t + 4 - 1]) : 0 === o && (a = 0),
                i.push(a);
              const l = 1 / (s - 2),
                c = -l,
                u = 1 + l,
                h = [c, c, u, c, u, u, c, c, u, u, c, u],
                d = 6,
                p = 6,
                f = 3,
                m = 2,
                g = 1,
                v = new Float32Array(f * p * d),
                _ = new Float32Array(m * p * d),
                y = new Float32Array(g * p * d);
              for (let t = 0; t < d; t++) {
                const e = ((t % 3) * 2) / 3 - 1,
                  n = t > 2 ? 0 : -1,
                  i = [
                    e,
                    n,
                    0,
                    e + 2 / 3,
                    n,
                    0,
                    e + 2 / 3,
                    n + 1,
                    0,
                    e,
                    n,
                    0,
                    e + 2 / 3,
                    n + 1,
                    0,
                    e,
                    n + 1,
                    0,
                  ];
                v.set(i, f * p * t), _.set(h, m * p * t);
                const r = [t, t, t, t, t, t];
                y.set(r, g * p * t);
              }
              const x = new Jp();
              x.setAttribute("position", new Bp(v, f)),
                x.setAttribute("uv", new Bp(_, m)),
                x.setAttribute("faceIndex", new Bp(y, g)),
                e.push(x),
                r > 4 && r--;
            }
            return {
              lodPlanes: e,
              sizeLods: n,
              sigmas: i,
            };
          })(i)),
            (this._blurMaterial = (function (t, e, n) {
              const i = new Float32Array(20),
                r = new md(0, 1, 0);
              return new Ef({
                name: "SphericalGaussianBlur",
                defines: {
                  n: 20,
                  CUBEUV_TEXEL_WIDTH: 1 / e,
                  CUBEUV_TEXEL_HEIGHT: 1 / n,
                  CUBEUV_MAX_MIP: t + ".0",
                },
                uniforms: {
                  envMap: {
                    value: null,
                  },
                  samples: {
                    value: 1,
                  },
                  weights: {
                    value: i,
                  },
                  latitudinal: {
                    value: !1,
                  },
                  dTheta: {
                    value: 0,
                  },
                  mipInt: {
                    value: 0,
                  },
                  poleAxis: {
                    value: r,
                  },
                },
                vertexShader: lm(),
                fragmentShader:
                  "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                blending: 0,
                depthTest: !1,
                depthWrite: !1,
              });
            })(i, t, e));
        }
        return i;
      }
      _compileMaterial(t) {
        const e = new gf(this._lodPlanes[0], t);
        this._renderer.compile(e, Jf);
      }
      _sceneToCubeUV(t, e, n, i) {
        const r = new Tf(90, 1, e, n),
          s = [1, -1, 1, 1, 1, 1],
          o = [1, 1, 1, -1, -1, -1],
          a = this._renderer,
          l = a.autoClear,
          c = a.toneMapping;
        a.getClearColor($f), (a.toneMapping = 0), (a.autoClear = !1);
        const u = new Np({
            name: "PMREM.Background",
            side: 1,
            depthWrite: !1,
            depthTest: !1,
          }),
          h = new gf(new _f(), u);
        let d = !1;
        const p = t.background;
        p
          ? p.isColor && (u.color.copy(p), (t.background = null), (d = !0))
          : (u.color.copy($f), (d = !0));
        for (let e = 0; e < 6; e++) {
          const n = e % 3;
          0 === n
            ? (r.up.set(0, s[e], 0), r.lookAt(o[e], 0, 0))
            : 1 === n
            ? (r.up.set(0, 0, s[e]), r.lookAt(0, o[e], 0))
            : (r.up.set(0, s[e], 0), r.lookAt(0, 0, o[e]));
          const l = this._cubeSize;
          sm(i, n * l, e > 2 ? l : 0, l, l),
            a.setRenderTarget(i),
            d && a.render(h, r),
            a.render(t, r);
        }
        h.geometry.dispose(),
          h.material.dispose(),
          (a.toneMapping = c),
          (a.autoClear = l),
          (t.background = p);
      }
      _textureToCubeUV(t, e) {
        const n = this._renderer,
          i = 301 === t.mapping || 302 === t.mapping;
        i
          ? (null === this._cubemapMaterial && (this._cubemapMaterial = am()),
            (this._cubemapMaterial.uniforms.flipEnvMap.value =
              !1 === t.isRenderTargetTexture ? -1 : 1))
          : null === this._equirectMaterial && (this._equirectMaterial = om());
        const r = i ? this._cubemapMaterial : this._equirectMaterial,
          s = new gf(this._lodPlanes[0], r);
        r.uniforms.envMap.value = t;
        const o = this._cubeSize;
        sm(e, 0, 0, 3 * o, 2 * o), n.setRenderTarget(e), n.render(s, Jf);
      }
      _applyPMREM(t) {
        const e = this._renderer,
          n = e.autoClear;
        e.autoClear = !1;
        for (let e = 1; e < this._lodPlanes.length; e++) {
          const n = Math.sqrt(
              this._sigmas[e] * this._sigmas[e] -
                this._sigmas[e - 1] * this._sigmas[e - 1]
            ),
            i = nm[(e - 1) % nm.length];
          this._blur(t, e - 1, e, n, i);
        }
        e.autoClear = n;
      }
      _blur(t, e, n, i, r) {
        const s = this._pingPongRenderTarget;
        this._halfBlur(t, s, e, n, i, "latitudinal", r),
          this._halfBlur(s, t, n, n, i, "longitudinal", r);
      }
      _halfBlur(t, e, n, i, r, s, o) {
        const a = this._renderer,
          l = this._blurMaterial;
        "latitudinal" !== s &&
          "longitudinal" !== s &&
          console.error(
            "blur direction must be either latitudinal or longitudinal!"
          );
        const c = new gf(this._lodPlanes[i], l),
          u = l.uniforms,
          h = this._sizeLods[n] - 1,
          d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
          p = r / d,
          f = isFinite(r) ? 1 + Math.floor(3 * p) : 20;
        f > 20 &&
          console.warn(
            `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
          );
        const m = [];
        let g = 0;
        for (let t = 0; t < 20; ++t) {
          const e = t / p,
            n = Math.exp((-e * e) / 2);
          m.push(n), 0 === t ? (g += n) : t < f && (g += 2 * n);
        }
        for (let t = 0; t < m.length; t++) m[t] = m[t] / g;
        (u.envMap.value = t.texture),
          (u.samples.value = f),
          (u.weights.value = m),
          (u.latitudinal.value = "latitudinal" === s),
          o && (u.poleAxis.value = o);
        const { _lodMax: v } = this;
        (u.dTheta.value = d), (u.mipInt.value = v - n);
        const _ = this._sizeLods[i];
        sm(
          e,
          3 * _ * (i > v - 4 ? i - v + 4 : 0),
          4 * (this._cubeSize - _),
          3 * _,
          2 * _
        ),
          a.setRenderTarget(e),
          a.render(c, Jf);
      }
    }
    function rm(t, e, n) {
      const i = new hd(t, e, n);
      return (
        (i.texture.mapping = 306),
        (i.texture.name = "PMREM.cubeUv"),
        (i.scissorTest = !0),
        i
      );
    }
    function sm(t, e, n, i, r) {
      t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
    }
    function om() {
      return new Ef({
        name: "EquirectangularToCubeUV",
        uniforms: {
          envMap: {
            value: null,
          },
        },
        vertexShader: lm(),
        fragmentShader:
          "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function am() {
      return new Ef({
        name: "CubemapToCubeUV",
        uniforms: {
          envMap: {
            value: null,
          },
          flipEnvMap: {
            value: -1,
          },
        },
        vertexShader: lm(),
        fragmentShader:
          "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      });
    }
    function lm() {
      return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
    }
    function cm(t) {
      let e = new WeakMap(),
        n = null;
      function i(t) {
        const n = t.target;
        n.removeEventListener("dispose", i);
        const r = e.get(n);
        void 0 !== r && (e.delete(n), r.dispose());
      }
      return {
        get: function (r) {
          if (r && r.isTexture) {
            const s = r.mapping,
              o = 303 === s || 304 === s,
              a = 301 === s || 302 === s;
            if (o || a) {
              if (r.isRenderTargetTexture && !0 === r.needsPMREMUpdate) {
                r.needsPMREMUpdate = !1;
                let i = e.get(r);
                return (
                  null === n && (n = new im(t)),
                  (i = o ? n.fromEquirectangular(r, i) : n.fromCubemap(r, i)),
                  e.set(r, i),
                  i.texture
                );
              }
              if (e.has(r)) return e.get(r).texture;
              {
                const s = r.image;
                if (
                  (o && s && s.height > 0) ||
                  (a &&
                    s &&
                    (function (t) {
                      let e = 0;
                      for (let n = 0; n < 6; n++) void 0 !== t[n] && e++;
                      return 6 === e;
                    })(s))
                ) {
                  null === n && (n = new im(t));
                  const s = o ? n.fromEquirectangular(r) : n.fromCubemap(r);
                  return (
                    e.set(r, s), r.addEventListener("dispose", i), s.texture
                  );
                }
                return null;
              }
            }
          }
          return r;
        },
        dispose: function () {
          (e = new WeakMap()), null !== n && (n.dispose(), (n = null));
        },
      };
    }
    function um(t) {
      const e = {};
      function n(n) {
        if (void 0 !== e[n]) return e[n];
        let i;
        switch (n) {
          case "WEBGL_depth_texture":
            i =
              t.getExtension("WEBGL_depth_texture") ||
              t.getExtension("MOZ_WEBGL_depth_texture") ||
              t.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            i =
              t.getExtension("EXT_texture_filter_anisotropic") ||
              t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            i =
              t.getExtension("WEBGL_compressed_texture_s3tc") ||
              t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            i =
              t.getExtension("WEBGL_compressed_texture_pvrtc") ||
              t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            i = t.getExtension(n);
        }
        return (e[n] = i), i;
      }
      return {
        has: function (t) {
          return null !== n(t);
        },
        init: function (t) {
          t.isWebGL2
            ? n("EXT_color_buffer_float")
            : (n("WEBGL_depth_texture"),
              n("OES_texture_float"),
              n("OES_texture_half_float"),
              n("OES_texture_half_float_linear"),
              n("OES_standard_derivatives"),
              n("OES_element_index_uint"),
              n("OES_vertex_array_object"),
              n("ANGLE_instanced_arrays")),
            n("OES_texture_float_linear"),
            n("EXT_color_buffer_half_float"),
            n("WEBGL_multisampled_render_to_texture");
        },
        get: function (t) {
          const e = n(t);
          return (
            null === e &&
              console.warn(
                "THREE.WebGLRenderer: " + t + " extension not supported."
              ),
            e
          );
        },
      };
    }
    function hm(t, e, n, i) {
      const r = {},
        s = new WeakMap();
      function o(t) {
        const a = t.target;
        null !== a.index && e.remove(a.index);
        for (const t in a.attributes) e.remove(a.attributes[t]);
        for (const t in a.morphAttributes) {
          const n = a.morphAttributes[t];
          for (let t = 0, i = n.length; t < i; t++) e.remove(n[t]);
        }
        a.removeEventListener("dispose", o), delete r[a.id];
        const l = s.get(a);
        l && (e.remove(l), s.delete(a)),
          i.releaseStatesOfGeometry(a),
          !0 === a.isInstancedBufferGeometry && delete a._maxInstanceCount,
          n.memory.geometries--;
      }
      function a(t) {
        const n = [],
          i = t.index,
          r = t.attributes.position;
        let o = 0;
        if (null !== i) {
          const t = i.array;
          o = i.version;
          for (let e = 0, i = t.length; e < i; e += 3) {
            const i = t[e + 0],
              r = t[e + 1],
              s = t[e + 2];
            n.push(i, r, r, s, s, i);
          }
        } else {
          if (void 0 === r) return;
          {
            const t = r.array;
            o = r.version;
            for (let e = 0, i = t.length / 3 - 1; e < i; e += 3) {
              const t = e + 0,
                i = e + 1,
                r = e + 2;
              n.push(t, i, i, r, r, t);
            }
          }
        }
        const a = new (jh(n) ? Vp : Hp)(n, 1);
        a.version = o;
        const l = s.get(t);
        l && e.remove(l), s.set(t, a);
      }
      return {
        get: function (t, e) {
          return (
            !0 === r[e.id] ||
              (e.addEventListener("dispose", o),
              (r[e.id] = !0),
              n.memory.geometries++),
            e
          );
        },
        update: function (n) {
          const i = n.attributes;
          for (const n in i) e.update(i[n], t.ARRAY_BUFFER);
          const r = n.morphAttributes;
          for (const n in r) {
            const i = r[n];
            for (let n = 0, r = i.length; n < r; n++)
              e.update(i[n], t.ARRAY_BUFFER);
          }
        },
        getWireframeAttribute: function (t) {
          const e = s.get(t);
          if (e) {
            const n = t.index;
            null !== n && e.version < n.version && a(t);
          } else a(t);
          return s.get(t);
        },
      };
    }
    function dm(t, e, n, i) {
      const r = i.isWebGL2;
      let s, o, a;
      (this.setMode = function (t) {
        s = t;
      }),
        (this.setIndex = function (t) {
          (o = t.type), (a = t.bytesPerElement);
        }),
        (this.render = function (e, i) {
          t.drawElements(s, i, o, e * a), n.update(i, s, 1);
        }),
        (this.renderInstances = function (i, l, c) {
          if (0 === c) return;
          let u, h;
          if (r) (u = t), (h = "drawElementsInstanced");
          else if (
            ((u = e.get("ANGLE_instanced_arrays")),
            (h = "drawElementsInstancedANGLE"),
            null === u)
          )
            return void console.error(
              "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
            );
          u[h](s, l, o, i * a, c), n.update(l, s, c);
        });
    }
    function pm(t) {
      const e = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
      };
      return {
        memory: {
          geometries: 0,
          textures: 0,
        },
        render: e,
        programs: null,
        autoReset: !0,
        reset: function () {
          (e.calls = 0), (e.triangles = 0), (e.points = 0), (e.lines = 0);
        },
        update: function (n, i, r) {
          switch ((e.calls++, i)) {
            case t.TRIANGLES:
              e.triangles += r * (n / 3);
              break;
            case t.LINES:
              e.lines += r * (n / 2);
              break;
            case t.LINE_STRIP:
              e.lines += r * (n - 1);
              break;
            case t.LINE_LOOP:
              e.lines += r * n;
              break;
            case t.POINTS:
              e.points += r * n;
              break;
            default:
              console.error("THREE.WebGLInfo: Unknown draw mode:", i);
          }
        },
      };
    }
    function fm(t, e) {
      return t[0] - e[0];
    }
    function mm(t, e) {
      return Math.abs(e[1]) - Math.abs(t[1]);
    }
    function gm(t, e, n) {
      const i = {},
        r = new Float32Array(8),
        s = new WeakMap(),
        o = new cd(),
        a = [];
      for (let t = 0; t < 8; t++) a[t] = [t, 0];
      return {
        update: function (l, c, u) {
          const h = l.morphTargetInfluences;
          if (!0 === e.isWebGL2) {
            const i =
                c.morphAttributes.position ||
                c.morphAttributes.normal ||
                c.morphAttributes.color,
              r = void 0 !== i ? i.length : 0;
            let a = s.get(c);
            if (void 0 === a || a.count !== r) {
              void 0 !== a && a.texture.dispose();
              const t = void 0 !== c.morphAttributes.position,
                n = void 0 !== c.morphAttributes.normal,
                i = void 0 !== c.morphAttributes.color,
                l = c.morphAttributes.position || [],
                u = c.morphAttributes.normal || [],
                h = c.morphAttributes.color || [];
              let d = 0;
              !0 === t && (d = 1), !0 === n && (d = 2), !0 === i && (d = 3);
              let p = c.attributes.position.count * d,
                f = 1;
              p > e.maxTextureSize &&
                ((f = Math.ceil(p / e.maxTextureSize)), (p = e.maxTextureSize));
              const m = new Float32Array(p * f * 4 * r),
                g = new dd(m, p, f, r);
              (g.type = 1015), (g.needsUpdate = !0);
              const v = 4 * d;
              for (let e = 0; e < r; e++) {
                const r = l[e],
                  s = u[e],
                  a = h[e],
                  c = p * f * 4 * e;
                for (let e = 0; e < r.count; e++) {
                  const l = e * v;
                  !0 === t &&
                    (o.fromBufferAttribute(r, e),
                    (m[c + l + 0] = o.x),
                    (m[c + l + 1] = o.y),
                    (m[c + l + 2] = o.z),
                    (m[c + l + 3] = 0)),
                    !0 === n &&
                      (o.fromBufferAttribute(s, e),
                      (m[c + l + 4] = o.x),
                      (m[c + l + 5] = o.y),
                      (m[c + l + 6] = o.z),
                      (m[c + l + 7] = 0)),
                    !0 === i &&
                      (o.fromBufferAttribute(a, e),
                      (m[c + l + 8] = o.x),
                      (m[c + l + 9] = o.y),
                      (m[c + l + 10] = o.z),
                      (m[c + l + 11] = 4 === a.itemSize ? o.w : 1));
                }
              }
              (a = {
                count: r,
                texture: g,
                size: new Vh(p, f),
              }),
                s.set(c, a),
                c.addEventListener("dispose", function t() {
                  g.dispose(), s.delete(c), c.removeEventListener("dispose", t);
                });
            }
            let l = 0;
            for (let t = 0; t < h.length; t++) l += h[t];
            const d = c.morphTargetsRelative ? 1 : 1 - l;
            u.getUniforms().setValue(t, "morphTargetBaseInfluence", d),
              u.getUniforms().setValue(t, "morphTargetInfluences", h),
              u.getUniforms().setValue(t, "morphTargetsTexture", a.texture, n),
              u.getUniforms().setValue(t, "morphTargetsTextureSize", a.size);
          } else {
            const e = void 0 === h ? 0 : h.length;
            let n = i[c.id];
            if (void 0 === n || n.length !== e) {
              n = [];
              for (let t = 0; t < e; t++) n[t] = [t, 0];
              i[c.id] = n;
            }
            for (let t = 0; t < e; t++) {
              const e = n[t];
              (e[0] = t), (e[1] = h[t]);
            }
            n.sort(mm);
            for (let t = 0; t < 8; t++)
              t < e && n[t][1]
                ? ((a[t][0] = n[t][0]), (a[t][1] = n[t][1]))
                : ((a[t][0] = Number.MAX_SAFE_INTEGER), (a[t][1] = 0));
            a.sort(fm);
            const s = c.morphAttributes.position,
              o = c.morphAttributes.normal;
            let l = 0;
            for (let t = 0; t < 8; t++) {
              const e = a[t],
                n = e[0],
                i = e[1];
              n !== Number.MAX_SAFE_INTEGER && i
                ? (s &&
                    c.getAttribute("morphTarget" + t) !== s[n] &&
                    c.setAttribute("morphTarget" + t, s[n]),
                  o &&
                    c.getAttribute("morphNormal" + t) !== o[n] &&
                    c.setAttribute("morphNormal" + t, o[n]),
                  (r[t] = i),
                  (l += i))
                : (s &&
                    !0 === c.hasAttribute("morphTarget" + t) &&
                    c.deleteAttribute("morphTarget" + t),
                  o &&
                    !0 === c.hasAttribute("morphNormal" + t) &&
                    c.deleteAttribute("morphNormal" + t),
                  (r[t] = 0));
            }
            const d = c.morphTargetsRelative ? 1 : 1 - l;
            u.getUniforms().setValue(t, "morphTargetBaseInfluence", d),
              u.getUniforms().setValue(t, "morphTargetInfluences", r);
          }
        },
      };
    }
    function vm(t, e, n, i) {
      let r = new WeakMap();
      function s(t) {
        const e = t.target;
        e.removeEventListener("dispose", s),
          n.remove(e.instanceMatrix),
          null !== e.instanceColor && n.remove(e.instanceColor);
      }
      return {
        update: function (o) {
          const a = i.render.frame,
            l = o.geometry,
            c = e.get(o, l);
          if (
            (r.get(c) !== a && (e.update(c), r.set(c, a)),
            o.isInstancedMesh &&
              (!1 === o.hasEventListener("dispose", s) &&
                o.addEventListener("dispose", s),
              r.get(o) !== a &&
                (n.update(o.instanceMatrix, t.ARRAY_BUFFER),
                null !== o.instanceColor &&
                  n.update(o.instanceColor, t.ARRAY_BUFFER),
                r.set(o, a))),
            o.isSkinnedMesh)
          ) {
            const t = o.skeleton;
            r.get(t) !== a && (t.update(), r.set(t, a));
          }
          return c;
        },
        dispose: function () {
          r = new WeakMap();
        },
      };
    }
    const _m = new ld(),
      ym = new dd(),
      xm = new pd(),
      bm = new Df(),
      Sm = [],
      Em = [],
      Mm = new Float32Array(16),
      Tm = new Float32Array(9),
      wm = new Float32Array(4);
    function Dm(t, e, n) {
      const i = t[0];
      if (i <= 0 || i > 0) return t;
      const r = e * n;
      let s = Sm[r];
      if ((void 0 === s && ((s = new Float32Array(r)), (Sm[r] = s)), 0 !== e)) {
        i.toArray(s, 0);
        for (let i = 1, r = 0; i !== e; ++i) (r += n), t[i].toArray(s, r);
      }
      return s;
    }
    function Am(t, e) {
      if (t.length !== e.length) return !1;
      for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
      return !0;
    }
    function Cm(t, e) {
      for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
    }
    function Pm(t, e) {
      let n = Em[e];
      void 0 === n && ((n = new Int32Array(e)), (Em[e] = n));
      for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
      return n;
    }
    function Rm(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
    }
    function Lm(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y) ||
          (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
      else {
        if (Am(n, e)) return;
        t.uniform2fv(this.addr, e), Cm(n, e);
      }
    }
    function Om(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
          (t.uniform3f(this.addr, e.x, e.y, e.z),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z));
      else if (void 0 !== e.r)
        (n[0] === e.r && n[1] === e.g && n[2] === e.b) ||
          (t.uniform3f(this.addr, e.r, e.g, e.b),
          (n[0] = e.r),
          (n[1] = e.g),
          (n[2] = e.b));
      else {
        if (Am(n, e)) return;
        t.uniform3fv(this.addr, e), Cm(n, e);
      }
    }
    function Im(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
          (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z),
          (n[3] = e.w));
      else {
        if (Am(n, e)) return;
        t.uniform4fv(this.addr, e), Cm(n, e);
      }
    }
    function Fm(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (Am(n, e)) return;
        t.uniformMatrix2fv(this.addr, !1, e), Cm(n, e);
      } else {
        if (Am(n, i)) return;
        wm.set(i), t.uniformMatrix2fv(this.addr, !1, wm), Cm(n, i);
      }
    }
    function Um(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (Am(n, e)) return;
        t.uniformMatrix3fv(this.addr, !1, e), Cm(n, e);
      } else {
        if (Am(n, i)) return;
        Tm.set(i), t.uniformMatrix3fv(this.addr, !1, Tm), Cm(n, i);
      }
    }
    function Nm(t, e) {
      const n = this.cache,
        i = e.elements;
      if (void 0 === i) {
        if (Am(n, e)) return;
        t.uniformMatrix4fv(this.addr, !1, e), Cm(n, e);
      } else {
        if (Am(n, i)) return;
        Mm.set(i), t.uniformMatrix4fv(this.addr, !1, Mm), Cm(n, i);
      }
    }
    function km(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
    }
    function zm(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y) ||
          (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
      else {
        if (Am(n, e)) return;
        t.uniform2iv(this.addr, e), Cm(n, e);
      }
    }
    function Bm(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
          (t.uniform3i(this.addr, e.x, e.y, e.z),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z));
      else {
        if (Am(n, e)) return;
        t.uniform3iv(this.addr, e), Cm(n, e);
      }
    }
    function Hm(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
          (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z),
          (n[3] = e.w));
      else {
        if (Am(n, e)) return;
        t.uniform4iv(this.addr, e), Cm(n, e);
      }
    }
    function Vm(t, e) {
      const n = this.cache;
      n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
    }
    function Gm(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y) ||
          (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
      else {
        if (Am(n, e)) return;
        t.uniform2uiv(this.addr, e), Cm(n, e);
      }
    }
    function Wm(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z) ||
          (t.uniform3ui(this.addr, e.x, e.y, e.z),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z));
      else {
        if (Am(n, e)) return;
        t.uniform3uiv(this.addr, e), Cm(n, e);
      }
    }
    function jm(t, e) {
      const n = this.cache;
      if (void 0 !== e.x)
        (n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w) ||
          (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
          (n[0] = e.x),
          (n[1] = e.y),
          (n[2] = e.z),
          (n[3] = e.w));
      else {
        if (Am(n, e)) return;
        t.uniform4uiv(this.addr, e), Cm(n, e);
      }
    }
    function Xm(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture2D(e || _m, r);
    }
    function qm(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture3D(e || xm, r);
    }
    function Ym(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTextureCube(e || bm, r);
    }
    function Km(t, e, n) {
      const i = this.cache,
        r = n.allocateTextureUnit();
      i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
        n.setTexture2DArray(e || ym, r);
    }
    function Zm(t, e) {
      t.uniform1fv(this.addr, e);
    }
    function Jm(t, e) {
      const n = Dm(e, this.size, 2);
      t.uniform2fv(this.addr, n);
    }
    function $m(t, e) {
      const n = Dm(e, this.size, 3);
      t.uniform3fv(this.addr, n);
    }
    function Qm(t, e) {
      const n = Dm(e, this.size, 4);
      t.uniform4fv(this.addr, n);
    }
    function tg(t, e) {
      const n = Dm(e, this.size, 4);
      t.uniformMatrix2fv(this.addr, !1, n);
    }
    function eg(t, e) {
      const n = Dm(e, this.size, 9);
      t.uniformMatrix3fv(this.addr, !1, n);
    }
    function ng(t, e) {
      const n = Dm(e, this.size, 16);
      t.uniformMatrix4fv(this.addr, !1, n);
    }
    function ig(t, e) {
      t.uniform1iv(this.addr, e);
    }
    function rg(t, e) {
      t.uniform2iv(this.addr, e);
    }
    function sg(t, e) {
      t.uniform3iv(this.addr, e);
    }
    function og(t, e) {
      t.uniform4iv(this.addr, e);
    }
    function ag(t, e) {
      t.uniform1uiv(this.addr, e);
    }
    function lg(t, e) {
      t.uniform2uiv(this.addr, e);
    }
    function cg(t, e) {
      t.uniform3uiv(this.addr, e);
    }
    function ug(t, e) {
      t.uniform4uiv(this.addr, e);
    }
    function hg(t, e, n) {
      const i = this.cache,
        r = e.length,
        s = Pm(n, r);
      Am(i, s) || (t.uniform1iv(this.addr, s), Cm(i, s));
      for (let t = 0; t !== r; ++t) n.setTexture2D(e[t] || _m, s[t]);
    }
    function dg(t, e, n) {
      const i = this.cache,
        r = e.length,
        s = Pm(n, r);
      Am(i, s) || (t.uniform1iv(this.addr, s), Cm(i, s));
      for (let t = 0; t !== r; ++t) n.setTexture3D(e[t] || xm, s[t]);
    }
    function pg(t, e, n) {
      const i = this.cache,
        r = e.length,
        s = Pm(n, r);
      Am(i, s) || (t.uniform1iv(this.addr, s), Cm(i, s));
      for (let t = 0; t !== r; ++t) n.setTextureCube(e[t] || bm, s[t]);
    }
    function fg(t, e, n) {
      const i = this.cache,
        r = e.length,
        s = Pm(n, r);
      Am(i, s) || (t.uniform1iv(this.addr, s), Cm(i, s));
      for (let t = 0; t !== r; ++t) n.setTexture2DArray(e[t] || ym, s[t]);
    }
    class mg {
      constructor(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return Rm;
              case 35664:
                return Lm;
              case 35665:
                return Om;
              case 35666:
                return Im;
              case 35674:
                return Fm;
              case 35675:
                return Um;
              case 35676:
                return Nm;
              case 5124:
              case 35670:
                return km;
              case 35667:
              case 35671:
                return zm;
              case 35668:
              case 35672:
                return Bm;
              case 35669:
              case 35673:
                return Hm;
              case 5125:
                return Vm;
              case 36294:
                return Gm;
              case 36295:
                return Wm;
              case 36296:
                return jm;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return Xm;
              case 35679:
              case 36299:
              case 36307:
                return qm;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return Ym;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return Km;
            }
          })(e.type));
      }
    }
    class gg {
      constructor(t, e, n) {
        (this.id = t),
          (this.addr = n),
          (this.cache = []),
          (this.size = e.size),
          (this.setValue = (function (t) {
            switch (t) {
              case 5126:
                return Zm;
              case 35664:
                return Jm;
              case 35665:
                return $m;
              case 35666:
                return Qm;
              case 35674:
                return tg;
              case 35675:
                return eg;
              case 35676:
                return ng;
              case 5124:
              case 35670:
                return ig;
              case 35667:
              case 35671:
                return rg;
              case 35668:
              case 35672:
                return sg;
              case 35669:
              case 35673:
                return og;
              case 5125:
                return ag;
              case 36294:
                return lg;
              case 36295:
                return cg;
              case 36296:
                return ug;
              case 35678:
              case 36198:
              case 36298:
              case 36306:
              case 35682:
                return hg;
              case 35679:
              case 36299:
              case 36307:
                return dg;
              case 35680:
              case 36300:
              case 36308:
              case 36293:
                return pg;
              case 36289:
              case 36303:
              case 36311:
              case 36292:
                return fg;
            }
          })(e.type));
      }
    }
    class vg {
      constructor(t) {
        (this.id = t), (this.seq = []), (this.map = {});
      }
      setValue(t, e, n) {
        const i = this.seq;
        for (let r = 0, s = i.length; r !== s; ++r) {
          const s = i[r];
          s.setValue(t, e[s.id], n);
        }
      }
    }
    const _g = /(\w+)(\])?(\[|\.)?/g;
    function yg(t, e) {
      t.seq.push(e), (t.map[e.id] = e);
    }
    function xg(t, e, n) {
      const i = t.name,
        r = i.length;
      for (_g.lastIndex = 0; ; ) {
        const s = _g.exec(i),
          o = _g.lastIndex;
        let a = s[1];
        const l = "]" === s[2],
          c = s[3];
        if ((l && (a |= 0), void 0 === c || ("[" === c && o + 2 === r))) {
          yg(n, void 0 === c ? new mg(a, t, e) : new gg(a, t, e));
          break;
        }
        {
          let t = n.map[a];
          void 0 === t && ((t = new vg(a)), yg(n, t)), (n = t);
        }
      }
    }
    class bg {
      constructor(t, e) {
        (this.seq = []), (this.map = {});
        const n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
          const n = t.getActiveUniform(e, i);
          xg(n, t.getUniformLocation(e, n.name), this);
        }
      }
      setValue(t, e, n, i) {
        const r = this.map[e];
        void 0 !== r && r.setValue(t, n, i);
      }
      setOptional(t, e, n) {
        const i = e[n];
        void 0 !== i && this.setValue(t, n, i);
      }
      static upload(t, e, n, i) {
        for (let r = 0, s = e.length; r !== s; ++r) {
          const s = e[r],
            o = n[s.id];
          !1 !== o.needsUpdate && s.setValue(t, o.value, i);
        }
      }
      static seqWithValue(t, e) {
        const n = [];
        for (let i = 0, r = t.length; i !== r; ++i) {
          const r = t[i];
          r.id in e && n.push(r);
        }
        return n;
      }
    }
    function Sg(t, e, n) {
      const i = t.createShader(e);
      return t.shaderSource(i, n), t.compileShader(i), i;
    }
    let Eg = 0;
    function Mg(t, e, n) {
      const i = t.getShaderParameter(e, t.COMPILE_STATUS),
        r = t.getShaderInfoLog(e).trim();
      if (i && "" === r) return "";
      const s = /ERROR: 0:(\d+)/.exec(r);
      if (s) {
        const i = parseInt(s[1]);
        return (
          n.toUpperCase() +
          "\n\n" +
          r +
          "\n\n" +
          (function (t, e) {
            const n = t.split("\n"),
              i = [],
              r = Math.max(e - 6, 0),
              s = Math.min(e + 6, n.length);
            for (let t = r; t < s; t++) {
              const r = t + 1;
              i.push(`${r === e ? ">" : " "} ${r}: ${n[t]}`);
            }
            return i.join("\n");
          })(t.getShaderSource(e), i)
        );
      }
      return r;
    }
    function Tg(t, e) {
      const n = (function (t) {
        switch (t) {
          case "srgb-linear":
            return ["Linear", "( value )"];
          case "srgb":
            return ["sRGB", "( value )"];
          default:
            return (
              console.warn("THREE.WebGLProgram: Unsupported color space:", t),
              ["Linear", "( value )"]
            );
        }
      })(e);
      return (
        "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
      );
    }
    function wg(t, e) {
      let n;
      switch (e) {
        case 1:
          n = "Linear";
          break;
        case 2:
          n = "Reinhard";
          break;
        case 3:
          n = "OptimizedCineon";
          break;
        case 4:
          n = "ACESFilmic";
          break;
        case 5:
          n = "Custom";
          break;
        default:
          console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
            (n = "Linear");
      }
      return (
        "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
      );
    }
    function Dg(t) {
      return "" !== t;
    }
    function Ag(t, e) {
      const n =
        e.numSpotLightShadows +
        e.numSpotLightMaps -
        e.numSpotLightShadowsWithMaps;
      return t
        .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
        .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
        .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
        .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
        .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
        .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
        .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
        .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
        .replace(
          /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
          e.numSpotLightShadowsWithMaps
        )
        .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
        .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
    }
    function Cg(t, e) {
      return t
        .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
        .replace(
          /UNION_CLIPPING_PLANES/g,
          e.numClippingPlanes - e.numClipIntersection
        );
    }
    const Pg = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function Rg(t) {
      return t.replace(Pg, Og);
    }
    const Lg = new Map([
      ["encodings_fragment", "colorspace_fragment"],
      ["encodings_pars_fragment", "colorspace_pars_fragment"],
      ["output_fragment", "opaque_fragment"],
    ]);
    function Og(t, e) {
      let n = zf[e];
      if (void 0 === n) {
        const t = Lg.get(e);
        if (void 0 === t)
          throw new Error("Can not resolve #include <" + e + ">");
        (n = zf[t]),
          console.warn(
            'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
            e,
            t
          );
      }
      return Rg(n);
    }
    const Ig =
      /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
    function Fg(t) {
      return t.replace(Ig, Ug);
    }
    function Ug(t, e, n, i) {
      let r = "";
      for (let t = parseInt(e); t < parseInt(n); t++)
        r += i
          .replace(/\[\s*i\s*\]/g, "[ " + t + " ]")
          .replace(/UNROLLED_LOOP_INDEX/g, t);
      return r;
    }
    function Ng(t) {
      let e =
        "precision " +
        t.precision +
        " float;\nprecision " +
        t.precision +
        " int;";
      return (
        "highp" === t.precision
          ? (e += "\n#define HIGH_PRECISION")
          : "mediump" === t.precision
          ? (e += "\n#define MEDIUM_PRECISION")
          : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"),
        e
      );
    }
    function kg(t, e, n, i) {
      const r = t.getContext(),
        s = n.defines;
      let o = n.vertexShader,
        a = n.fragmentShader;
      const l = (function (t) {
          let e = "SHADOWMAP_TYPE_BASIC";
          return (
            1 === t.shadowMapType
              ? (e = "SHADOWMAP_TYPE_PCF")
              : 2 === t.shadowMapType
              ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
              : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"),
            e
          );
        })(n),
        c = (function (t) {
          let e = "ENVMAP_TYPE_CUBE";
          if (t.envMap)
            switch (t.envMapMode) {
              case 301:
              case 302:
                e = "ENVMAP_TYPE_CUBE";
                break;
              case 306:
                e = "ENVMAP_TYPE_CUBE_UV";
            }
          return e;
        })(n),
        u = (function (t) {
          let e = "ENVMAP_MODE_REFLECTION";
          if (t.envMap)
            switch (t.envMapMode) {
              case 302:
                e = "ENVMAP_MODE_REFRACTION";
            }
          return e;
        })(n),
        h = (function (t) {
          let e = "ENVMAP_BLENDING_NONE";
          if (t.envMap)
            switch (t.combine) {
              case 0:
                e = "ENVMAP_BLENDING_MULTIPLY";
                break;
              case 1:
                e = "ENVMAP_BLENDING_MIX";
                break;
              case 2:
                e = "ENVMAP_BLENDING_ADD";
            }
          return e;
        })(n),
        d = (function (t) {
          const e = t.envMapCubeUVHeight;
          if (null === e) return null;
          const n = Math.log2(e) - 2,
            i = 1 / e;
          return {
            texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
            texelHeight: i,
            maxMip: n,
          };
        })(n),
        p = n.isWebGL2
          ? ""
          : (function (t) {
              return [
                t.extensionDerivatives ||
                t.envMapCubeUVHeight ||
                t.bumpMap ||
                t.normalMapTangentSpace ||
                t.clearcoatNormalMap ||
                t.flatShading ||
                "physical" === t.shaderID
                  ? "#extension GL_OES_standard_derivatives : enable"
                  : "",
                (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
                t.rendererExtensionFragDepth
                  ? "#extension GL_EXT_frag_depth : enable"
                  : "",
                t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
                  ? "#extension GL_EXT_draw_buffers : require"
                  : "",
                (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
                t.rendererExtensionShaderTextureLod
                  ? "#extension GL_EXT_shader_texture_lod : enable"
                  : "",
              ]
                .filter(Dg)
                .join("\n");
            })(n),
        f = (function (t) {
          const e = [];
          for (const n in t) {
            const i = t[n];
            !1 !== i && e.push("#define " + n + " " + i);
          }
          return e.join("\n");
        })(s),
        m = r.createProgram();
      let g,
        v,
        _ = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
      n.isRawShaderMaterial
        ? ((g = [
            "#define SHADER_TYPE " + n.shaderType,
            "#define SHADER_NAME " + n.shaderName,
            f,
          ]
            .filter(Dg)
            .join("\n")),
          g.length > 0 && (g += "\n"),
          (v = [
            p,
            "#define SHADER_TYPE " + n.shaderType,
            "#define SHADER_NAME " + n.shaderName,
            f,
          ]
            .filter(Dg)
            .join("\n")),
          v.length > 0 && (v += "\n"))
        : ((g = [
            Ng(n),
            "#define SHADER_TYPE " + n.shaderType,
            "#define SHADER_NAME " + n.shaderName,
            f,
            n.instancing ? "#define USE_INSTANCING" : "",
            n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + u : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            n.iridescenceThicknessMap
              ? "#define USE_IRIDESCENCE_THICKNESSMAP"
              : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.alphaHash ? "#define USE_ALPHAHASH" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            n.mapUv ? "#define MAP_UV " + n.mapUv : "",
            n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
            n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
            n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
            n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
            n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
            n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
            n.displacementMapUv
              ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
              : "",
            n.metalnessMapUv
              ? "#define METALNESSMAP_UV " + n.metalnessMapUv
              : "",
            n.roughnessMapUv
              ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv
              : "",
            n.anisotropyMapUv
              ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
              : "",
            n.clearcoatMapUv
              ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv
              : "",
            n.clearcoatNormalMapUv
              ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
              : "",
            n.clearcoatRoughnessMapUv
              ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
              : "",
            n.iridescenceMapUv
              ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
              : "",
            n.iridescenceThicknessMapUv
              ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                n.iridescenceThicknessMapUv
              : "",
            n.sheenColorMapUv
              ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
              : "",
            n.sheenRoughnessMapUv
              ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
              : "",
            n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
            n.specularColorMapUv
              ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
              : "",
            n.specularIntensityMapUv
              ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
              : "",
            n.transmissionMapUv
              ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
              : "",
            n.thicknessMapUv
              ? "#define THICKNESSMAP_UV " + n.thicknessMapUv
              : "",
            n.vertexTangents && !1 === n.flatShading
              ? "#define USE_TANGENT"
              : "",
            n.vertexColors ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUv1s ? "#define USE_UV1" : "",
            n.vertexUv2s ? "#define USE_UV2" : "",
            n.vertexUv3s ? "#define USE_UV3" : "",
            n.pointsUvs ? "#define USE_POINTS_UV" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.skinning ? "#define USE_SKINNING" : "",
            n.morphTargets ? "#define USE_MORPHTARGETS" : "",
            n.morphNormals && !1 === n.flatShading
              ? "#define USE_MORPHNORMALS"
              : "",
            n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
            n.morphTargetsCount > 0 && n.isWebGL2
              ? "#define MORPHTARGETS_TEXTURE"
              : "",
            n.morphTargetsCount > 0 && n.isWebGL2
              ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
              : "",
            n.morphTargetsCount > 0 && n.isWebGL2
              ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
              : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
            n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            "uniform mat4 modelMatrix;",
            "uniform mat4 modelViewMatrix;",
            "uniform mat4 projectionMatrix;",
            "uniform mat4 viewMatrix;",
            "uniform mat3 normalMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            "#ifdef USE_INSTANCING",
            "\tattribute mat4 instanceMatrix;",
            "#endif",
            "#ifdef USE_INSTANCING_COLOR",
            "\tattribute vec3 instanceColor;",
            "#endif",
            "attribute vec3 position;",
            "attribute vec3 normal;",
            "attribute vec2 uv;",
            "#ifdef USE_UV1",
            "\tattribute vec2 uv1;",
            "#endif",
            "#ifdef USE_UV2",
            "\tattribute vec2 uv2;",
            "#endif",
            "#ifdef USE_UV3",
            "\tattribute vec2 uv3;",
            "#endif",
            "#ifdef USE_TANGENT",
            "\tattribute vec4 tangent;",
            "#endif",
            "#if defined( USE_COLOR_ALPHA )",
            "\tattribute vec4 color;",
            "#elif defined( USE_COLOR )",
            "\tattribute vec3 color;",
            "#endif",
            "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
            "\tattribute vec3 morphTarget0;",
            "\tattribute vec3 morphTarget1;",
            "\tattribute vec3 morphTarget2;",
            "\tattribute vec3 morphTarget3;",
            "\t#ifdef USE_MORPHNORMALS",
            "\t\tattribute vec3 morphNormal0;",
            "\t\tattribute vec3 morphNormal1;",
            "\t\tattribute vec3 morphNormal2;",
            "\t\tattribute vec3 morphNormal3;",
            "\t#else",
            "\t\tattribute vec3 morphTarget4;",
            "\t\tattribute vec3 morphTarget5;",
            "\t\tattribute vec3 morphTarget6;",
            "\t\tattribute vec3 morphTarget7;",
            "\t#endif",
            "#endif",
            "#ifdef USE_SKINNING",
            "\tattribute vec4 skinIndex;",
            "\tattribute vec4 skinWeight;",
            "#endif",
            "\n",
          ]
            .filter(Dg)
            .join("\n")),
          (v = [
            p,
            Ng(n),
            "#define SHADER_TYPE " + n.shaderType,
            "#define SHADER_NAME " + n.shaderName,
            f,
            n.useFog && n.fog ? "#define USE_FOG" : "",
            n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
            n.map ? "#define USE_MAP" : "",
            n.matcap ? "#define USE_MATCAP" : "",
            n.envMap ? "#define USE_ENVMAP" : "",
            n.envMap ? "#define " + c : "",
            n.envMap ? "#define " + u : "",
            n.envMap ? "#define " + h : "",
            d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "",
            d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "",
            d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "",
            n.lightMap ? "#define USE_LIGHTMAP" : "",
            n.aoMap ? "#define USE_AOMAP" : "",
            n.bumpMap ? "#define USE_BUMPMAP" : "",
            n.normalMap ? "#define USE_NORMALMAP" : "",
            n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
            n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
            n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
            n.anisotropy ? "#define USE_ANISOTROPY" : "",
            n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
            n.clearcoat ? "#define USE_CLEARCOAT" : "",
            n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
            n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
            n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
            n.iridescence ? "#define USE_IRIDESCENCE" : "",
            n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
            n.iridescenceThicknessMap
              ? "#define USE_IRIDESCENCE_THICKNESSMAP"
              : "",
            n.specularMap ? "#define USE_SPECULARMAP" : "",
            n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
            n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
            n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
            n.metalnessMap ? "#define USE_METALNESSMAP" : "",
            n.alphaMap ? "#define USE_ALPHAMAP" : "",
            n.alphaTest ? "#define USE_ALPHATEST" : "",
            n.alphaHash ? "#define USE_ALPHAHASH" : "",
            n.sheen ? "#define USE_SHEEN" : "",
            n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
            n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
            n.transmission ? "#define USE_TRANSMISSION" : "",
            n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
            n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
            n.vertexTangents && !1 === n.flatShading
              ? "#define USE_TANGENT"
              : "",
            n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
            n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
            n.vertexUv1s ? "#define USE_UV1" : "",
            n.vertexUv2s ? "#define USE_UV2" : "",
            n.vertexUv3s ? "#define USE_UV3" : "",
            n.pointsUvs ? "#define USE_POINTS_UV" : "",
            n.gradientMap ? "#define USE_GRADIENTMAP" : "",
            n.flatShading ? "#define FLAT_SHADED" : "",
            n.doubleSided ? "#define DOUBLE_SIDED" : "",
            n.flipSided ? "#define FLIP_SIDED" : "",
            n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
            n.shadowMapEnabled ? "#define " + l : "",
            n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
            n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
            n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
            n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
            "uniform mat4 viewMatrix;",
            "uniform vec3 cameraPosition;",
            "uniform bool isOrthographic;",
            0 !== n.toneMapping ? "#define TONE_MAPPING" : "",
            0 !== n.toneMapping ? zf.tonemapping_pars_fragment : "",
            0 !== n.toneMapping ? wg("toneMapping", n.toneMapping) : "",
            n.dithering ? "#define DITHERING" : "",
            n.opaque ? "#define OPAQUE" : "",
            zf.colorspace_pars_fragment,
            Tg("linearToOutputTexel", n.outputColorSpace),
            n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
            "\n",
          ]
            .filter(Dg)
            .join("\n"))),
        (o = Rg(o)),
        (o = Ag(o, n)),
        (o = Cg(o, n)),
        (a = Rg(a)),
        (a = Ag(a, n)),
        (a = Cg(a, n)),
        (o = Fg(o)),
        (a = Fg(a)),
        n.isWebGL2 &&
          !0 !== n.isRawShaderMaterial &&
          ((_ = "#version 300 es\n"),
          (g =
            [
              "precision mediump sampler2DArray;",
              "#define attribute in",
              "#define varying out",
              "#define texture2D texture",
            ].join("\n") +
            "\n" +
            g),
          (v =
            [
              "#define varying in",
              "300 es" === n.glslVersion
                ? ""
                : "layout(location = 0) out highp vec4 pc_fragColor;",
              "300 es" === n.glslVersion
                ? ""
                : "#define gl_FragColor pc_fragColor",
              "#define gl_FragDepthEXT gl_FragDepth",
              "#define texture2D texture",
              "#define textureCube texture",
              "#define texture2DProj textureProj",
              "#define texture2DLodEXT textureLod",
              "#define texture2DProjLodEXT textureProjLod",
              "#define textureCubeLodEXT textureLod",
              "#define texture2DGradEXT textureGrad",
              "#define texture2DProjGradEXT textureProjGrad",
              "#define textureCubeGradEXT textureGrad",
            ].join("\n") +
            "\n" +
            v));
      const y = _ + g + o,
        x = _ + v + a,
        b = Sg(r, r.VERTEX_SHADER, y),
        S = Sg(r, r.FRAGMENT_SHADER, x);
      if (
        (r.attachShader(m, b),
        r.attachShader(m, S),
        void 0 !== n.index0AttributeName
          ? r.bindAttribLocation(m, 0, n.index0AttributeName)
          : !0 === n.morphTargets && r.bindAttribLocation(m, 0, "position"),
        r.linkProgram(m),
        t.debug.checkShaderErrors)
      ) {
        const e = r.getProgramInfoLog(m).trim(),
          n = r.getShaderInfoLog(b).trim(),
          i = r.getShaderInfoLog(S).trim();
        let s = !0,
          o = !0;
        if (!1 === r.getProgramParameter(m, r.LINK_STATUS))
          if (((s = !1), "function" == typeof t.debug.onShaderError))
            t.debug.onShaderError(r, m, b, S);
          else {
            const t = Mg(r, b, "vertex"),
              n = Mg(r, S, "fragment");
            console.error(
              "THREE.WebGLProgram: Shader Error " +
                r.getError() +
                " - VALIDATE_STATUS " +
                r.getProgramParameter(m, r.VALIDATE_STATUS) +
                "\n\nProgram Info Log: " +
                e +
                "\n" +
                t +
                "\n" +
                n
            );
          }
        else
          "" !== e
            ? console.warn("THREE.WebGLProgram: Program Info Log:", e)
            : ("" !== n && "" !== i) || (o = !1);
        o &&
          (this.diagnostics = {
            runnable: s,
            programLog: e,
            vertexShader: {
              log: n,
              prefix: g,
            },
            fragmentShader: {
              log: i,
              prefix: v,
            },
          });
      }
      let E, M;
      return (
        r.deleteShader(b),
        r.deleteShader(S),
        (this.getUniforms = function () {
          return void 0 === E && (E = new bg(r, m)), E;
        }),
        (this.getAttributes = function () {
          return (
            void 0 === M &&
              (M = (function (t, e) {
                const n = {},
                  i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
                for (let r = 0; r < i; r++) {
                  const i = t.getActiveAttrib(e, r),
                    s = i.name;
                  let o = 1;
                  i.type === t.FLOAT_MAT2 && (o = 2),
                    i.type === t.FLOAT_MAT3 && (o = 3),
                    i.type === t.FLOAT_MAT4 && (o = 4),
                    (n[s] = {
                      type: i.type,
                      location: t.getAttribLocation(e, s),
                      locationSize: o,
                    });
                }
                return n;
              })(r, m)),
            M
          );
        }),
        (this.destroy = function () {
          i.releaseStatesOfProgram(this),
            r.deleteProgram(m),
            (this.program = void 0);
        }),
        (this.type = n.shaderType),
        (this.name = n.shaderName),
        (this.id = Eg++),
        (this.cacheKey = e),
        (this.usedTimes = 1),
        (this.program = m),
        (this.vertexShader = b),
        (this.fragmentShader = S),
        this
      );
    }
    let zg = 0;
    class Bg {
      constructor() {
        (this.shaderCache = new Map()), (this.materialCache = new Map());
      }
      update(t) {
        const e = t.vertexShader,
          n = t.fragmentShader,
          i = this._getShaderStage(e),
          r = this._getShaderStage(n),
          s = this._getShaderCacheForMaterial(t);
        return (
          !1 === s.has(i) && (s.add(i), i.usedTimes++),
          !1 === s.has(r) && (s.add(r), r.usedTimes++),
          this
        );
      }
      remove(t) {
        const e = this.materialCache.get(t);
        for (const t of e)
          t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t.code);
        return this.materialCache.delete(t), this;
      }
      getVertexShaderID(t) {
        return this._getShaderStage(t.vertexShader).id;
      }
      getFragmentShaderID(t) {
        return this._getShaderStage(t.fragmentShader).id;
      }
      dispose() {
        this.shaderCache.clear(), this.materialCache.clear();
      }
      _getShaderCacheForMaterial(t) {
        const e = this.materialCache;
        let n = e.get(t);
        return void 0 === n && ((n = new Set()), e.set(t, n)), n;
      }
      _getShaderStage(t) {
        const e = this.shaderCache;
        let n = e.get(t);
        return void 0 === n && ((n = new Hg(t)), e.set(t, n)), n;
      }
    }
    class Hg {
      constructor(t) {
        (this.id = zg++), (this.code = t), (this.usedTimes = 0);
      }
    }
    function Vg(t, e, n, i, r, s, o) {
      const a = new np(),
        l = new Bg(),
        c = [],
        u = r.isWebGL2,
        h = r.logarithmicDepthBuffer,
        d = r.vertexTextures;
      let p = r.precision;
      const f = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite",
      };
      function m(t) {
        return 0 === t ? "uv" : "uv" + t;
      }
      return {
        getParameters: function (s, a, c, g, v) {
          const _ = g.fog,
            y = v.geometry,
            x = s.isMeshStandardMaterial ? g.environment : null,
            b = (s.isMeshStandardMaterial ? n : e).get(s.envMap || x),
            S = b && 306 === b.mapping ? b.image.height : null,
            E = f[s.type];
          null !== s.precision &&
            ((p = r.getMaxPrecision(s.precision)),
            p !== s.precision &&
              console.warn(
                "THREE.WebGLProgram.getParameters:",
                s.precision,
                "not supported, using",
                p,
                "instead."
              ));
          const M =
              y.morphAttributes.position ||
              y.morphAttributes.normal ||
              y.morphAttributes.color,
            T = void 0 !== M ? M.length : 0;
          let w,
            D,
            A,
            C,
            P = 0;
          if (
            (void 0 !== y.morphAttributes.position && (P = 1),
            void 0 !== y.morphAttributes.normal && (P = 2),
            void 0 !== y.morphAttributes.color && (P = 3),
            E)
          ) {
            const t = Hf[E];
            (w = t.vertexShader), (D = t.fragmentShader);
          } else
            (w = s.vertexShader),
              (D = s.fragmentShader),
              l.update(s),
              (A = l.getVertexShaderID(s)),
              (C = l.getFragmentShaderID(s));
          const R = t.getRenderTarget(),
            L = !0 === v.isInstancedMesh,
            O = !!s.map,
            I = !!s.matcap,
            F = !!b,
            U = !!s.aoMap,
            N = !!s.lightMap,
            k = !!s.bumpMap,
            z = !!s.normalMap,
            B = !!s.displacementMap,
            H = !!s.emissiveMap,
            V = !!s.metalnessMap,
            G = !!s.roughnessMap,
            W = s.anisotropy > 0,
            j = s.clearcoat > 0,
            X = s.iridescence > 0,
            q = s.sheen > 0,
            Y = s.transmission > 0,
            K = W && !!s.anisotropyMap,
            Z = j && !!s.clearcoatMap,
            J = j && !!s.clearcoatNormalMap,
            $ = j && !!s.clearcoatRoughnessMap,
            Q = X && !!s.iridescenceMap,
            tt = X && !!s.iridescenceThicknessMap,
            et = q && !!s.sheenColorMap,
            nt = q && !!s.sheenRoughnessMap,
            it = !!s.specularMap,
            rt = !!s.specularColorMap,
            st = !!s.specularIntensityMap,
            ot = Y && !!s.transmissionMap,
            at = Y && !!s.thicknessMap,
            lt = !!s.gradientMap,
            ct = !!s.alphaMap,
            ut = s.alphaTest > 0,
            ht = !!s.alphaHash,
            dt = !!s.extensions,
            pt = !!y.attributes.uv1,
            ft = !!y.attributes.uv2,
            mt = !!y.attributes.uv3;
          let gt = 0;
          return (
            s.toneMapped &&
              ((null !== R && !0 !== R.isXRRenderTarget) ||
                (gt = t.toneMapping)),
            {
              isWebGL2: u,
              shaderID: E,
              shaderType: s.type,
              shaderName: s.name,
              vertexShader: w,
              fragmentShader: D,
              defines: s.defines,
              customVertexShaderID: A,
              customFragmentShaderID: C,
              isRawShaderMaterial: !0 === s.isRawShaderMaterial,
              glslVersion: s.glslVersion,
              precision: p,
              instancing: L,
              instancingColor: L && null !== v.instanceColor,
              supportsVertexTextures: d,
              outputColorSpace:
                null === R
                  ? t.outputColorSpace
                  : !0 === R.isXRRenderTarget
                  ? R.texture.colorSpace
                  : "srgb-linear",
              map: O,
              matcap: I,
              envMap: F,
              envMapMode: F && b.mapping,
              envMapCubeUVHeight: S,
              aoMap: U,
              lightMap: N,
              bumpMap: k,
              normalMap: z,
              displacementMap: d && B,
              emissiveMap: H,
              normalMapObjectSpace: z && 1 === s.normalMapType,
              normalMapTangentSpace: z && 0 === s.normalMapType,
              metalnessMap: V,
              roughnessMap: G,
              anisotropy: W,
              anisotropyMap: K,
              clearcoat: j,
              clearcoatMap: Z,
              clearcoatNormalMap: J,
              clearcoatRoughnessMap: $,
              iridescence: X,
              iridescenceMap: Q,
              iridescenceThicknessMap: tt,
              sheen: q,
              sheenColorMap: et,
              sheenRoughnessMap: nt,
              specularMap: it,
              specularColorMap: rt,
              specularIntensityMap: st,
              transmission: Y,
              transmissionMap: ot,
              thicknessMap: at,
              gradientMap: lt,
              opaque: !1 === s.transparent && 1 === s.blending,
              alphaMap: ct,
              alphaTest: ut,
              alphaHash: ht,
              combine: s.combine,
              mapUv: O && m(s.map.channel),
              aoMapUv: U && m(s.aoMap.channel),
              lightMapUv: N && m(s.lightMap.channel),
              bumpMapUv: k && m(s.bumpMap.channel),
              normalMapUv: z && m(s.normalMap.channel),
              displacementMapUv: B && m(s.displacementMap.channel),
              emissiveMapUv: H && m(s.emissiveMap.channel),
              metalnessMapUv: V && m(s.metalnessMap.channel),
              roughnessMapUv: G && m(s.roughnessMap.channel),
              anisotropyMapUv: K && m(s.anisotropyMap.channel),
              clearcoatMapUv: Z && m(s.clearcoatMap.channel),
              clearcoatNormalMapUv: J && m(s.clearcoatNormalMap.channel),
              clearcoatRoughnessMapUv: $ && m(s.clearcoatRoughnessMap.channel),
              iridescenceMapUv: Q && m(s.iridescenceMap.channel),
              iridescenceThicknessMapUv:
                tt && m(s.iridescenceThicknessMap.channel),
              sheenColorMapUv: et && m(s.sheenColorMap.channel),
              sheenRoughnessMapUv: nt && m(s.sheenRoughnessMap.channel),
              specularMapUv: it && m(s.specularMap.channel),
              specularColorMapUv: rt && m(s.specularColorMap.channel),
              specularIntensityMapUv: st && m(s.specularIntensityMap.channel),
              transmissionMapUv: ot && m(s.transmissionMap.channel),
              thicknessMapUv: at && m(s.thicknessMap.channel),
              alphaMapUv: ct && m(s.alphaMap.channel),
              vertexTangents: !!y.attributes.tangent && (z || W),
              vertexColors: s.vertexColors,
              vertexAlphas:
                !0 === s.vertexColors &&
                !!y.attributes.color &&
                4 === y.attributes.color.itemSize,
              vertexUv1s: pt,
              vertexUv2s: ft,
              vertexUv3s: mt,
              pointsUvs: !0 === v.isPoints && !!y.attributes.uv && (O || ct),
              fog: !!_,
              useFog: !0 === s.fog,
              fogExp2: _ && _.isFogExp2,
              flatShading: !0 === s.flatShading,
              sizeAttenuation: !0 === s.sizeAttenuation,
              logarithmicDepthBuffer: h,
              skinning: !0 === v.isSkinnedMesh,
              morphTargets: void 0 !== y.morphAttributes.position,
              morphNormals: void 0 !== y.morphAttributes.normal,
              morphColors: void 0 !== y.morphAttributes.color,
              morphTargetsCount: T,
              morphTextureStride: P,
              numDirLights: a.directional.length,
              numPointLights: a.point.length,
              numSpotLights: a.spot.length,
              numSpotLightMaps: a.spotLightMap.length,
              numRectAreaLights: a.rectArea.length,
              numHemiLights: a.hemi.length,
              numDirLightShadows: a.directionalShadowMap.length,
              numPointLightShadows: a.pointShadowMap.length,
              numSpotLightShadows: a.spotShadowMap.length,
              numSpotLightShadowsWithMaps: a.numSpotLightShadowsWithMaps,
              numClippingPlanes: o.numPlanes,
              numClipIntersection: o.numIntersection,
              dithering: s.dithering,
              shadowMapEnabled: t.shadowMap.enabled && c.length > 0,
              shadowMapType: t.shadowMap.type,
              toneMapping: gt,
              useLegacyLights: t._useLegacyLights,
              premultipliedAlpha: s.premultipliedAlpha,
              doubleSided: 2 === s.side,
              flipSided: 1 === s.side,
              useDepthPacking: s.depthPacking >= 0,
              depthPacking: s.depthPacking || 0,
              index0AttributeName: s.index0AttributeName,
              extensionDerivatives: dt && !0 === s.extensions.derivatives,
              extensionFragDepth: dt && !0 === s.extensions.fragDepth,
              extensionDrawBuffers: dt && !0 === s.extensions.drawBuffers,
              extensionShaderTextureLOD:
                dt && !0 === s.extensions.shaderTextureLOD,
              rendererExtensionFragDepth: u || i.has("EXT_frag_depth"),
              rendererExtensionDrawBuffers: u || i.has("WEBGL_draw_buffers"),
              rendererExtensionShaderTextureLod:
                u || i.has("EXT_shader_texture_lod"),
              customProgramCacheKey: s.customProgramCacheKey(),
            }
          );
        },
        getProgramCacheKey: function (e) {
          const n = [];
          if (
            (e.shaderID
              ? n.push(e.shaderID)
              : (n.push(e.customVertexShaderID),
                n.push(e.customFragmentShaderID)),
            void 0 !== e.defines)
          )
            for (const t in e.defines) n.push(t), n.push(e.defines[t]);
          return (
            !1 === e.isRawShaderMaterial &&
              (!(function (t, e) {
                t.push(e.precision),
                  t.push(e.outputColorSpace),
                  t.push(e.envMapMode),
                  t.push(e.envMapCubeUVHeight),
                  t.push(e.mapUv),
                  t.push(e.alphaMapUv),
                  t.push(e.lightMapUv),
                  t.push(e.aoMapUv),
                  t.push(e.bumpMapUv),
                  t.push(e.normalMapUv),
                  t.push(e.displacementMapUv),
                  t.push(e.emissiveMapUv),
                  t.push(e.metalnessMapUv),
                  t.push(e.roughnessMapUv),
                  t.push(e.anisotropyMapUv),
                  t.push(e.clearcoatMapUv),
                  t.push(e.clearcoatNormalMapUv),
                  t.push(e.clearcoatRoughnessMapUv),
                  t.push(e.iridescenceMapUv),
                  t.push(e.iridescenceThicknessMapUv),
                  t.push(e.sheenColorMapUv),
                  t.push(e.sheenRoughnessMapUv),
                  t.push(e.specularMapUv),
                  t.push(e.specularColorMapUv),
                  t.push(e.specularIntensityMapUv),
                  t.push(e.transmissionMapUv),
                  t.push(e.thicknessMapUv),
                  t.push(e.combine),
                  t.push(e.fogExp2),
                  t.push(e.sizeAttenuation),
                  t.push(e.morphTargetsCount),
                  t.push(e.morphAttributeCount),
                  t.push(e.numDirLights),
                  t.push(e.numPointLights),
                  t.push(e.numSpotLights),
                  t.push(e.numSpotLightMaps),
                  t.push(e.numHemiLights),
                  t.push(e.numRectAreaLights),
                  t.push(e.numDirLightShadows),
                  t.push(e.numPointLightShadows),
                  t.push(e.numSpotLightShadows),
                  t.push(e.numSpotLightShadowsWithMaps),
                  t.push(e.shadowMapType),
                  t.push(e.toneMapping),
                  t.push(e.numClippingPlanes),
                  t.push(e.numClipIntersection),
                  t.push(e.depthPacking);
              })(n, e),
              (function (t, e) {
                a.disableAll(), e.isWebGL2 && a.enable(0);
                e.supportsVertexTextures && a.enable(1);
                e.instancing && a.enable(2);
                e.instancingColor && a.enable(3);
                e.matcap && a.enable(4);
                e.envMap && a.enable(5);
                e.normalMapObjectSpace && a.enable(6);
                e.normalMapTangentSpace && a.enable(7);
                e.clearcoat && a.enable(8);
                e.iridescence && a.enable(9);
                e.alphaTest && a.enable(10);
                e.vertexColors && a.enable(11);
                e.vertexAlphas && a.enable(12);
                e.vertexUv1s && a.enable(13);
                e.vertexUv2s && a.enable(14);
                e.vertexUv3s && a.enable(15);
                e.vertexTangents && a.enable(16);
                e.anisotropy && a.enable(17);
                t.push(a.mask), a.disableAll(), e.fog && a.enable(0);
                e.useFog && a.enable(1);
                e.flatShading && a.enable(2);
                e.logarithmicDepthBuffer && a.enable(3);
                e.skinning && a.enable(4);
                e.morphTargets && a.enable(5);
                e.morphNormals && a.enable(6);
                e.morphColors && a.enable(7);
                e.premultipliedAlpha && a.enable(8);
                e.shadowMapEnabled && a.enable(9);
                e.useLegacyLights && a.enable(10);
                e.doubleSided && a.enable(11);
                e.flipSided && a.enable(12);
                e.useDepthPacking && a.enable(13);
                e.dithering && a.enable(14);
                e.transmission && a.enable(15);
                e.sheen && a.enable(16);
                e.opaque && a.enable(17);
                e.pointsUvs && a.enable(18);
                t.push(a.mask);
              })(n, e),
              n.push(t.outputColorSpace)),
            n.push(e.customProgramCacheKey),
            n.join()
          );
        },
        getUniforms: function (t) {
          const e = f[t.type];
          let n;
          if (e) {
            const t = Hf[e];
            n = Sf.clone(t.uniforms);
          } else n = t.uniforms;
          return n;
        },
        acquireProgram: function (e, n) {
          let i;
          for (let t = 0, e = c.length; t < e; t++) {
            const e = c[t];
            if (e.cacheKey === n) {
              (i = e), ++i.usedTimes;
              break;
            }
          }
          return void 0 === i && ((i = new kg(t, n, e, s)), c.push(i)), i;
        },
        releaseProgram: function (t) {
          if (0 == --t.usedTimes) {
            const e = c.indexOf(t);
            (c[e] = c[c.length - 1]), c.pop(), t.destroy();
          }
        },
        releaseShaderCache: function (t) {
          l.remove(t);
        },
        programs: c,
        dispose: function () {
          l.dispose();
        },
      };
    }
    function Gg() {
      let t = new WeakMap();
      return {
        get: function (e) {
          let n = t.get(e);
          return void 0 === n && ((n = {}), t.set(e, n)), n;
        },
        remove: function (e) {
          t.delete(e);
        },
        update: function (e, n, i) {
          t.get(e)[n] = i;
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Wg(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.material.id !== e.material.id
        ? t.material.id - e.material.id
        : t.z !== e.z
        ? t.z - e.z
        : t.id - e.id;
    }
    function jg(t, e) {
      return t.groupOrder !== e.groupOrder
        ? t.groupOrder - e.groupOrder
        : t.renderOrder !== e.renderOrder
        ? t.renderOrder - e.renderOrder
        : t.z !== e.z
        ? e.z - t.z
        : t.id - e.id;
    }
    function Xg() {
      const t = [];
      let e = 0;
      const n = [],
        i = [],
        r = [];
      function s(n, i, r, s, o, a) {
        let l = t[e];
        return (
          void 0 === l
            ? ((l = {
                id: n.id,
                object: n,
                geometry: i,
                material: r,
                groupOrder: s,
                renderOrder: n.renderOrder,
                z: o,
                group: a,
              }),
              (t[e] = l))
            : ((l.id = n.id),
              (l.object = n),
              (l.geometry = i),
              (l.material = r),
              (l.groupOrder = s),
              (l.renderOrder = n.renderOrder),
              (l.z = o),
              (l.group = a)),
          e++,
          l
        );
      }
      return {
        opaque: n,
        transmissive: i,
        transparent: r,
        init: function () {
          (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
        },
        push: function (t, e, o, a, l, c) {
          const u = s(t, e, o, a, l, c);
          o.transmission > 0
            ? i.push(u)
            : !0 === o.transparent
            ? r.push(u)
            : n.push(u);
        },
        unshift: function (t, e, o, a, l, c) {
          const u = s(t, e, o, a, l, c);
          o.transmission > 0
            ? i.unshift(u)
            : !0 === o.transparent
            ? r.unshift(u)
            : n.unshift(u);
        },
        finish: function () {
          for (let n = e, i = t.length; n < i; n++) {
            const e = t[n];
            if (null === e.id) break;
            (e.id = null),
              (e.object = null),
              (e.geometry = null),
              (e.material = null),
              (e.group = null);
          }
        },
        sort: function (t, e) {
          n.length > 1 && n.sort(t || Wg),
            i.length > 1 && i.sort(e || jg),
            r.length > 1 && r.sort(e || jg);
        },
      };
    }
    function qg() {
      let t = new WeakMap();
      return {
        get: function (e, n) {
          const i = t.get(e);
          let r;
          return (
            void 0 === i
              ? ((r = new Xg()), t.set(e, [r]))
              : n >= i.length
              ? ((r = new Xg()), i.push(r))
              : (r = i[n]),
            r
          );
        },
        dispose: function () {
          t = new WeakMap();
        },
      };
    }
    function Yg() {
      const t = {};
      return {
        get: function (e) {
          if (void 0 !== t[e.id]) return t[e.id];
          let n;
          switch (e.type) {
            case "DirectionalLight":
              n = {
                direction: new md(),
                color: new Fp(),
              };
              break;
            case "SpotLight":
              n = {
                position: new md(),
                direction: new md(),
                color: new Fp(),
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
              };
              break;
            case "PointLight":
              n = {
                position: new md(),
                color: new Fp(),
                distance: 0,
                decay: 0,
              };
              break;
            case "HemisphereLight":
              n = {
                direction: new md(),
                skyColor: new Fp(),
                groundColor: new Fp(),
              };
              break;
            case "RectAreaLight":
              n = {
                color: new Fp(),
                position: new md(),
                halfWidth: new md(),
                halfHeight: new md(),
              };
          }
          return (t[e.id] = n), n;
        },
      };
    }
    let Kg = 0;
    function Zg(t, e) {
      return (
        (e.castShadow ? 2 : 0) -
        (t.castShadow ? 2 : 0) +
        (e.map ? 1 : 0) -
        (t.map ? 1 : 0)
      );
    }
    function Jg(t, e) {
      const n = new Yg(),
        i = (function () {
          const t = {};
          return {
            get: function (e) {
              if (void 0 !== t[e.id]) return t[e.id];
              let n;
              switch (e.type) {
                case "DirectionalLight":
                case "SpotLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vh(),
                  };
                  break;
                case "PointLight":
                  n = {
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new Vh(),
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3,
                  };
              }
              return (t[e.id] = n), n;
            },
          };
        })(),
        r = {
          version: 0,
          hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
          },
          ambient: [0, 0, 0],
          probe: [],
          directional: [],
          directionalShadow: [],
          directionalShadowMap: [],
          directionalShadowMatrix: [],
          spot: [],
          spotLightMap: [],
          spotShadow: [],
          spotShadowMap: [],
          spotLightMatrix: [],
          rectArea: [],
          rectAreaLTC1: null,
          rectAreaLTC2: null,
          point: [],
          pointShadow: [],
          pointShadowMap: [],
          pointShadowMatrix: [],
          hemi: [],
          numSpotLightShadowsWithMaps: 0,
        };
      for (let t = 0; t < 9; t++) r.probe.push(new md());
      const s = new md(),
        o = new jd(),
        a = new jd();
      return {
        setup: function (s, o) {
          let a = 0,
            l = 0,
            c = 0;
          for (let t = 0; t < 9; t++) r.probe[t].set(0, 0, 0);
          let u = 0,
            h = 0,
            d = 0,
            p = 0,
            f = 0,
            m = 0,
            g = 0,
            v = 0,
            _ = 0,
            y = 0;
          s.sort(Zg);
          const x = !0 === o ? Math.PI : 1;
          for (let t = 0, e = s.length; t < e; t++) {
            const e = s[t],
              o = e.color,
              b = e.intensity,
              S = e.distance,
              E = e.shadow && e.shadow.map ? e.shadow.map.texture : null;
            if (e.isAmbientLight)
              (a += o.r * b * x), (l += o.g * b * x), (c += o.b * b * x);
            else if (e.isLightProbe)
              for (let t = 0; t < 9; t++)
                r.probe[t].addScaledVector(e.sh.coefficients[t], b);
            else if (e.isDirectionalLight) {
              const t = n.get(e);
              if (
                (t.color.copy(e.color).multiplyScalar(e.intensity * x),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (r.directionalShadow[u] = n),
                  (r.directionalShadowMap[u] = E),
                  (r.directionalShadowMatrix[u] = e.shadow.matrix),
                  m++;
              }
              (r.directional[u] = t), u++;
            } else if (e.isSpotLight) {
              const t = n.get(e);
              t.position.setFromMatrixPosition(e.matrixWorld),
                t.color.copy(o).multiplyScalar(b * x),
                (t.distance = S),
                (t.coneCos = Math.cos(e.angle)),
                (t.penumbraCos = Math.cos(e.angle * (1 - e.penumbra))),
                (t.decay = e.decay),
                (r.spot[d] = t);
              const s = e.shadow;
              if (
                (e.map &&
                  ((r.spotLightMap[_] = e.map),
                  _++,
                  s.updateMatrices(e),
                  e.castShadow && y++),
                (r.spotLightMatrix[d] = s.matrix),
                e.castShadow)
              ) {
                const t = i.get(e);
                (t.shadowBias = s.bias),
                  (t.shadowNormalBias = s.normalBias),
                  (t.shadowRadius = s.radius),
                  (t.shadowMapSize = s.mapSize),
                  (r.spotShadow[d] = t),
                  (r.spotShadowMap[d] = E),
                  v++;
              }
              d++;
            } else if (e.isRectAreaLight) {
              const t = n.get(e);
              t.color.copy(o).multiplyScalar(b),
                t.halfWidth.set(0.5 * e.width, 0, 0),
                t.halfHeight.set(0, 0.5 * e.height, 0),
                (r.rectArea[p] = t),
                p++;
            } else if (e.isPointLight) {
              const t = n.get(e);
              if (
                (t.color.copy(e.color).multiplyScalar(e.intensity * x),
                (t.distance = e.distance),
                (t.decay = e.decay),
                e.castShadow)
              ) {
                const t = e.shadow,
                  n = i.get(e);
                (n.shadowBias = t.bias),
                  (n.shadowNormalBias = t.normalBias),
                  (n.shadowRadius = t.radius),
                  (n.shadowMapSize = t.mapSize),
                  (n.shadowCameraNear = t.camera.near),
                  (n.shadowCameraFar = t.camera.far),
                  (r.pointShadow[h] = n),
                  (r.pointShadowMap[h] = E),
                  (r.pointShadowMatrix[h] = e.shadow.matrix),
                  g++;
              }
              (r.point[h] = t), h++;
            } else if (e.isHemisphereLight) {
              const t = n.get(e);
              t.skyColor.copy(e.color).multiplyScalar(b * x),
                t.groundColor.copy(e.groundColor).multiplyScalar(b * x),
                (r.hemi[f] = t),
                f++;
            }
          }
          p > 0 &&
            (e.isWebGL2 || !0 === t.has("OES_texture_float_linear")
              ? ((r.rectAreaLTC1 = Bf.LTC_FLOAT_1),
                (r.rectAreaLTC2 = Bf.LTC_FLOAT_2))
              : !0 === t.has("OES_texture_half_float_linear")
              ? ((r.rectAreaLTC1 = Bf.LTC_HALF_1),
                (r.rectAreaLTC2 = Bf.LTC_HALF_2))
              : console.error(
                  "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
                )),
            (r.ambient[0] = a),
            (r.ambient[1] = l),
            (r.ambient[2] = c);
          const b = r.hash;
          (b.directionalLength === u &&
            b.pointLength === h &&
            b.spotLength === d &&
            b.rectAreaLength === p &&
            b.hemiLength === f &&
            b.numDirectionalShadows === m &&
            b.numPointShadows === g &&
            b.numSpotShadows === v &&
            b.numSpotMaps === _) ||
            ((r.directional.length = u),
            (r.spot.length = d),
            (r.rectArea.length = p),
            (r.point.length = h),
            (r.hemi.length = f),
            (r.directionalShadow.length = m),
            (r.directionalShadowMap.length = m),
            (r.pointShadow.length = g),
            (r.pointShadowMap.length = g),
            (r.spotShadow.length = v),
            (r.spotShadowMap.length = v),
            (r.directionalShadowMatrix.length = m),
            (r.pointShadowMatrix.length = g),
            (r.spotLightMatrix.length = v + _ - y),
            (r.spotLightMap.length = _),
            (r.numSpotLightShadowsWithMaps = y),
            (b.directionalLength = u),
            (b.pointLength = h),
            (b.spotLength = d),
            (b.rectAreaLength = p),
            (b.hemiLength = f),
            (b.numDirectionalShadows = m),
            (b.numPointShadows = g),
            (b.numSpotShadows = v),
            (b.numSpotMaps = _),
            (r.version = Kg++));
        },
        setupView: function (t, e) {
          let n = 0,
            i = 0,
            l = 0,
            c = 0,
            u = 0;
          const h = e.matrixWorldInverse;
          for (let e = 0, d = t.length; e < d; e++) {
            const d = t[e];
            if (d.isDirectionalLight) {
              const t = r.directional[n];
              t.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                t.direction.sub(s),
                t.direction.transformDirection(h),
                n++;
            } else if (d.isSpotLight) {
              const t = r.spot[l];
              t.position.setFromMatrixPosition(d.matrixWorld),
                t.position.applyMatrix4(h),
                t.direction.setFromMatrixPosition(d.matrixWorld),
                s.setFromMatrixPosition(d.target.matrixWorld),
                t.direction.sub(s),
                t.direction.transformDirection(h),
                l++;
            } else if (d.isRectAreaLight) {
              const t = r.rectArea[c];
              t.position.setFromMatrixPosition(d.matrixWorld),
                t.position.applyMatrix4(h),
                a.identity(),
                o.copy(d.matrixWorld),
                o.premultiply(h),
                a.extractRotation(o),
                t.halfWidth.set(0.5 * d.width, 0, 0),
                t.halfHeight.set(0, 0.5 * d.height, 0),
                t.halfWidth.applyMatrix4(a),
                t.halfHeight.applyMatrix4(a),
                c++;
            } else if (d.isPointLight) {
              const t = r.point[i];
              t.position.setFromMatrixPosition(d.matrixWorld),
                t.position.applyMatrix4(h),
                i++;
            } else if (d.isHemisphereLight) {
              const t = r.hemi[u];
              t.direction.setFromMatrixPosition(d.matrixWorld),
                t.direction.transformDirection(h),
                u++;
            }
          }
        },
        state: r,
      };
    }
    function $g(t, e) {
      const n = new Jg(t, e),
        i = [],
        r = [];
      return {
        init: function () {
          (i.length = 0), (r.length = 0);
        },
        state: {
          lightsArray: i,
          shadowsArray: r,
          lights: n,
        },
        setupLights: function (t) {
          n.setup(i, t);
        },
        setupLightsView: function (t) {
          n.setupView(i, t);
        },
        pushLight: function (t) {
          i.push(t);
        },
        pushShadow: function (t) {
          r.push(t);
        },
      };
    }
    function Qg(t, e) {
      let n = new WeakMap();
      return {
        get: function (i, r = 0) {
          const s = n.get(i);
          let o;
          return (
            void 0 === s
              ? ((o = new $g(t, e)), n.set(i, [o]))
              : r >= s.length
              ? ((o = new $g(t, e)), s.push(o))
              : (o = s[r]),
            o
          );
        },
        dispose: function () {
          n = new WeakMap();
        },
      };
    }
    class tv extends Pp {
      constructor(t) {
        super(),
          (this.isMeshDepthMaterial = !0),
          (this.type = "MeshDepthMaterial"),
          (this.depthPacking = 3200),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          (this.wireframe = !1),
          (this.wireframeLinewidth = 1),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.depthPacking = t.depthPacking),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          (this.wireframe = t.wireframe),
          (this.wireframeLinewidth = t.wireframeLinewidth),
          this
        );
      }
    }
    class ev extends Pp {
      constructor(t) {
        super(),
          (this.isMeshDistanceMaterial = !0),
          (this.type = "MeshDistanceMaterial"),
          (this.map = null),
          (this.alphaMap = null),
          (this.displacementMap = null),
          (this.displacementScale = 1),
          (this.displacementBias = 0),
          this.setValues(t);
      }
      copy(t) {
        return (
          super.copy(t),
          (this.map = t.map),
          (this.alphaMap = t.alphaMap),
          (this.displacementMap = t.displacementMap),
          (this.displacementScale = t.displacementScale),
          (this.displacementBias = t.displacementBias),
          this
        );
      }
    }
    function nv(t, e, n) {
      let i = new Ff();
      const r = new Vh(),
        s = new Vh(),
        o = new cd(),
        a = new tv({
          depthPacking: 3201,
        }),
        l = new ev(),
        c = {},
        u = n.maxTextureSize,
        h = {
          0: 1,
          1: 0,
          2: 2,
        },
        d = new Ef({
          defines: {
            VSM_SAMPLES: 8,
          },
          uniforms: {
            shadow_pass: {
              value: null,
            },
            resolution: {
              value: new Vh(),
            },
            radius: {
              value: 4,
            },
          },
          vertexShader:
            "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
          fragmentShader:
            "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
        }),
        p = d.clone();
      p.defines.HORIZONTAL_PASS = 1;
      const f = new Jp();
      f.setAttribute(
        "position",
        new Bp(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
      );
      const m = new gf(f, d),
        g = this;
      (this.enabled = !1),
        (this.autoUpdate = !0),
        (this.needsUpdate = !1),
        (this.type = 1);
      let v = this.type;
      function _(n, i) {
        const s = e.update(m);
        d.defines.VSM_SAMPLES !== n.blurSamples &&
          ((d.defines.VSM_SAMPLES = n.blurSamples),
          (p.defines.VSM_SAMPLES = n.blurSamples),
          (d.needsUpdate = !0),
          (p.needsUpdate = !0)),
          null === n.mapPass && (n.mapPass = new hd(r.x, r.y)),
          (d.uniforms.shadow_pass.value = n.map.texture),
          (d.uniforms.resolution.value = n.mapSize),
          (d.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.mapPass),
          t.clear(),
          t.renderBufferDirect(i, null, s, d, m, null),
          (p.uniforms.shadow_pass.value = n.mapPass.texture),
          (p.uniforms.resolution.value = n.mapSize),
          (p.uniforms.radius.value = n.radius),
          t.setRenderTarget(n.map),
          t.clear(),
          t.renderBufferDirect(i, null, s, p, m, null);
      }
      function y(e, n, i, r) {
        let s = null;
        const o =
          !0 === i.isPointLight
            ? e.customDistanceMaterial
            : e.customDepthMaterial;
        if (void 0 !== o) s = o;
        else if (
          ((s = !0 === i.isPointLight ? l : a),
          (t.localClippingEnabled &&
            !0 === n.clipShadows &&
            Array.isArray(n.clippingPlanes) &&
            0 !== n.clippingPlanes.length) ||
            (n.displacementMap && 0 !== n.displacementScale) ||
            (n.alphaMap && n.alphaTest > 0) ||
            (n.map && n.alphaTest > 0))
        ) {
          const t = s.uuid,
            e = n.uuid;
          let i = c[t];
          void 0 === i && ((i = {}), (c[t] = i));
          let r = i[e];
          void 0 === r && ((r = s.clone()), (i[e] = r)), (s = r);
        }
        if (
          ((s.visible = n.visible),
          (s.wireframe = n.wireframe),
          (s.side =
            3 === r
              ? null !== n.shadowSide
                ? n.shadowSide
                : n.side
              : null !== n.shadowSide
              ? n.shadowSide
              : h[n.side]),
          (s.alphaMap = n.alphaMap),
          (s.alphaTest = n.alphaTest),
          (s.map = n.map),
          (s.clipShadows = n.clipShadows),
          (s.clippingPlanes = n.clippingPlanes),
          (s.clipIntersection = n.clipIntersection),
          (s.displacementMap = n.displacementMap),
          (s.displacementScale = n.displacementScale),
          (s.displacementBias = n.displacementBias),
          (s.wireframeLinewidth = n.wireframeLinewidth),
          (s.linewidth = n.linewidth),
          !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial)
        ) {
          t.properties.get(s).light = i;
        }
        return s;
      }
      function x(n, r, s, o, a) {
        if (!1 === n.visible) return;
        if (
          n.layers.test(r.layers) &&
          (n.isMesh || n.isLine || n.isPoints) &&
          (n.castShadow || (n.receiveShadow && 3 === a)) &&
          (!n.frustumCulled || i.intersectsObject(n))
        ) {
          n.modelViewMatrix.multiplyMatrices(
            s.matrixWorldInverse,
            n.matrixWorld
          );
          const i = e.update(n),
            r = n.material;
          if (Array.isArray(r)) {
            const e = i.groups;
            for (let l = 0, c = e.length; l < c; l++) {
              const c = e[l],
                u = r[c.materialIndex];
              if (u && u.visible) {
                const e = y(n, u, o, a);
                t.renderBufferDirect(s, null, i, e, n, c);
              }
            }
          } else if (r.visible) {
            const e = y(n, r, o, a);
            t.renderBufferDirect(s, null, i, e, n, null);
          }
        }
        const l = n.children;
        for (let t = 0, e = l.length; t < e; t++) x(l[t], r, s, o, a);
      }
      this.render = function (e, n, a) {
        if (!1 === g.enabled) return;
        if (!1 === g.autoUpdate && !1 === g.needsUpdate) return;
        if (0 === e.length) return;
        const l = t.getRenderTarget(),
          c = t.getActiveCubeFace(),
          h = t.getActiveMipmapLevel(),
          d = t.state;
        d.setBlending(0),
          d.buffers.color.setClear(1, 1, 1, 1),
          d.buffers.depth.setTest(!0),
          d.setScissorTest(!1);
        const p = 3 !== v && 3 === this.type,
          f = 3 === v && 3 !== this.type;
        for (let l = 0, c = e.length; l < c; l++) {
          const c = e[l],
            h = c.shadow;
          if (void 0 === h) {
            console.warn("THREE.WebGLShadowMap:", c, "has no shadow.");
            continue;
          }
          if (!1 === h.autoUpdate && !1 === h.needsUpdate) continue;
          r.copy(h.mapSize);
          const m = h.getFrameExtents();
          if (
            (r.multiply(m),
            s.copy(h.mapSize),
            (r.x > u || r.y > u) &&
              (r.x > u &&
                ((s.x = Math.floor(u / m.x)),
                (r.x = s.x * m.x),
                (h.mapSize.x = s.x)),
              r.y > u &&
                ((s.y = Math.floor(u / m.y)),
                (r.y = s.y * m.y),
                (h.mapSize.y = s.y))),
            null === h.map || !0 === p || !0 === f)
          ) {
            const t =
              3 !== this.type
                ? {
                    minFilter: 1003,
                    magFilter: 1003,
                  }
                : {};
            null !== h.map && h.map.dispose(),
              (h.map = new hd(r.x, r.y, t)),
              (h.map.texture.name = c.name + ".shadowMap"),
              h.camera.updateProjectionMatrix();
          }
          t.setRenderTarget(h.map), t.clear();
          const g = h.getViewportCount();
          for (let t = 0; t < g; t++) {
            const e = h.getViewport(t);
            o.set(s.x * e.x, s.y * e.y, s.x * e.z, s.y * e.w),
              d.viewport(o),
              h.updateMatrices(c, t),
              (i = h.getFrustum()),
              x(n, a, h.camera, c, this.type);
          }
          !0 !== h.isPointLightShadow && 3 === this.type && _(h, a),
            (h.needsUpdate = !1);
        }
        (v = this.type), (g.needsUpdate = !1), t.setRenderTarget(l, c, h);
      };
    }
    function iv(t, e, n) {
      const i = n.isWebGL2;
      const r = new (function () {
          let e = !1;
          const n = new cd();
          let i = null;
          const r = new cd(0, 0, 0, 0);
          return {
            setMask: function (n) {
              i === n || e || (t.colorMask(n, n, n, n), (i = n));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e, i, s, o, a) {
              !0 === a && ((e *= o), (i *= o), (s *= o)),
                n.set(e, i, s, o),
                !1 === r.equals(n) && (t.clearColor(e, i, s, o), r.copy(n));
            },
            reset: function () {
              (e = !1), (i = null), r.set(-1, 0, 0, 0);
            },
          };
        })(),
        s = new (function () {
          let e = !1,
            n = null,
            i = null,
            r = null;
          return {
            setTest: function (e) {
              e ? B(t.DEPTH_TEST) : H(t.DEPTH_TEST);
            },
            setMask: function (i) {
              n === i || e || (t.depthMask(i), (n = i));
            },
            setFunc: function (e) {
              if (i !== e) {
                switch (e) {
                  case 0:
                    t.depthFunc(t.NEVER);
                    break;
                  case 1:
                    t.depthFunc(t.ALWAYS);
                    break;
                  case 2:
                    t.depthFunc(t.LESS);
                    break;
                  case 3:
                    t.depthFunc(t.LEQUAL);
                    break;
                  case 4:
                    t.depthFunc(t.EQUAL);
                    break;
                  case 5:
                    t.depthFunc(t.GEQUAL);
                    break;
                  case 6:
                    t.depthFunc(t.GREATER);
                    break;
                  case 7:
                    t.depthFunc(t.NOTEQUAL);
                    break;
                  default:
                    t.depthFunc(t.LEQUAL);
                }
                i = e;
              }
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              r !== e && (t.clearDepth(e), (r = e));
            },
            reset: function () {
              (e = !1), (n = null), (i = null), (r = null);
            },
          };
        })(),
        o = new (function () {
          let e = !1,
            n = null,
            i = null,
            r = null,
            s = null,
            o = null,
            a = null,
            l = null,
            c = null;
          return {
            setTest: function (n) {
              e || (n ? B(t.STENCIL_TEST) : H(t.STENCIL_TEST));
            },
            setMask: function (i) {
              n === i || e || (t.stencilMask(i), (n = i));
            },
            setFunc: function (e, n, o) {
              (i === e && r === n && s === o) ||
                (t.stencilFunc(e, n, o), (i = e), (r = n), (s = o));
            },
            setOp: function (e, n, i) {
              (o === e && a === n && l === i) ||
                (t.stencilOp(e, n, i), (o = e), (a = n), (l = i));
            },
            setLocked: function (t) {
              e = t;
            },
            setClear: function (e) {
              c !== e && (t.clearStencil(e), (c = e));
            },
            reset: function () {
              (e = !1),
                (n = null),
                (i = null),
                (r = null),
                (s = null),
                (o = null),
                (a = null),
                (l = null),
                (c = null);
            },
          };
        })(),
        a = new WeakMap(),
        l = new WeakMap();
      let c = {},
        u = {},
        h = new WeakMap(),
        d = [],
        p = null,
        f = !1,
        m = null,
        g = null,
        v = null,
        _ = null,
        y = null,
        x = null,
        b = null,
        S = !1,
        E = null,
        M = null,
        T = null,
        w = null,
        D = null;
      const A = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
      let C = !1,
        P = 0;
      const R = t.getParameter(t.VERSION);
      -1 !== R.indexOf("WebGL")
        ? ((P = parseFloat(/^WebGL (\d)/.exec(R)[1])), (C = P >= 1))
        : -1 !== R.indexOf("OpenGL ES") &&
          ((P = parseFloat(/^OpenGL ES (\d)/.exec(R)[1])), (C = P >= 2));
      let L = null,
        O = {};
      const I = t.getParameter(t.SCISSOR_BOX),
        F = t.getParameter(t.VIEWPORT),
        U = new cd().fromArray(I),
        N = new cd().fromArray(F);
      function k(e, n, r, s) {
        const o = new Uint8Array(4),
          a = t.createTexture();
        t.bindTexture(e, a),
          t.texParameteri(e, t.TEXTURE_MIN_FILTER, t.NEAREST),
          t.texParameteri(e, t.TEXTURE_MAG_FILTER, t.NEAREST);
        for (let a = 0; a < r; a++)
          !i || (e !== t.TEXTURE_3D && e !== t.TEXTURE_2D_ARRAY)
            ? t.texImage2D(
                n + a,
                0,
                t.RGBA,
                1,
                1,
                0,
                t.RGBA,
                t.UNSIGNED_BYTE,
                o
              )
            : t.texImage3D(
                n,
                0,
                t.RGBA,
                1,
                1,
                s,
                0,
                t.RGBA,
                t.UNSIGNED_BYTE,
                o
              );
        return a;
      }
      const z = {};
      function B(e) {
        !0 !== c[e] && (t.enable(e), (c[e] = !0));
      }
      function H(e) {
        !1 !== c[e] && (t.disable(e), (c[e] = !1));
      }
      (z[t.TEXTURE_2D] = k(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
        (z[t.TEXTURE_CUBE_MAP] = k(
          t.TEXTURE_CUBE_MAP,
          t.TEXTURE_CUBE_MAP_POSITIVE_X,
          6
        )),
        i &&
          ((z[t.TEXTURE_2D_ARRAY] = k(
            t.TEXTURE_2D_ARRAY,
            t.TEXTURE_2D_ARRAY,
            1,
            1
          )),
          (z[t.TEXTURE_3D] = k(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
        r.setClear(0, 0, 0, 1),
        s.setClear(1),
        o.setClear(0),
        B(t.DEPTH_TEST),
        s.setFunc(3),
        j(!1),
        X(1),
        B(t.CULL_FACE),
        W(0);
      const V = {
        100: t.FUNC_ADD,
        101: t.FUNC_SUBTRACT,
        102: t.FUNC_REVERSE_SUBTRACT,
      };
      if (i) (V[103] = t.MIN), (V[104] = t.MAX);
      else {
        const t = e.get("EXT_blend_minmax");
        null !== t && ((V[103] = t.MIN_EXT), (V[104] = t.MAX_EXT));
      }
      const G = {
        200: t.ZERO,
        201: t.ONE,
        202: t.SRC_COLOR,
        204: t.SRC_ALPHA,
        210: t.SRC_ALPHA_SATURATE,
        208: t.DST_COLOR,
        206: t.DST_ALPHA,
        203: t.ONE_MINUS_SRC_COLOR,
        205: t.ONE_MINUS_SRC_ALPHA,
        209: t.ONE_MINUS_DST_COLOR,
        207: t.ONE_MINUS_DST_ALPHA,
      };
      function W(e, n, i, r, s, o, a, l) {
        if (0 !== e) {
          if ((!1 === f && (B(t.BLEND), (f = !0)), 5 === e))
            (s = s || n),
              (o = o || i),
              (a = a || r),
              (n === g && s === y) ||
                (t.blendEquationSeparate(V[n], V[s]), (g = n), (y = s)),
              (i === v && r === _ && o === x && a === b) ||
                (t.blendFuncSeparate(G[i], G[r], G[o], G[a]),
                (v = i),
                (_ = r),
                (x = o),
                (b = a)),
              (m = e),
              (S = !1);
          else if (e !== m || l !== S) {
            if (
              ((100 === g && 100 === y) ||
                (t.blendEquation(t.FUNC_ADD), (g = 100), (y = 100)),
              l)
            )
              switch (e) {
                case 1:
                  t.blendFuncSeparate(
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA
                  );
                  break;
                case 2:
                  t.blendFunc(t.ONE, t.ONE);
                  break;
                case 3:
                  t.blendFuncSeparate(
                    t.ZERO,
                    t.ONE_MINUS_SRC_COLOR,
                    t.ZERO,
                    t.ONE
                  );
                  break;
                case 4:
                  t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            else
              switch (e) {
                case 1:
                  t.blendFuncSeparate(
                    t.SRC_ALPHA,
                    t.ONE_MINUS_SRC_ALPHA,
                    t.ONE,
                    t.ONE_MINUS_SRC_ALPHA
                  );
                  break;
                case 2:
                  t.blendFunc(t.SRC_ALPHA, t.ONE);
                  break;
                case 3:
                  t.blendFuncSeparate(
                    t.ZERO,
                    t.ONE_MINUS_SRC_COLOR,
                    t.ZERO,
                    t.ONE
                  );
                  break;
                case 4:
                  t.blendFunc(t.ZERO, t.SRC_COLOR);
                  break;
                default:
                  console.error("THREE.WebGLState: Invalid blending: ", e);
              }
            (v = null), (_ = null), (x = null), (b = null), (m = e), (S = l);
          }
        } else !0 === f && (H(t.BLEND), (f = !1));
      }
      function j(e) {
        E !== e && (e ? t.frontFace(t.CW) : t.frontFace(t.CCW), (E = e));
      }
      function X(e) {
        0 !== e
          ? (B(t.CULL_FACE),
            e !== M &&
              (1 === e
                ? t.cullFace(t.BACK)
                : 2 === e
                ? t.cullFace(t.FRONT)
                : t.cullFace(t.FRONT_AND_BACK)))
          : H(t.CULL_FACE),
          (M = e);
      }
      function q(e, n, i) {
        e
          ? (B(t.POLYGON_OFFSET_FILL),
            (w === n && D === i) || (t.polygonOffset(n, i), (w = n), (D = i)))
          : H(t.POLYGON_OFFSET_FILL);
      }
      return {
        buffers: {
          color: r,
          depth: s,
          stencil: o,
        },
        enable: B,
        disable: H,
        bindFramebuffer: function (e, n) {
          return (
            u[e] !== n &&
            (t.bindFramebuffer(e, n),
            (u[e] = n),
            i &&
              (e === t.DRAW_FRAMEBUFFER && (u[t.FRAMEBUFFER] = n),
              e === t.FRAMEBUFFER && (u[t.DRAW_FRAMEBUFFER] = n)),
            !0)
          );
        },
        drawBuffers: function (i, r) {
          let s = d,
            o = !1;
          if (i)
            if (
              ((s = h.get(r)),
              void 0 === s && ((s = []), h.set(r, s)),
              i.isWebGLMultipleRenderTargets)
            ) {
              const e = i.texture;
              if (s.length !== e.length || s[0] !== t.COLOR_ATTACHMENT0) {
                for (let n = 0, i = e.length; n < i; n++)
                  s[n] = t.COLOR_ATTACHMENT0 + n;
                (s.length = e.length), (o = !0);
              }
            } else
              s[0] !== t.COLOR_ATTACHMENT0 &&
                ((s[0] = t.COLOR_ATTACHMENT0), (o = !0));
          else s[0] !== t.BACK && ((s[0] = t.BACK), (o = !0));
          o &&
            (n.isWebGL2
              ? t.drawBuffers(s)
              : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(s));
        },
        useProgram: function (e) {
          return p !== e && (t.useProgram(e), (p = e), !0);
        },
        setBlending: W,
        setMaterial: function (e, n) {
          2 === e.side ? H(t.CULL_FACE) : B(t.CULL_FACE);
          let i = 1 === e.side;
          n && (i = !i),
            j(i),
            1 === e.blending && !1 === e.transparent
              ? W(0)
              : W(
                  e.blending,
                  e.blendEquation,
                  e.blendSrc,
                  e.blendDst,
                  e.blendEquationAlpha,
                  e.blendSrcAlpha,
                  e.blendDstAlpha,
                  e.premultipliedAlpha
                ),
            s.setFunc(e.depthFunc),
            s.setTest(e.depthTest),
            s.setMask(e.depthWrite),
            r.setMask(e.colorWrite);
          const a = e.stencilWrite;
          o.setTest(a),
            a &&
              (o.setMask(e.stencilWriteMask),
              o.setFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask),
              o.setOp(e.stencilFail, e.stencilZFail, e.stencilZPass)),
            q(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits),
            !0 === e.alphaToCoverage
              ? B(t.SAMPLE_ALPHA_TO_COVERAGE)
              : H(t.SAMPLE_ALPHA_TO_COVERAGE);
        },
        setFlipSided: j,
        setCullFace: X,
        setLineWidth: function (e) {
          e !== T && (C && t.lineWidth(e), (T = e));
        },
        setPolygonOffset: q,
        setScissorTest: function (e) {
          e ? B(t.SCISSOR_TEST) : H(t.SCISSOR_TEST);
        },
        activeTexture: function (e) {
          void 0 === e && (e = t.TEXTURE0 + A - 1),
            L !== e && (t.activeTexture(e), (L = e));
        },
        bindTexture: function (e, n, i) {
          void 0 === i && (i = null === L ? t.TEXTURE0 + A - 1 : L);
          let r = O[i];
          void 0 === r &&
            ((r = {
              type: void 0,
              texture: void 0,
            }),
            (O[i] = r)),
            (r.type === e && r.texture === n) ||
              (L !== i && (t.activeTexture(i), (L = i)),
              t.bindTexture(e, n || z[e]),
              (r.type = e),
              (r.texture = n));
        },
        unbindTexture: function () {
          const e = O[L];
          void 0 !== e &&
            void 0 !== e.type &&
            (t.bindTexture(e.type, null),
            (e.type = void 0),
            (e.texture = void 0));
        },
        compressedTexImage2D: function () {
          try {
            t.compressedTexImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        compressedTexImage3D: function () {
          try {
            t.compressedTexImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage2D: function () {
          try {
            t.texImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texImage3D: function () {
          try {
            t.texImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        updateUBOMapping: function (e, n) {
          let i = l.get(n);
          void 0 === i && ((i = new WeakMap()), l.set(n, i));
          let r = i.get(e);
          void 0 === r &&
            ((r = t.getUniformBlockIndex(n, e.name)), i.set(e, r));
        },
        uniformBlockBinding: function (e, n) {
          const i = l.get(n).get(e);
          a.get(n) !== i &&
            (t.uniformBlockBinding(n, i, e.__bindingPointIndex), a.set(n, i));
        },
        texStorage2D: function () {
          try {
            t.texStorage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texStorage3D: function () {
          try {
            t.texStorage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texSubImage2D: function () {
          try {
            t.texSubImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        texSubImage3D: function () {
          try {
            t.texSubImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        compressedTexSubImage2D: function () {
          try {
            t.compressedTexSubImage2D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        compressedTexSubImage3D: function () {
          try {
            t.compressedTexSubImage3D.apply(t, arguments);
          } catch (t) {
            console.error("THREE.WebGLState:", t);
          }
        },
        scissor: function (e) {
          !1 === U.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), U.copy(e));
        },
        viewport: function (e) {
          !1 === N.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), N.copy(e));
        },
        reset: function () {
          t.disable(t.BLEND),
            t.disable(t.CULL_FACE),
            t.disable(t.DEPTH_TEST),
            t.disable(t.POLYGON_OFFSET_FILL),
            t.disable(t.SCISSOR_TEST),
            t.disable(t.STENCIL_TEST),
            t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
            t.blendEquation(t.FUNC_ADD),
            t.blendFunc(t.ONE, t.ZERO),
            t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
            t.colorMask(!0, !0, !0, !0),
            t.clearColor(0, 0, 0, 0),
            t.depthMask(!0),
            t.depthFunc(t.LESS),
            t.clearDepth(1),
            t.stencilMask(4294967295),
            t.stencilFunc(t.ALWAYS, 0, 4294967295),
            t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
            t.clearStencil(0),
            t.cullFace(t.BACK),
            t.frontFace(t.CCW),
            t.polygonOffset(0, 0),
            t.activeTexture(t.TEXTURE0),
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            !0 === i &&
              (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
              t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
            t.useProgram(null),
            t.lineWidth(1),
            t.scissor(0, 0, t.canvas.width, t.canvas.height),
            t.viewport(0, 0, t.canvas.width, t.canvas.height),
            (c = {}),
            (L = null),
            (O = {}),
            (u = {}),
            (h = new WeakMap()),
            (d = []),
            (p = null),
            (f = !1),
            (m = null),
            (g = null),
            (v = null),
            (_ = null),
            (y = null),
            (x = null),
            (b = null),
            (S = !1),
            (E = null),
            (M = null),
            (T = null),
            (w = null),
            (D = null),
            U.set(0, 0, t.canvas.width, t.canvas.height),
            N.set(0, 0, t.canvas.width, t.canvas.height),
            r.reset(),
            s.reset(),
            o.reset();
        },
      };
    }
    function rv(t, e, n, i, r, s, o) {
      const a = r.isWebGL2,
        l = r.maxTextures,
        c = r.maxCubemapSize,
        u = r.maxTextureSize,
        h = r.maxSamples,
        d = e.has("WEBGL_multisampled_render_to_texture")
          ? e.get("WEBGL_multisampled_render_to_texture")
          : null,
        p =
          "undefined" != typeof navigator &&
          /OculusBrowser/g.test(navigator.userAgent),
        f = new WeakMap();
      let m;
      const g = new WeakMap();
      let v = !1;
      try {
        v =
          "undefined" != typeof OffscreenCanvas &&
          null !== new OffscreenCanvas(1, 1).getContext("2d");
      } catch (t) {}
      function _(t, e) {
        return v ? new OffscreenCanvas(t, e) : Xh("canvas");
      }
      function y(t, e, n, i) {
        let r = 1;
        if (
          ((t.width > i || t.height > i) &&
            (r = i / Math.max(t.width, t.height)),
          r < 1 || !0 === e)
        ) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              t instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              t instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && t instanceof ImageBitmap)
          ) {
            const i = e ? zh : Math.floor,
              s = i(r * t.width),
              o = i(r * t.height);
            void 0 === m && (m = _(s, o));
            const a = n ? _(s, o) : m;
            (a.width = s), (a.height = o);
            return (
              a.getContext("2d").drawImage(t, 0, 0, s, o),
              console.warn(
                "THREE.WebGLRenderer: Texture has been resized from (" +
                  t.width +
                  "x" +
                  t.height +
                  ") to (" +
                  s +
                  "x" +
                  o +
                  ")."
              ),
              a
            );
          }
          return (
            "data" in t &&
              console.warn(
                "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                  t.width +
                  "x" +
                  t.height +
                  ")."
              ),
            t
          );
        }
        return t;
      }
      function x(t) {
        return kh(t.width) && kh(t.height);
      }
      function b(t, e) {
        return (
          t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        );
      }
      function S(e) {
        t.generateMipmap(e);
      }
      function E(n, i, r, s, o = !1) {
        if (!1 === a) return i;
        if (null !== n) {
          if (void 0 !== t[n]) return t[n];
          console.warn(
            "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
              n +
              "'"
          );
        }
        let l = i;
        return (
          i === t.RED &&
            (r === t.FLOAT && (l = t.R32F),
            r === t.HALF_FLOAT && (l = t.R16F),
            r === t.UNSIGNED_BYTE && (l = t.R8)),
          i === t.RED_INTEGER &&
            (r === t.UNSIGNED_BYTE && (l = t.R8UI),
            r === t.UNSIGNED_SHORT && (l = t.R16UI),
            r === t.UNSIGNED_INT && (l = t.R32UI),
            r === t.BYTE && (l = t.R8I),
            r === t.SHORT && (l = t.R16I),
            r === t.INT && (l = t.R32I)),
          i === t.RG &&
            (r === t.FLOAT && (l = t.RG32F),
            r === t.HALF_FLOAT && (l = t.RG16F),
            r === t.UNSIGNED_BYTE && (l = t.RG8)),
          i === t.RGBA &&
            (r === t.FLOAT && (l = t.RGBA32F),
            r === t.HALF_FLOAT && (l = t.RGBA16F),
            r === t.UNSIGNED_BYTE &&
              (l = "srgb" === s && !1 === o ? t.SRGB8_ALPHA8 : t.RGBA8),
            r === t.UNSIGNED_SHORT_4_4_4_4 && (l = t.RGBA4),
            r === t.UNSIGNED_SHORT_5_5_5_1 && (l = t.RGB5_A1)),
          (l !== t.R16F &&
            l !== t.R32F &&
            l !== t.RG16F &&
            l !== t.RG32F &&
            l !== t.RGBA16F &&
            l !== t.RGBA32F) ||
            e.get("EXT_color_buffer_float"),
          l
        );
      }
      function M(t, e, n) {
        return !0 === b(t, n) ||
          (t.isFramebufferTexture &&
            1003 !== t.minFilter &&
            1006 !== t.minFilter)
          ? Math.log2(Math.max(e.width, e.height)) + 1
          : void 0 !== t.mipmaps && t.mipmaps.length > 0
          ? t.mipmaps.length
          : t.isCompressedTexture && Array.isArray(t.image)
          ? e.mipmaps.length
          : 1;
      }
      function T(e) {
        return 1003 === e || 1004 === e || 1005 === e ? t.NEAREST : t.LINEAR;
      }
      function w(t) {
        const e = t.target;
        e.removeEventListener("dispose", w),
          (function (t) {
            const e = i.get(t);
            if (void 0 === e.__webglInit) return;
            const n = t.source,
              r = g.get(n);
            if (r) {
              const i = r[e.__cacheKey];
              i.usedTimes--,
                0 === i.usedTimes && A(t),
                0 === Object.keys(r).length && g.delete(n);
            }
            i.remove(t);
          })(e),
          e.isVideoTexture && f.delete(e);
      }
      function D(e) {
        const n = e.target;
        n.removeEventListener("dispose", D),
          (function (e) {
            const n = e.texture,
              r = i.get(e),
              s = i.get(n);
            void 0 !== s.__webglTexture &&
              (t.deleteTexture(s.__webglTexture), o.memory.textures--);
            e.depthTexture && e.depthTexture.dispose();
            if (e.isWebGLCubeRenderTarget)
              for (let e = 0; e < 6; e++) {
                if (Array.isArray(r.__webglFramebuffer[e]))
                  for (let n = 0; n < r.__webglFramebuffer[e].length; n++)
                    t.deleteFramebuffer(r.__webglFramebuffer[e][n]);
                else t.deleteFramebuffer(r.__webglFramebuffer[e]);
                r.__webglDepthbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthbuffer[e]);
              }
            else {
              if (Array.isArray(r.__webglFramebuffer))
                for (let e = 0; e < r.__webglFramebuffer.length; e++)
                  t.deleteFramebuffer(r.__webglFramebuffer[e]);
              else t.deleteFramebuffer(r.__webglFramebuffer);
              if (
                (r.__webglDepthbuffer &&
                  t.deleteRenderbuffer(r.__webglDepthbuffer),
                r.__webglMultisampledFramebuffer &&
                  t.deleteFramebuffer(r.__webglMultisampledFramebuffer),
                r.__webglColorRenderbuffer)
              )
                for (let e = 0; e < r.__webglColorRenderbuffer.length; e++)
                  r.__webglColorRenderbuffer[e] &&
                    t.deleteRenderbuffer(r.__webglColorRenderbuffer[e]);
              r.__webglDepthRenderbuffer &&
                t.deleteRenderbuffer(r.__webglDepthRenderbuffer);
            }
            if (e.isWebGLMultipleRenderTargets)
              for (let e = 0, r = n.length; e < r; e++) {
                const r = i.get(n[e]);
                r.__webglTexture &&
                  (t.deleteTexture(r.__webglTexture), o.memory.textures--),
                  i.remove(n[e]);
              }
            i.remove(n), i.remove(e);
          })(n);
      }
      function A(e) {
        const n = i.get(e);
        t.deleteTexture(n.__webglTexture);
        const r = e.source;
        delete g.get(r)[n.__cacheKey], o.memory.textures--;
      }
      let C = 0;
      function P(e, r) {
        const s = i.get(e);
        if (
          (e.isVideoTexture &&
            (function (t) {
              const e = o.render.frame;
              f.get(t) !== e && (f.set(t, e), t.update());
            })(e),
          !1 === e.isRenderTargetTexture &&
            e.version > 0 &&
            s.__version !== e.version)
        ) {
          const t = e.image;
          if (null === t)
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but no image data found."
            );
          else {
            if (!1 !== t.complete) return void U(s, e, r);
            console.warn(
              "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
            );
          }
        }
        n.bindTexture(t.TEXTURE_2D, s.__webglTexture, t.TEXTURE0 + r);
      }
      const R = {
          1e3: t.REPEAT,
          1001: t.CLAMP_TO_EDGE,
          1002: t.MIRRORED_REPEAT,
        },
        L = {
          1003: t.NEAREST,
          1004: t.NEAREST_MIPMAP_NEAREST,
          1005: t.NEAREST_MIPMAP_LINEAR,
          1006: t.LINEAR,
          1007: t.LINEAR_MIPMAP_NEAREST,
          1008: t.LINEAR_MIPMAP_LINEAR,
        },
        O = {
          512: t.NEVER,
          519: t.ALWAYS,
          513: t.LESS,
          515: t.LEQUAL,
          514: t.EQUAL,
          518: t.GEQUAL,
          516: t.GREATER,
          517: t.NOTEQUAL,
        };
      function I(n, s, o) {
        if (
          (o
            ? (t.texParameteri(n, t.TEXTURE_WRAP_S, R[s.wrapS]),
              t.texParameteri(n, t.TEXTURE_WRAP_T, R[s.wrapT]),
              (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                t.texParameteri(n, t.TEXTURE_WRAP_R, R[s.wrapR]),
              t.texParameteri(n, t.TEXTURE_MAG_FILTER, L[s.magFilter]),
              t.texParameteri(n, t.TEXTURE_MIN_FILTER, L[s.minFilter]))
            : (t.texParameteri(n, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
              t.texParameteri(n, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
              (n !== t.TEXTURE_3D && n !== t.TEXTURE_2D_ARRAY) ||
                t.texParameteri(n, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
              (1001 === s.wrapS && 1001 === s.wrapT) ||
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
                ),
              t.texParameteri(n, t.TEXTURE_MAG_FILTER, T(s.magFilter)),
              t.texParameteri(n, t.TEXTURE_MIN_FILTER, T(s.minFilter)),
              1003 !== s.minFilter &&
                1006 !== s.minFilter &&
                console.warn(
                  "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
                )),
          s.compareFunction &&
            (t.texParameteri(
              n,
              t.TEXTURE_COMPARE_MODE,
              t.COMPARE_REF_TO_TEXTURE
            ),
            t.texParameteri(n, t.TEXTURE_COMPARE_FUNC, O[s.compareFunction])),
          !0 === e.has("EXT_texture_filter_anisotropic"))
        ) {
          const o = e.get("EXT_texture_filter_anisotropic");
          if (1003 === s.magFilter) return;
          if (1005 !== s.minFilter && 1008 !== s.minFilter) return;
          if (1015 === s.type && !1 === e.has("OES_texture_float_linear"))
            return;
          if (
            !1 === a &&
            1016 === s.type &&
            !1 === e.has("OES_texture_half_float_linear")
          )
            return;
          (s.anisotropy > 1 || i.get(s).__currentAnisotropy) &&
            (t.texParameterf(
              n,
              o.TEXTURE_MAX_ANISOTROPY_EXT,
              Math.min(s.anisotropy, r.getMaxAnisotropy())
            ),
            (i.get(s).__currentAnisotropy = s.anisotropy));
        }
      }
      function F(e, n) {
        let i = !1;
        void 0 === e.__webglInit &&
          ((e.__webglInit = !0), n.addEventListener("dispose", w));
        const r = n.source;
        let s = g.get(r);
        void 0 === s && ((s = {}), g.set(r, s));
        const a = (function (t) {
          const e = [];
          return (
            e.push(t.wrapS),
            e.push(t.wrapT),
            e.push(t.wrapR || 0),
            e.push(t.magFilter),
            e.push(t.minFilter),
            e.push(t.anisotropy),
            e.push(t.internalFormat),
            e.push(t.format),
            e.push(t.type),
            e.push(t.generateMipmaps),
            e.push(t.premultiplyAlpha),
            e.push(t.flipY),
            e.push(t.unpackAlignment),
            e.push(t.colorSpace),
            e.join()
          );
        })(n);
        if (a !== e.__cacheKey) {
          void 0 === s[a] &&
            ((s[a] = {
              texture: t.createTexture(),
              usedTimes: 0,
            }),
            o.memory.textures++,
            (i = !0)),
            s[a].usedTimes++;
          const r = s[e.__cacheKey];
          void 0 !== r &&
            (s[e.__cacheKey].usedTimes--, 0 === r.usedTimes && A(n)),
            (e.__cacheKey = a),
            (e.__webglTexture = s[a].texture);
        }
        return i;
      }
      function U(e, r, o) {
        let l = t.TEXTURE_2D;
        (r.isDataArrayTexture || r.isCompressedArrayTexture) &&
          (l = t.TEXTURE_2D_ARRAY),
          r.isData3DTexture && (l = t.TEXTURE_3D);
        const c = F(e, r),
          h = r.source;
        n.bindTexture(l, e.__webglTexture, t.TEXTURE0 + o);
        const d = i.get(h);
        if (h.version !== d.__version || !0 === c) {
          n.activeTexture(t.TEXTURE0 + o),
            t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
            t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, r.premultiplyAlpha),
            t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
            t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
          const e =
            (function (t) {
              return (
                !a &&
                (1001 !== t.wrapS ||
                  1001 !== t.wrapT ||
                  (1003 !== t.minFilter && 1006 !== t.minFilter))
              );
            })(r) && !1 === x(r.image);
          let i = y(r.image, e, !1, u);
          i = V(r, i);
          const p = x(i) || a,
            f = s.convert(r.format, r.colorSpace);
          let m,
            g = s.convert(r.type),
            v = E(r.internalFormat, f, g, r.colorSpace);
          I(l, r, p);
          const _ = r.mipmaps,
            T = a && !0 !== r.isVideoTexture,
            w = void 0 === d.__version || !0 === c,
            D = M(r, i, p);
          if (r.isDepthTexture)
            (v = t.DEPTH_COMPONENT),
              a
                ? (v =
                    1015 === r.type
                      ? t.DEPTH_COMPONENT32F
                      : 1014 === r.type
                      ? t.DEPTH_COMPONENT24
                      : 1020 === r.type
                      ? t.DEPTH24_STENCIL8
                      : t.DEPTH_COMPONENT16)
                : 1015 === r.type &&
                  console.error(
                    "WebGLRenderer: Floating point depth texture requires WebGL2."
                  ),
              1026 === r.format &&
                v === t.DEPTH_COMPONENT &&
                1012 !== r.type &&
                1014 !== r.type &&
                (console.warn(
                  "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
                ),
                (r.type = 1014),
                (g = s.convert(r.type))),
              1027 === r.format &&
                v === t.DEPTH_COMPONENT &&
                ((v = t.DEPTH_STENCIL),
                1020 !== r.type &&
                  (console.warn(
                    "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
                  ),
                  (r.type = 1020),
                  (g = s.convert(r.type)))),
              w &&
                (T
                  ? n.texStorage2D(t.TEXTURE_2D, 1, v, i.width, i.height)
                  : n.texImage2D(
                      t.TEXTURE_2D,
                      0,
                      v,
                      i.width,
                      i.height,
                      0,
                      f,
                      g,
                      null
                    ));
          else if (r.isDataTexture)
            if (_.length > 0 && p) {
              T &&
                w &&
                n.texStorage2D(t.TEXTURE_2D, D, v, _[0].width, _[0].height);
              for (let e = 0, i = _.length; e < i; e++)
                (m = _[e]),
                  T
                    ? n.texSubImage2D(
                        t.TEXTURE_2D,
                        e,
                        0,
                        0,
                        m.width,
                        m.height,
                        f,
                        g,
                        m.data
                      )
                    : n.texImage2D(
                        t.TEXTURE_2D,
                        e,
                        v,
                        m.width,
                        m.height,
                        0,
                        f,
                        g,
                        m.data
                      );
              r.generateMipmaps = !1;
            } else
              T
                ? (w && n.texStorage2D(t.TEXTURE_2D, D, v, i.width, i.height),
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    0,
                    0,
                    0,
                    i.width,
                    i.height,
                    f,
                    g,
                    i.data
                  ))
                : n.texImage2D(
                    t.TEXTURE_2D,
                    0,
                    v,
                    i.width,
                    i.height,
                    0,
                    f,
                    g,
                    i.data
                  );
          else if (r.isCompressedTexture)
            if (r.isCompressedArrayTexture) {
              T &&
                w &&
                n.texStorage3D(
                  t.TEXTURE_2D_ARRAY,
                  D,
                  v,
                  _[0].width,
                  _[0].height,
                  i.depth
                );
              for (let e = 0, s = _.length; e < s; e++)
                (m = _[e]),
                  1023 !== r.format
                    ? null !== f
                      ? T
                        ? n.compressedTexSubImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            0,
                            0,
                            0,
                            m.width,
                            m.height,
                            i.depth,
                            f,
                            m.data,
                            0,
                            0
                          )
                        : n.compressedTexImage3D(
                            t.TEXTURE_2D_ARRAY,
                            e,
                            v,
                            m.width,
                            m.height,
                            i.depth,
                            0,
                            m.data,
                            0,
                            0
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : T
                    ? n.texSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        e,
                        0,
                        0,
                        0,
                        m.width,
                        m.height,
                        i.depth,
                        f,
                        g,
                        m.data
                      )
                    : n.texImage3D(
                        t.TEXTURE_2D_ARRAY,
                        e,
                        v,
                        m.width,
                        m.height,
                        i.depth,
                        0,
                        f,
                        g,
                        m.data
                      );
            } else {
              T &&
                w &&
                n.texStorage2D(t.TEXTURE_2D, D, v, _[0].width, _[0].height);
              for (let e = 0, i = _.length; e < i; e++)
                (m = _[e]),
                  1023 !== r.format
                    ? null !== f
                      ? T
                        ? n.compressedTexSubImage2D(
                            t.TEXTURE_2D,
                            e,
                            0,
                            0,
                            m.width,
                            m.height,
                            f,
                            m.data
                          )
                        : n.compressedTexImage2D(
                            t.TEXTURE_2D,
                            e,
                            v,
                            m.width,
                            m.height,
                            0,
                            m.data
                          )
                      : console.warn(
                          "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                        )
                    : T
                    ? n.texSubImage2D(
                        t.TEXTURE_2D,
                        e,
                        0,
                        0,
                        m.width,
                        m.height,
                        f,
                        g,
                        m.data
                      )
                    : n.texImage2D(
                        t.TEXTURE_2D,
                        e,
                        v,
                        m.width,
                        m.height,
                        0,
                        f,
                        g,
                        m.data
                      );
            }
          else if (r.isDataArrayTexture)
            T
              ? (w &&
                  n.texStorage3D(
                    t.TEXTURE_2D_ARRAY,
                    D,
                    v,
                    i.width,
                    i.height,
                    i.depth
                  ),
                n.texSubImage3D(
                  t.TEXTURE_2D_ARRAY,
                  0,
                  0,
                  0,
                  0,
                  i.width,
                  i.height,
                  i.depth,
                  f,
                  g,
                  i.data
                ))
              : n.texImage3D(
                  t.TEXTURE_2D_ARRAY,
                  0,
                  v,
                  i.width,
                  i.height,
                  i.depth,
                  0,
                  f,
                  g,
                  i.data
                );
          else if (r.isData3DTexture)
            T
              ? (w &&
                  n.texStorage3D(
                    t.TEXTURE_3D,
                    D,
                    v,
                    i.width,
                    i.height,
                    i.depth
                  ),
                n.texSubImage3D(
                  t.TEXTURE_3D,
                  0,
                  0,
                  0,
                  0,
                  i.width,
                  i.height,
                  i.depth,
                  f,
                  g,
                  i.data
                ))
              : n.texImage3D(
                  t.TEXTURE_3D,
                  0,
                  v,
                  i.width,
                  i.height,
                  i.depth,
                  0,
                  f,
                  g,
                  i.data
                );
          else if (r.isFramebufferTexture) {
            if (w)
              if (T) n.texStorage2D(t.TEXTURE_2D, D, v, i.width, i.height);
              else {
                let e = i.width,
                  r = i.height;
                for (let i = 0; i < D; i++)
                  n.texImage2D(t.TEXTURE_2D, i, v, e, r, 0, f, g, null),
                    (e >>= 1),
                    (r >>= 1);
              }
          } else if (_.length > 0 && p) {
            T &&
              w &&
              n.texStorage2D(t.TEXTURE_2D, D, v, _[0].width, _[0].height);
            for (let e = 0, i = _.length; e < i; e++)
              (m = _[e]),
                T
                  ? n.texSubImage2D(t.TEXTURE_2D, e, 0, 0, f, g, m)
                  : n.texImage2D(t.TEXTURE_2D, e, v, f, g, m);
            r.generateMipmaps = !1;
          } else
            T
              ? (w && n.texStorage2D(t.TEXTURE_2D, D, v, i.width, i.height),
                n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, f, g, i))
              : n.texImage2D(t.TEXTURE_2D, 0, v, f, g, i);
          b(r, p) && S(l),
            (d.__version = h.version),
            r.onUpdate && r.onUpdate(r);
        }
        e.__version = r.version;
      }
      function N(e, r, o, a, l, c) {
        const u = s.convert(o.format, o.colorSpace),
          h = s.convert(o.type),
          p = E(o.internalFormat, u, h, o.colorSpace);
        if (!i.get(r).__hasExternalTextures) {
          const e = Math.max(1, r.width >> c),
            i = Math.max(1, r.height >> c);
          l === t.TEXTURE_3D || l === t.TEXTURE_2D_ARRAY
            ? n.texImage3D(l, c, p, e, i, r.depth, 0, u, h, null)
            : n.texImage2D(l, c, p, e, i, 0, u, h, null);
        }
        n.bindFramebuffer(t.FRAMEBUFFER, e),
          H(r)
            ? d.framebufferTexture2DMultisampleEXT(
                t.FRAMEBUFFER,
                a,
                l,
                i.get(o).__webglTexture,
                0,
                B(r)
              )
            : (l === t.TEXTURE_2D ||
                (l >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
                  l <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
              t.framebufferTexture2D(
                t.FRAMEBUFFER,
                a,
                l,
                i.get(o).__webglTexture,
                c
              ),
          n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
      function k(e, n, i) {
        if (
          (t.bindRenderbuffer(t.RENDERBUFFER, e),
          n.depthBuffer && !n.stencilBuffer)
        ) {
          let r = t.DEPTH_COMPONENT16;
          if (i || H(n)) {
            const e = n.depthTexture;
            e &&
              e.isDepthTexture &&
              (1015 === e.type
                ? (r = t.DEPTH_COMPONENT32F)
                : 1014 === e.type && (r = t.DEPTH_COMPONENT24));
            const i = B(n);
            H(n)
              ? d.renderbufferStorageMultisampleEXT(
                  t.RENDERBUFFER,
                  i,
                  r,
                  n.width,
                  n.height
                )
              : t.renderbufferStorageMultisample(
                  t.RENDERBUFFER,
                  i,
                  r,
                  n.width,
                  n.height
                );
          } else t.renderbufferStorage(t.RENDERBUFFER, r, n.width, n.height);
          t.framebufferRenderbuffer(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.RENDERBUFFER,
            e
          );
        } else if (n.depthBuffer && n.stencilBuffer) {
          const r = B(n);
          i && !1 === H(n)
            ? t.renderbufferStorageMultisample(
                t.RENDERBUFFER,
                r,
                t.DEPTH24_STENCIL8,
                n.width,
                n.height
              )
            : H(n)
            ? d.renderbufferStorageMultisampleEXT(
                t.RENDERBUFFER,
                r,
                t.DEPTH24_STENCIL8,
                n.width,
                n.height
              )
            : t.renderbufferStorage(
                t.RENDERBUFFER,
                t.DEPTH_STENCIL,
                n.width,
                n.height
              ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.DEPTH_STENCIL_ATTACHMENT,
              t.RENDERBUFFER,
              e
            );
        } else {
          const e =
            !0 === n.isWebGLMultipleRenderTargets ? n.texture : [n.texture];
          for (let r = 0; r < e.length; r++) {
            const o = e[r],
              a = s.convert(o.format, o.colorSpace),
              l = s.convert(o.type),
              c = E(o.internalFormat, a, l, o.colorSpace),
              u = B(n);
            i && !1 === H(n)
              ? t.renderbufferStorageMultisample(
                  t.RENDERBUFFER,
                  u,
                  c,
                  n.width,
                  n.height
                )
              : H(n)
              ? d.renderbufferStorageMultisampleEXT(
                  t.RENDERBUFFER,
                  u,
                  c,
                  n.width,
                  n.height
                )
              : t.renderbufferStorage(t.RENDERBUFFER, c, n.width, n.height);
          }
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null);
      }
      function z(e) {
        const r = i.get(e),
          s = !0 === e.isWebGLCubeRenderTarget;
        if (e.depthTexture && !r.__autoAllocateDepthBuffer) {
          if (s)
            throw new Error(
              "target.depthTexture not supported in Cube render targets"
            );
          !(function (e, r) {
            if (r && r.isWebGLCubeRenderTarget)
              throw new Error(
                "Depth Texture with cube render targets is not supported"
              );
            if (
              (n.bindFramebuffer(t.FRAMEBUFFER, e),
              !r.depthTexture || !r.depthTexture.isDepthTexture)
            )
              throw new Error(
                "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
              );
            (i.get(r.depthTexture).__webglTexture &&
              r.depthTexture.image.width === r.width &&
              r.depthTexture.image.height === r.height) ||
              ((r.depthTexture.image.width = r.width),
              (r.depthTexture.image.height = r.height),
              (r.depthTexture.needsUpdate = !0)),
              P(r.depthTexture, 0);
            const s = i.get(r.depthTexture).__webglTexture,
              o = B(r);
            if (1026 === r.depthTexture.format)
              H(r)
                ? d.framebufferTexture2DMultisampleEXT(
                    t.FRAMEBUFFER,
                    t.DEPTH_ATTACHMENT,
                    t.TEXTURE_2D,
                    s,
                    0,
                    o
                  )
                : t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    t.DEPTH_ATTACHMENT,
                    t.TEXTURE_2D,
                    s,
                    0
                  );
            else {
              if (1027 !== r.depthTexture.format)
                throw new Error("Unknown depthTexture format");
              H(r)
                ? d.framebufferTexture2DMultisampleEXT(
                    t.FRAMEBUFFER,
                    t.DEPTH_STENCIL_ATTACHMENT,
                    t.TEXTURE_2D,
                    s,
                    0,
                    o
                  )
                : t.framebufferTexture2D(
                    t.FRAMEBUFFER,
                    t.DEPTH_STENCIL_ATTACHMENT,
                    t.TEXTURE_2D,
                    s,
                    0
                  );
            }
          })(r.__webglFramebuffer, e);
        } else if (s) {
          r.__webglDepthbuffer = [];
          for (let i = 0; i < 6; i++)
            n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer[i]),
              (r.__webglDepthbuffer[i] = t.createRenderbuffer()),
              k(r.__webglDepthbuffer[i], e, !1);
        } else
          n.bindFramebuffer(t.FRAMEBUFFER, r.__webglFramebuffer),
            (r.__webglDepthbuffer = t.createRenderbuffer()),
            k(r.__webglDepthbuffer, e, !1);
        n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
      function B(t) {
        return Math.min(h, t.samples);
      }
      function H(t) {
        const n = i.get(t);
        return (
          a &&
          t.samples > 0 &&
          !0 === e.has("WEBGL_multisampled_render_to_texture") &&
          !1 !== n.__useRenderToTexture
        );
      }
      function V(t, n) {
        const i = t.colorSpace,
          r = t.format,
          s = t.type;
        return (
          !0 === t.isCompressedTexture ||
            1035 === t.format ||
            ("srgb-linear" !== i &&
              "" !== i &&
              ("srgb" === i
                ? !1 === a
                  ? !0 === e.has("EXT_sRGB") && 1023 === r
                    ? ((t.format = 1035),
                      (t.minFilter = 1006),
                      (t.generateMipmaps = !1))
                    : (n = id.sRGBToLinear(n))
                  : (1023 === r && 1009 === s) ||
                    console.warn(
                      "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                    )
                : console.error(
                    "THREE.WebGLTextures: Unsupported texture color space:",
                    i
                  ))),
          n
        );
      }
      (this.allocateTextureUnit = function () {
        const t = C;
        return (
          t >= l &&
            console.warn(
              "THREE.WebGLTextures: Trying to use " +
                t +
                " texture units while this GPU supports only " +
                l
            ),
          (C += 1),
          t
        );
      }),
        (this.resetTextureUnits = function () {
          C = 0;
        }),
        (this.setTexture2D = P),
        (this.setTexture2DArray = function (e, r) {
          const s = i.get(e);
          e.version > 0 && s.__version !== e.version
            ? U(s, e, r)
            : n.bindTexture(
                t.TEXTURE_2D_ARRAY,
                s.__webglTexture,
                t.TEXTURE0 + r
              );
        }),
        (this.setTexture3D = function (e, r) {
          const s = i.get(e);
          e.version > 0 && s.__version !== e.version
            ? U(s, e, r)
            : n.bindTexture(t.TEXTURE_3D, s.__webglTexture, t.TEXTURE0 + r);
        }),
        (this.setTextureCube = function (e, r) {
          const o = i.get(e);
          e.version > 0 && o.__version !== e.version
            ? (function (e, r, o) {
                if (6 !== r.image.length) return;
                const l = F(e, r),
                  u = r.source;
                n.bindTexture(
                  t.TEXTURE_CUBE_MAP,
                  e.__webglTexture,
                  t.TEXTURE0 + o
                );
                const h = i.get(u);
                if (u.version !== h.__version || !0 === l) {
                  n.activeTexture(t.TEXTURE0 + o),
                    t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, r.flipY),
                    t.pixelStorei(
                      t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                      r.premultiplyAlpha
                    ),
                    t.pixelStorei(t.UNPACK_ALIGNMENT, r.unpackAlignment),
                    t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, t.NONE);
                  const e =
                      r.isCompressedTexture || r.image[0].isCompressedTexture,
                    i = r.image[0] && r.image[0].isDataTexture,
                    d = [];
                  for (let t = 0; t < 6; t++)
                    (d[t] =
                      e || i
                        ? i
                          ? r.image[t].image
                          : r.image[t]
                        : y(r.image[t], !1, !0, c)),
                      (d[t] = V(r, d[t]));
                  const p = d[0],
                    f = x(p) || a,
                    m = s.convert(r.format, r.colorSpace),
                    g = s.convert(r.type),
                    v = E(r.internalFormat, m, g, r.colorSpace),
                    _ = a && !0 !== r.isVideoTexture,
                    T = void 0 === h.__version || !0 === l;
                  let w,
                    D = M(r, p, f);
                  if ((I(t.TEXTURE_CUBE_MAP, r, f), e)) {
                    _ &&
                      T &&
                      n.texStorage2D(
                        t.TEXTURE_CUBE_MAP,
                        D,
                        v,
                        p.width,
                        p.height
                      );
                    for (let e = 0; e < 6; e++) {
                      w = d[e].mipmaps;
                      for (let i = 0; i < w.length; i++) {
                        const s = w[i];
                        1023 !== r.format
                          ? null !== m
                            ? _
                              ? n.compressedTexSubImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  0,
                                  0,
                                  s.width,
                                  s.height,
                                  m,
                                  s.data
                                )
                              : n.compressedTexImage2D(
                                  t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                  i,
                                  v,
                                  s.width,
                                  s.height,
                                  0,
                                  s.data
                                )
                            : console.warn(
                                "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                              )
                          : _
                          ? n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i,
                              0,
                              0,
                              s.width,
                              s.height,
                              m,
                              g,
                              s.data
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              i,
                              v,
                              s.width,
                              s.height,
                              0,
                              m,
                              g,
                              s.data
                            );
                      }
                    }
                  } else {
                    (w = r.mipmaps),
                      _ &&
                        T &&
                        (w.length > 0 && D++,
                        n.texStorage2D(
                          t.TEXTURE_CUBE_MAP,
                          D,
                          v,
                          d[0].width,
                          d[0].height
                        ));
                    for (let e = 0; e < 6; e++)
                      if (i) {
                        _
                          ? n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              0,
                              0,
                              0,
                              d[e].width,
                              d[e].height,
                              m,
                              g,
                              d[e].data
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              0,
                              v,
                              d[e].width,
                              d[e].height,
                              0,
                              m,
                              g,
                              d[e].data
                            );
                        for (let i = 0; i < w.length; i++) {
                          const r = w[i].image[e].image;
                          _
                            ? n.texSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i + 1,
                                0,
                                0,
                                r.width,
                                r.height,
                                m,
                                g,
                                r.data
                              )
                            : n.texImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i + 1,
                                v,
                                r.width,
                                r.height,
                                0,
                                m,
                                g,
                                r.data
                              );
                        }
                      } else {
                        _
                          ? n.texSubImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              0,
                              0,
                              0,
                              m,
                              g,
                              d[e]
                            )
                          : n.texImage2D(
                              t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                              0,
                              v,
                              m,
                              g,
                              d[e]
                            );
                        for (let i = 0; i < w.length; i++) {
                          const r = w[i];
                          _
                            ? n.texSubImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i + 1,
                                0,
                                0,
                                m,
                                g,
                                r.image[e]
                              )
                            : n.texImage2D(
                                t.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                                i + 1,
                                v,
                                m,
                                g,
                                r.image[e]
                              );
                        }
                      }
                  }
                  b(r, f) && S(t.TEXTURE_CUBE_MAP),
                    (h.__version = u.version),
                    r.onUpdate && r.onUpdate(r);
                }
                e.__version = r.version;
              })(o, e, r)
            : n.bindTexture(
                t.TEXTURE_CUBE_MAP,
                o.__webglTexture,
                t.TEXTURE0 + r
              );
        }),
        (this.rebindTextures = function (e, n, r) {
          const s = i.get(e);
          void 0 !== n &&
            N(
              s.__webglFramebuffer,
              e,
              e.texture,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_2D,
              0
            ),
            void 0 !== r && z(e);
        }),
        (this.setupRenderTarget = function (e) {
          const l = e.texture,
            c = i.get(e),
            u = i.get(l);
          e.addEventListener("dispose", D),
            !0 !== e.isWebGLMultipleRenderTargets &&
              (void 0 === u.__webglTexture &&
                (u.__webglTexture = t.createTexture()),
              (u.__version = l.version),
              o.memory.textures++);
          const h = !0 === e.isWebGLCubeRenderTarget,
            d = !0 === e.isWebGLMultipleRenderTargets,
            p = x(e) || a;
          if (h) {
            c.__webglFramebuffer = [];
            for (let e = 0; e < 6; e++)
              if (a && l.mipmaps && l.mipmaps.length > 0) {
                c.__webglFramebuffer[e] = [];
                for (let n = 0; n < l.mipmaps.length; n++)
                  c.__webglFramebuffer[e][n] = t.createFramebuffer();
              } else c.__webglFramebuffer[e] = t.createFramebuffer();
          } else {
            if (a && l.mipmaps && l.mipmaps.length > 0) {
              c.__webglFramebuffer = [];
              for (let e = 0; e < l.mipmaps.length; e++)
                c.__webglFramebuffer[e] = t.createFramebuffer();
            } else c.__webglFramebuffer = t.createFramebuffer();
            if (d)
              if (r.drawBuffers) {
                const n = e.texture;
                for (let e = 0, r = n.length; e < r; e++) {
                  const r = i.get(n[e]);
                  void 0 === r.__webglTexture &&
                    ((r.__webglTexture = t.createTexture()),
                    o.memory.textures++);
                }
              } else
                console.warn(
                  "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
                );
            if (a && e.samples > 0 && !1 === H(e)) {
              const i = d ? l : [l];
              (c.__webglMultisampledFramebuffer = t.createFramebuffer()),
                (c.__webglColorRenderbuffer = []),
                n.bindFramebuffer(
                  t.FRAMEBUFFER,
                  c.__webglMultisampledFramebuffer
                );
              for (let n = 0; n < i.length; n++) {
                const r = i[n];
                (c.__webglColorRenderbuffer[n] = t.createRenderbuffer()),
                  t.bindRenderbuffer(
                    t.RENDERBUFFER,
                    c.__webglColorRenderbuffer[n]
                  );
                const o = s.convert(r.format, r.colorSpace),
                  a = s.convert(r.type),
                  l = E(
                    r.internalFormat,
                    o,
                    a,
                    r.colorSpace,
                    !0 === e.isXRRenderTarget
                  ),
                  u = B(e);
                t.renderbufferStorageMultisample(
                  t.RENDERBUFFER,
                  u,
                  l,
                  e.width,
                  e.height
                ),
                  t.framebufferRenderbuffer(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + n,
                    t.RENDERBUFFER,
                    c.__webglColorRenderbuffer[n]
                  );
              }
              t.bindRenderbuffer(t.RENDERBUFFER, null),
                e.depthBuffer &&
                  ((c.__webglDepthRenderbuffer = t.createRenderbuffer()),
                  k(c.__webglDepthRenderbuffer, e, !0)),
                n.bindFramebuffer(t.FRAMEBUFFER, null);
            }
          }
          if (h) {
            n.bindTexture(t.TEXTURE_CUBE_MAP, u.__webglTexture),
              I(t.TEXTURE_CUBE_MAP, l, p);
            for (let n = 0; n < 6; n++)
              if (a && l.mipmaps && l.mipmaps.length > 0)
                for (let i = 0; i < l.mipmaps.length; i++)
                  N(
                    c.__webglFramebuffer[n][i],
                    e,
                    l,
                    t.COLOR_ATTACHMENT0,
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                    i
                  );
              else
                N(
                  c.__webglFramebuffer[n],
                  e,
                  l,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                  0
                );
            b(l, p) && S(t.TEXTURE_CUBE_MAP), n.unbindTexture();
          } else if (d) {
            const r = e.texture;
            for (let s = 0, o = r.length; s < o; s++) {
              const o = r[s],
                a = i.get(o);
              n.bindTexture(t.TEXTURE_2D, a.__webglTexture),
                I(t.TEXTURE_2D, o, p),
                N(
                  c.__webglFramebuffer,
                  e,
                  o,
                  t.COLOR_ATTACHMENT0 + s,
                  t.TEXTURE_2D,
                  0
                ),
                b(o, p) && S(t.TEXTURE_2D);
            }
            n.unbindTexture();
          } else {
            let i = t.TEXTURE_2D;
            if (
              ((e.isWebGL3DRenderTarget || e.isWebGLArrayRenderTarget) &&
                (a
                  ? (i = e.isWebGL3DRenderTarget
                      ? t.TEXTURE_3D
                      : t.TEXTURE_2D_ARRAY)
                  : console.error(
                      "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                    )),
              n.bindTexture(i, u.__webglTexture),
              I(i, l, p),
              a && l.mipmaps && l.mipmaps.length > 0)
            )
              for (let n = 0; n < l.mipmaps.length; n++)
                N(c.__webglFramebuffer[n], e, l, t.COLOR_ATTACHMENT0, i, n);
            else N(c.__webglFramebuffer, e, l, t.COLOR_ATTACHMENT0, i, 0);
            b(l, p) && S(i), n.unbindTexture();
          }
          e.depthBuffer && z(e);
        }),
        (this.updateRenderTargetMipmap = function (e) {
          const r = x(e) || a,
            s = !0 === e.isWebGLMultipleRenderTargets ? e.texture : [e.texture];
          for (let o = 0, a = s.length; o < a; o++) {
            const a = s[o];
            if (b(a, r)) {
              const r = e.isWebGLCubeRenderTarget
                  ? t.TEXTURE_CUBE_MAP
                  : t.TEXTURE_2D,
                s = i.get(a).__webglTexture;
              n.bindTexture(r, s), S(r), n.unbindTexture();
            }
          }
        }),
        (this.updateMultisampleRenderTarget = function (e) {
          if (a && e.samples > 0 && !1 === H(e)) {
            const r = e.isWebGLMultipleRenderTargets ? e.texture : [e.texture],
              s = e.width,
              o = e.height;
            let a = t.COLOR_BUFFER_BIT;
            const l = [],
              c = e.stencilBuffer
                ? t.DEPTH_STENCIL_ATTACHMENT
                : t.DEPTH_ATTACHMENT,
              u = i.get(e),
              h = !0 === e.isWebGLMultipleRenderTargets;
            if (h)
              for (let e = 0; e < r.length; e++)
                n.bindFramebuffer(
                  t.FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                ),
                  t.framebufferRenderbuffer(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.RENDERBUFFER,
                    null
                  ),
                  n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                  t.framebufferTexture2D(
                    t.DRAW_FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.TEXTURE_2D,
                    null,
                    0
                  );
            n.bindFramebuffer(
              t.READ_FRAMEBUFFER,
              u.__webglMultisampledFramebuffer
            ),
              n.bindFramebuffer(t.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
            for (let n = 0; n < r.length; n++) {
              l.push(t.COLOR_ATTACHMENT0 + n), e.depthBuffer && l.push(c);
              const d =
                void 0 !== u.__ignoreDepthValues && u.__ignoreDepthValues;
              if (
                (!1 === d &&
                  (e.depthBuffer && (a |= t.DEPTH_BUFFER_BIT),
                  e.stencilBuffer && (a |= t.STENCIL_BUFFER_BIT)),
                h &&
                  t.framebufferRenderbuffer(
                    t.READ_FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0,
                    t.RENDERBUFFER,
                    u.__webglColorRenderbuffer[n]
                  ),
                !0 === d &&
                  (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [c]),
                  t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [c])),
                h)
              ) {
                const e = i.get(r[n]).__webglTexture;
                t.framebufferTexture2D(
                  t.DRAW_FRAMEBUFFER,
                  t.COLOR_ATTACHMENT0,
                  t.TEXTURE_2D,
                  e,
                  0
                );
              }
              t.blitFramebuffer(0, 0, s, o, 0, 0, s, o, a, t.NEAREST),
                p && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, l);
            }
            if (
              (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
              n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
              h)
            )
              for (let e = 0; e < r.length; e++) {
                n.bindFramebuffer(
                  t.FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                ),
                  t.framebufferRenderbuffer(
                    t.FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.RENDERBUFFER,
                    u.__webglColorRenderbuffer[e]
                  );
                const s = i.get(r[e]).__webglTexture;
                n.bindFramebuffer(t.FRAMEBUFFER, u.__webglFramebuffer),
                  t.framebufferTexture2D(
                    t.DRAW_FRAMEBUFFER,
                    t.COLOR_ATTACHMENT0 + e,
                    t.TEXTURE_2D,
                    s,
                    0
                  );
              }
            n.bindFramebuffer(
              t.DRAW_FRAMEBUFFER,
              u.__webglMultisampledFramebuffer
            );
          }
        }),
        (this.setupDepthRenderbuffer = z),
        (this.setupFrameBufferTexture = N),
        (this.useMultisampledRTT = H);
    }
    function sv(t, e, n) {
      const i = n.isWebGL2;
      return {
        convert: function (n, r = "") {
          let s;
          if (1009 === n) return t.UNSIGNED_BYTE;
          if (1017 === n) return t.UNSIGNED_SHORT_4_4_4_4;
          if (1018 === n) return t.UNSIGNED_SHORT_5_5_5_1;
          if (1010 === n) return t.BYTE;
          if (1011 === n) return t.SHORT;
          if (1012 === n) return t.UNSIGNED_SHORT;
          if (1013 === n) return t.INT;
          if (1014 === n) return t.UNSIGNED_INT;
          if (1015 === n) return t.FLOAT;
          if (1016 === n)
            return i
              ? t.HALF_FLOAT
              : ((s = e.get("OES_texture_half_float")),
                null !== s ? s.HALF_FLOAT_OES : null);
          if (1021 === n) return t.ALPHA;
          if (1023 === n) return t.RGBA;
          if (1024 === n) return t.LUMINANCE;
          if (1025 === n) return t.LUMINANCE_ALPHA;
          if (1026 === n) return t.DEPTH_COMPONENT;
          if (1027 === n) return t.DEPTH_STENCIL;
          if (1035 === n)
            return (
              (s = e.get("EXT_sRGB")), null !== s ? s.SRGB_ALPHA_EXT : null
            );
          if (1028 === n) return t.RED;
          if (1029 === n) return t.RED_INTEGER;
          if (1030 === n) return t.RG;
          if (1031 === n) return t.RG_INTEGER;
          if (1033 === n) return t.RGBA_INTEGER;
          if (33776 === n || 33777 === n || 33778 === n || 33779 === n)
            if ("srgb" === r) {
              if (
                ((s = e.get("WEBGL_compressed_texture_s3tc_srgb")), null === s)
              )
                return null;
              if (33776 === n) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              if (33777 === n) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (33778 === n) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (33779 === n) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else {
              if (((s = e.get("WEBGL_compressed_texture_s3tc")), null === s))
                return null;
              if (33776 === n) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (33777 === n) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (33778 === n) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (33779 === n) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }
          if (35840 === n || 35841 === n || 35842 === n || 35843 === n) {
            if (((s = e.get("WEBGL_compressed_texture_pvrtc")), null === s))
              return null;
            if (35840 === n) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (35841 === n) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (35842 === n) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (35843 === n) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          }
          if (36196 === n)
            return (
              (s = e.get("WEBGL_compressed_texture_etc1")),
              null !== s ? s.COMPRESSED_RGB_ETC1_WEBGL : null
            );
          if (37492 === n || 37496 === n) {
            if (((s = e.get("WEBGL_compressed_texture_etc")), null === s))
              return null;
            if (37492 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ETC2
                : s.COMPRESSED_RGB8_ETC2;
            if (37496 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                : s.COMPRESSED_RGBA8_ETC2_EAC;
          }
          if (
            37808 === n ||
            37809 === n ||
            37810 === n ||
            37811 === n ||
            37812 === n ||
            37813 === n ||
            37814 === n ||
            37815 === n ||
            37816 === n ||
            37817 === n ||
            37818 === n ||
            37819 === n ||
            37820 === n ||
            37821 === n
          ) {
            if (((s = e.get("WEBGL_compressed_texture_astc")), null === s))
              return null;
            if (37808 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (37809 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (37810 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (37811 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (37812 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (37813 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (37814 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (37815 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (37816 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (37817 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (37818 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (37819 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (37820 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (37821 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                : s.COMPRESSED_RGBA_ASTC_12x12_KHR;
          }
          if (36492 === n) {
            if (((s = e.get("EXT_texture_compression_bptc")), null === s))
              return null;
            if (36492 === n)
              return "srgb" === r
                ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          }
          if (36283 === n || 36284 === n || 36285 === n || 36286 === n) {
            if (((s = e.get("EXT_texture_compression_rgtc")), null === s))
              return null;
            if (36492 === n) return s.COMPRESSED_RED_RGTC1_EXT;
            if (36284 === n) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (36285 === n) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (36286 === n) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          }
          return 1020 === n
            ? i
              ? t.UNSIGNED_INT_24_8
              : ((s = e.get("WEBGL_depth_texture")),
                null !== s ? s.UNSIGNED_INT_24_8_WEBGL : null)
            : void 0 !== t[n]
            ? t[n]
            : null;
        },
      };
    }
    class ov extends Tf {
      constructor(t = []) {
        super(), (this.isArrayCamera = !0), (this.cameras = t);
      }
    }
    class av extends gp {
      constructor() {
        super(), (this.isGroup = !0), (this.type = "Group");
      }
    }
    const lv = {
      type: "move",
    };
    class cv {
      constructor() {
        (this._targetRay = null), (this._grip = null), (this._hand = null);
      }
      getHandSpace() {
        return (
          null === this._hand &&
            ((this._hand = new av()),
            (this._hand.matrixAutoUpdate = !1),
            (this._hand.visible = !1),
            (this._hand.joints = {}),
            (this._hand.inputState = {
              pinching: !1,
            })),
          this._hand
        );
      }
      getTargetRaySpace() {
        return (
          null === this._targetRay &&
            ((this._targetRay = new av()),
            (this._targetRay.matrixAutoUpdate = !1),
            (this._targetRay.visible = !1),
            (this._targetRay.hasLinearVelocity = !1),
            (this._targetRay.linearVelocity = new md()),
            (this._targetRay.hasAngularVelocity = !1),
            (this._targetRay.angularVelocity = new md())),
          this._targetRay
        );
      }
      getGripSpace() {
        return (
          null === this._grip &&
            ((this._grip = new av()),
            (this._grip.matrixAutoUpdate = !1),
            (this._grip.visible = !1),
            (this._grip.hasLinearVelocity = !1),
            (this._grip.linearVelocity = new md()),
            (this._grip.hasAngularVelocity = !1),
            (this._grip.angularVelocity = new md())),
          this._grip
        );
      }
      dispatchEvent(t) {
        return (
          null !== this._targetRay && this._targetRay.dispatchEvent(t),
          null !== this._grip && this._grip.dispatchEvent(t),
          null !== this._hand && this._hand.dispatchEvent(t),
          this
        );
      }
      connect(t) {
        if (t && t.hand) {
          const e = this._hand;
          if (e) for (const n of t.hand.values()) this._getHandJoint(e, n);
        }
        return (
          this.dispatchEvent({
            type: "connected",
            data: t,
          }),
          this
        );
      }
      disconnect(t) {
        return (
          this.dispatchEvent({
            type: "disconnected",
            data: t,
          }),
          null !== this._targetRay && (this._targetRay.visible = !1),
          null !== this._grip && (this._grip.visible = !1),
          null !== this._hand && (this._hand.visible = !1),
          this
        );
      }
      update(t, e, n) {
        let i = null,
          r = null,
          s = null;
        const o = this._targetRay,
          a = this._grip,
          l = this._hand;
        if (t && "visible-blurred" !== e.session.visibilityState) {
          if (l && t.hand) {
            s = !0;
            for (const i of t.hand.values()) {
              const t = e.getJointPose(i, n),
                r = this._getHandJoint(l, i);
              null !== t &&
                (r.matrix.fromArray(t.transform.matrix),
                r.matrix.decompose(r.position, r.rotation, r.scale),
                (r.matrixWorldNeedsUpdate = !0),
                (r.jointRadius = t.radius)),
                (r.visible = null !== t);
            }
            const i = l.joints["index-finger-tip"],
              r = l.joints["thumb-tip"],
              o = i.position.distanceTo(r.position),
              a = 0.02,
              c = 0.005;
            l.inputState.pinching && o > a + c
              ? ((l.inputState.pinching = !1),
                this.dispatchEvent({
                  type: "pinchend",
                  handedness: t.handedness,
                  target: this,
                }))
              : !l.inputState.pinching &&
                o <= a - c &&
                ((l.inputState.pinching = !0),
                this.dispatchEvent({
                  type: "pinchstart",
                  handedness: t.handedness,
                  target: this,
                }));
          } else
            null !== a &&
              t.gripSpace &&
              ((r = e.getPose(t.gripSpace, n)),
              null !== r &&
                (a.matrix.fromArray(r.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                (a.matrixWorldNeedsUpdate = !0),
                r.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(r.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                r.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(r.angularVelocity))
                  : (a.hasAngularVelocity = !1)));
          null !== o &&
            ((i = e.getPose(t.targetRaySpace, n)),
            null === i && null !== r && (i = r),
            null !== i &&
              (o.matrix.fromArray(i.transform.matrix),
              o.matrix.decompose(o.position, o.rotation, o.scale),
              (o.matrixWorldNeedsUpdate = !0),
              i.linearVelocity
                ? ((o.hasLinearVelocity = !0),
                  o.linearVelocity.copy(i.linearVelocity))
                : (o.hasLinearVelocity = !1),
              i.angularVelocity
                ? ((o.hasAngularVelocity = !0),
                  o.angularVelocity.copy(i.angularVelocity))
                : (o.hasAngularVelocity = !1),
              this.dispatchEvent(lv)));
        }
        return (
          null !== o && (o.visible = null !== i),
          null !== a && (a.visible = null !== r),
          null !== l && (l.visible = null !== s),
          this
        );
      }
      _getHandJoint(t, e) {
        if (void 0 === t.joints[e.jointName]) {
          const n = new av();
          (n.matrixAutoUpdate = !1),
            (n.visible = !1),
            (t.joints[e.jointName] = n),
            t.add(n);
        }
        return t.joints[e.jointName];
      }
    }
    class uv extends ld {
      constructor(t, e, n, i, r, s, o, a, l, c) {
        if (1026 !== (c = void 0 !== c ? c : 1026) && 1027 !== c)
          throw new Error(
            "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
          );
        void 0 === n && 1026 === c && (n = 1014),
          void 0 === n && 1027 === c && (n = 1020),
          super(null, i, r, s, o, a, c, n, l),
          (this.isDepthTexture = !0),
          (this.image = {
            width: t,
            height: e,
          }),
          (this.magFilter = void 0 !== o ? o : 1003),
          (this.minFilter = void 0 !== a ? a : 1003),
          (this.flipY = !1),
          (this.generateMipmaps = !1),
          (this.compareFunction = null);
      }
      copy(t) {
        return super.copy(t), (this.compareFunction = t.compareFunction), this;
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          null !== this.compareFunction &&
            (e.compareFunction = this.compareFunction),
          e
        );
      }
    }
    class hv extends Ph {
      constructor(t, e) {
        super();
        const n = this;
        let i = null,
          r = 1,
          s = null,
          o = "local-floor",
          a = 1,
          l = null,
          c = null,
          u = null,
          h = null,
          d = null,
          p = null;
        const f = e.getContextAttributes();
        let m = null,
          g = null;
        const v = [],
          _ = [],
          y = new Tf();
        y.layers.enable(1), (y.viewport = new cd());
        const x = new Tf();
        x.layers.enable(2), (x.viewport = new cd());
        const b = [y, x],
          S = new ov();
        S.layers.enable(1), S.layers.enable(2);
        let E = null,
          M = null;
        function T(t) {
          const e = _.indexOf(t.inputSource);
          if (-1 === e) return;
          const n = v[e];
          void 0 !== n &&
            (n.update(t.inputSource, t.frame, l || s),
            n.dispatchEvent({
              type: t.type,
              data: t.inputSource,
            }));
        }
        function w() {
          i.removeEventListener("select", T),
            i.removeEventListener("selectstart", T),
            i.removeEventListener("selectend", T),
            i.removeEventListener("squeeze", T),
            i.removeEventListener("squeezestart", T),
            i.removeEventListener("squeezeend", T),
            i.removeEventListener("end", w),
            i.removeEventListener("inputsourceschange", D);
          for (let t = 0; t < v.length; t++) {
            const e = _[t];
            null !== e && ((_[t] = null), v[t].disconnect(e));
          }
          (E = null),
            (M = null),
            t.setRenderTarget(m),
            (d = null),
            (h = null),
            (u = null),
            (i = null),
            (g = null),
            L.stop(),
            (n.isPresenting = !1),
            n.dispatchEvent({
              type: "sessionend",
            });
        }
        function D(t) {
          for (let e = 0; e < t.removed.length; e++) {
            const n = t.removed[e],
              i = _.indexOf(n);
            i >= 0 && ((_[i] = null), v[i].disconnect(n));
          }
          for (let e = 0; e < t.added.length; e++) {
            const n = t.added[e];
            let i = _.indexOf(n);
            if (-1 === i) {
              for (let t = 0; t < v.length; t++) {
                if (t >= _.length) {
                  _.push(n), (i = t);
                  break;
                }
                if (null === _[t]) {
                  (_[t] = n), (i = t);
                  break;
                }
              }
              if (-1 === i) break;
            }
            const r = v[i];
            r && r.connect(n);
          }
        }
        (this.cameraAutoUpdate = !0),
          (this.enabled = !1),
          (this.isPresenting = !1),
          (this.getController = function (t) {
            let e = v[t];
            return (
              void 0 === e && ((e = new cv()), (v[t] = e)),
              e.getTargetRaySpace()
            );
          }),
          (this.getControllerGrip = function (t) {
            let e = v[t];
            return (
              void 0 === e && ((e = new cv()), (v[t] = e)), e.getGripSpace()
            );
          }),
          (this.getHand = function (t) {
            let e = v[t];
            return (
              void 0 === e && ((e = new cv()), (v[t] = e)), e.getHandSpace()
            );
          }),
          (this.setFramebufferScaleFactor = function (t) {
            (r = t),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                );
          }),
          (this.setReferenceSpaceType = function (t) {
            (o = t),
              !0 === n.isPresenting &&
                console.warn(
                  "THREE.WebXRManager: Cannot change reference space type while presenting."
                );
          }),
          (this.getReferenceSpace = function () {
            return l || s;
          }),
          (this.setReferenceSpace = function (t) {
            l = t;
          }),
          (this.getBaseLayer = function () {
            return null !== h ? h : d;
          }),
          (this.getBinding = function () {
            return u;
          }),
          (this.getFrame = function () {
            return p;
          }),
          (this.getSession = function () {
            return i;
          }),
          (this.setSession = async function (c) {
            if (((i = c), null !== i)) {
              if (
                ((m = t.getRenderTarget()),
                i.addEventListener("select", T),
                i.addEventListener("selectstart", T),
                i.addEventListener("selectend", T),
                i.addEventListener("squeeze", T),
                i.addEventListener("squeezestart", T),
                i.addEventListener("squeezeend", T),
                i.addEventListener("end", w),
                i.addEventListener("inputsourceschange", D),
                !0 !== f.xrCompatible && (await e.makeXRCompatible()),
                void 0 === i.renderState.layers ||
                  !1 === t.capabilities.isWebGL2)
              ) {
                const n = {
                  antialias: void 0 !== i.renderState.layers || f.antialias,
                  alpha: !0,
                  depth: f.depth,
                  stencil: f.stencil,
                  framebufferScaleFactor: r,
                };
                (d = new XRWebGLLayer(i, e, n)),
                  i.updateRenderState({
                    baseLayer: d,
                  }),
                  (g = new hd(d.framebufferWidth, d.framebufferHeight, {
                    format: 1023,
                    type: 1009,
                    colorSpace: t.outputColorSpace,
                    stencilBuffer: f.stencil,
                  }));
              } else {
                let n = null,
                  s = null,
                  o = null;
                f.depth &&
                  ((o = f.stencil ? e.DEPTH24_STENCIL8 : e.DEPTH_COMPONENT24),
                  (n = f.stencil ? 1027 : 1026),
                  (s = f.stencil ? 1020 : 1014));
                const a = {
                  colorFormat: e.RGBA8,
                  depthFormat: o,
                  scaleFactor: r,
                };
                (u = new XRWebGLBinding(i, e)),
                  (h = u.createProjectionLayer(a)),
                  i.updateRenderState({
                    layers: [h],
                  }),
                  (g = new hd(h.textureWidth, h.textureHeight, {
                    format: 1023,
                    type: 1009,
                    depthTexture: new uv(
                      h.textureWidth,
                      h.textureHeight,
                      s,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      void 0,
                      n
                    ),
                    stencilBuffer: f.stencil,
                    colorSpace: t.outputColorSpace,
                    samples: f.antialias ? 4 : 0,
                  }));
                t.properties.get(g).__ignoreDepthValues = h.ignoreDepthValues;
              }
              (g.isXRRenderTarget = !0),
                this.setFoveation(a),
                (l = null),
                (s = await i.requestReferenceSpace(o)),
                L.setContext(i),
                L.start(),
                (n.isPresenting = !0),
                n.dispatchEvent({
                  type: "sessionstart",
                });
            }
          }),
          (this.getEnvironmentBlendMode = function () {
            if (null !== i) return i.environmentBlendMode;
          });
        const A = new md(),
          C = new md();
        function P(t, e) {
          null === e
            ? t.matrixWorld.copy(t.matrix)
            : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
            t.matrixWorldInverse.copy(t.matrixWorld).invert();
        }
        (this.updateCamera = function (t) {
          if (null === i) return;
          (S.near = x.near = y.near = t.near),
            (S.far = x.far = y.far = t.far),
            (E === S.near && M === S.far) ||
              (i.updateRenderState({
                depthNear: S.near,
                depthFar: S.far,
              }),
              (E = S.near),
              (M = S.far));
          const e = t.parent,
            n = S.cameras;
          P(S, e);
          for (let t = 0; t < n.length; t++) P(n[t], e);
          2 === n.length
            ? (function (t, e, n) {
                A.setFromMatrixPosition(e.matrixWorld),
                  C.setFromMatrixPosition(n.matrixWorld);
                const i = A.distanceTo(C),
                  r = e.projectionMatrix.elements,
                  s = n.projectionMatrix.elements,
                  o = r[14] / (r[10] - 1),
                  a = r[14] / (r[10] + 1),
                  l = (r[9] + 1) / r[5],
                  c = (r[9] - 1) / r[5],
                  u = (r[8] - 1) / r[0],
                  h = (s[8] + 1) / s[0],
                  d = o * u,
                  p = o * h,
                  f = i / (-u + h),
                  m = f * -u;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale),
                  t.translateX(m),
                  t.translateZ(f),
                  t.matrixWorld.compose(t.position, t.quaternion, t.scale),
                  t.matrixWorldInverse.copy(t.matrixWorld).invert();
                const g = o + f,
                  v = a + f,
                  _ = d - m,
                  y = p + (i - m),
                  x = ((l * a) / v) * g,
                  b = ((c * a) / v) * g;
                t.projectionMatrix.makePerspective(_, y, x, b, g, v),
                  t.projectionMatrixInverse.copy(t.projectionMatrix).invert();
              })(S, y, x)
            : S.projectionMatrix.copy(y.projectionMatrix),
            (function (t, e, n) {
              null === n
                ? t.matrix.copy(e.matrixWorld)
                : (t.matrix.copy(n.matrixWorld),
                  t.matrix.invert(),
                  t.matrix.multiply(e.matrixWorld));
              t.matrix.decompose(t.position, t.quaternion, t.scale),
                t.updateMatrixWorld(!0);
              const i = t.children;
              for (let t = 0, e = i.length; t < e; t++)
                i[t].updateMatrixWorld(!0);
              t.projectionMatrix.copy(e.projectionMatrix),
                t.projectionMatrixInverse.copy(e.projectionMatrixInverse),
                t.isPerspectiveCamera &&
                  ((t.fov =
                    2 * Oh * Math.atan(1 / t.projectionMatrix.elements[5])),
                  (t.zoom = 1));
            })(t, S, e);
        }),
          (this.getCamera = function () {
            return S;
          }),
          (this.getFoveation = function () {
            if (null !== h || null !== d) return a;
          }),
          (this.setFoveation = function (t) {
            (a = t),
              null !== h && (h.fixedFoveation = t),
              null !== d &&
                void 0 !== d.fixedFoveation &&
                (d.fixedFoveation = t);
          });
        let R = null;
        const L = new Uf();
        L.setAnimationLoop(function (e, i) {
          if (((c = i.getViewerPose(l || s)), (p = i), null !== c)) {
            const e = c.views;
            null !== d &&
              (t.setRenderTargetFramebuffer(g, d.framebuffer),
              t.setRenderTarget(g));
            let n = !1;
            e.length !== S.cameras.length && ((S.cameras.length = 0), (n = !0));
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              let s = null;
              if (null !== d) s = d.getViewport(r);
              else {
                const e = u.getViewSubImage(h, r);
                (s = e.viewport),
                  0 === i &&
                    (t.setRenderTargetTextures(
                      g,
                      e.colorTexture,
                      h.ignoreDepthValues ? void 0 : e.depthStencilTexture
                    ),
                    t.setRenderTarget(g));
              }
              let o = b[i];
              void 0 === o &&
                ((o = new Tf()),
                o.layers.enable(i),
                (o.viewport = new cd()),
                (b[i] = o)),
                o.matrix.fromArray(r.transform.matrix),
                o.matrix.decompose(o.position, o.quaternion, o.scale),
                o.projectionMatrix.fromArray(r.projectionMatrix),
                o.projectionMatrixInverse.copy(o.projectionMatrix).invert(),
                o.viewport.set(s.x, s.y, s.width, s.height),
                0 === i &&
                  (S.matrix.copy(o.matrix),
                  S.matrix.decompose(S.position, S.quaternion, S.scale)),
                !0 === n && S.cameras.push(o);
            }
          }
          for (let t = 0; t < v.length; t++) {
            const e = _[t],
              n = v[t];
            null !== e && void 0 !== n && n.update(e, i, l || s);
          }
          R && R(e, i),
            i.detectedPlanes &&
              n.dispatchEvent({
                type: "planesdetected",
                data: i,
              }),
            (p = null);
        }),
          (this.setAnimationLoop = function (t) {
            R = t;
          }),
          (this.dispose = function () {});
      }
    }
    function dv(t, e) {
      function n(t, e) {
        !0 === t.matrixAutoUpdate && t.updateMatrix(), e.value.copy(t.matrix);
      }
      function i(i, r) {
        (i.opacity.value = r.opacity),
          r.color && i.diffuse.value.copy(r.color),
          r.emissive &&
            i.emissive.value
              .copy(r.emissive)
              .multiplyScalar(r.emissiveIntensity),
          r.map && ((i.map.value = r.map), n(r.map, i.mapTransform)),
          r.alphaMap &&
            ((i.alphaMap.value = r.alphaMap),
            n(r.alphaMap, i.alphaMapTransform)),
          r.bumpMap &&
            ((i.bumpMap.value = r.bumpMap),
            n(r.bumpMap, i.bumpMapTransform),
            (i.bumpScale.value = r.bumpScale),
            1 === r.side && (i.bumpScale.value *= -1)),
          r.normalMap &&
            ((i.normalMap.value = r.normalMap),
            n(r.normalMap, i.normalMapTransform),
            i.normalScale.value.copy(r.normalScale),
            1 === r.side && i.normalScale.value.negate()),
          r.displacementMap &&
            ((i.displacementMap.value = r.displacementMap),
            n(r.displacementMap, i.displacementMapTransform),
            (i.displacementScale.value = r.displacementScale),
            (i.displacementBias.value = r.displacementBias)),
          r.emissiveMap &&
            ((i.emissiveMap.value = r.emissiveMap),
            n(r.emissiveMap, i.emissiveMapTransform)),
          r.specularMap &&
            ((i.specularMap.value = r.specularMap),
            n(r.specularMap, i.specularMapTransform)),
          r.alphaTest > 0 && (i.alphaTest.value = r.alphaTest);
        const s = e.get(r).envMap;
        if (
          (s &&
            ((i.envMap.value = s),
            (i.flipEnvMap.value =
              s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
            (i.reflectivity.value = r.reflectivity),
            (i.ior.value = r.ior),
            (i.refractionRatio.value = r.refractionRatio)),
          r.lightMap)
        ) {
          i.lightMap.value = r.lightMap;
          const e = !0 === t._useLegacyLights ? Math.PI : 1;
          (i.lightMapIntensity.value = r.lightMapIntensity * e),
            n(r.lightMap, i.lightMapTransform);
        }
        r.aoMap &&
          ((i.aoMap.value = r.aoMap),
          (i.aoMapIntensity.value = r.aoMapIntensity),
          n(r.aoMap, i.aoMapTransform));
      }
      return {
        refreshFogUniforms: function (e, n) {
          n.color.getRGB(e.fogColor.value, bf(t)),
            n.isFog
              ? ((e.fogNear.value = n.near), (e.fogFar.value = n.far))
              : n.isFogExp2 && (e.fogDensity.value = n.density);
        },
        refreshMaterialUniforms: function (t, r, s, o, a) {
          r.isMeshBasicMaterial || r.isMeshLambertMaterial
            ? i(t, r)
            : r.isMeshToonMaterial
            ? (i(t, r),
              (function (t, e) {
                e.gradientMap && (t.gradientMap.value = e.gradientMap);
              })(t, r))
            : r.isMeshPhongMaterial
            ? (i(t, r),
              (function (t, e) {
                t.specular.value.copy(e.specular),
                  (t.shininess.value = Math.max(e.shininess, 1e-4));
              })(t, r))
            : r.isMeshStandardMaterial
            ? (i(t, r),
              (function (t, i) {
                (t.metalness.value = i.metalness),
                  i.metalnessMap &&
                    ((t.metalnessMap.value = i.metalnessMap),
                    n(i.metalnessMap, t.metalnessMapTransform));
                (t.roughness.value = i.roughness),
                  i.roughnessMap &&
                    ((t.roughnessMap.value = i.roughnessMap),
                    n(i.roughnessMap, t.roughnessMapTransform));
                e.get(i).envMap &&
                  (t.envMapIntensity.value = i.envMapIntensity);
              })(t, r),
              r.isMeshPhysicalMaterial &&
                (function (t, e, i) {
                  (t.ior.value = e.ior),
                    e.sheen > 0 &&
                      (t.sheenColor.value
                        .copy(e.sheenColor)
                        .multiplyScalar(e.sheen),
                      (t.sheenRoughness.value = e.sheenRoughness),
                      e.sheenColorMap &&
                        ((t.sheenColorMap.value = e.sheenColorMap),
                        n(e.sheenColorMap, t.sheenColorMapTransform)),
                      e.sheenRoughnessMap &&
                        ((t.sheenRoughnessMap.value = e.sheenRoughnessMap),
                        n(e.sheenRoughnessMap, t.sheenRoughnessMapTransform)));
                  e.clearcoat > 0 &&
                    ((t.clearcoat.value = e.clearcoat),
                    (t.clearcoatRoughness.value = e.clearcoatRoughness),
                    e.clearcoatMap &&
                      ((t.clearcoatMap.value = e.clearcoatMap),
                      n(e.clearcoatMap, t.clearcoatMapTransform)),
                    e.clearcoatRoughnessMap &&
                      ((t.clearcoatRoughnessMap.value =
                        e.clearcoatRoughnessMap),
                      n(
                        e.clearcoatRoughnessMap,
                        t.clearcoatRoughnessMapTransform
                      )),
                    e.clearcoatNormalMap &&
                      ((t.clearcoatNormalMap.value = e.clearcoatNormalMap),
                      n(e.clearcoatNormalMap, t.clearcoatNormalMapTransform),
                      t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale),
                      1 === e.side && t.clearcoatNormalScale.value.negate()));
                  e.iridescence > 0 &&
                    ((t.iridescence.value = e.iridescence),
                    (t.iridescenceIOR.value = e.iridescenceIOR),
                    (t.iridescenceThicknessMinimum.value =
                      e.iridescenceThicknessRange[0]),
                    (t.iridescenceThicknessMaximum.value =
                      e.iridescenceThicknessRange[1]),
                    e.iridescenceMap &&
                      ((t.iridescenceMap.value = e.iridescenceMap),
                      n(e.iridescenceMap, t.iridescenceMapTransform)),
                    e.iridescenceThicknessMap &&
                      ((t.iridescenceThicknessMap.value =
                        e.iridescenceThicknessMap),
                      n(
                        e.iridescenceThicknessMap,
                        t.iridescenceThicknessMapTransform
                      )));
                  e.transmission > 0 &&
                    ((t.transmission.value = e.transmission),
                    (t.transmissionSamplerMap.value = i.texture),
                    t.transmissionSamplerSize.value.set(i.width, i.height),
                    e.transmissionMap &&
                      ((t.transmissionMap.value = e.transmissionMap),
                      n(e.transmissionMap, t.transmissionMapTransform)),
                    (t.thickness.value = e.thickness),
                    e.thicknessMap &&
                      ((t.thicknessMap.value = e.thicknessMap),
                      n(e.thicknessMap, t.thicknessMapTransform)),
                    (t.attenuationDistance.value = e.attenuationDistance),
                    t.attenuationColor.value.copy(e.attenuationColor));
                  e.anisotropy > 0 &&
                    (t.anisotropyVector.value.set(
                      e.anisotropy * Math.cos(e.anisotropyRotation),
                      e.anisotropy * Math.sin(e.anisotropyRotation)
                    ),
                    e.anisotropyMap &&
                      ((t.anisotropyMap.value = e.anisotropyMap),
                      n(e.anisotropyMap, t.anisotropyMapTransform)));
                  (t.specularIntensity.value = e.specularIntensity),
                    t.specularColor.value.copy(e.specularColor),
                    e.specularColorMap &&
                      ((t.specularColorMap.value = e.specularColorMap),
                      n(e.specularColorMap, t.specularColorMapTransform));
                  e.specularIntensityMap &&
                    ((t.specularIntensityMap.value = e.specularIntensityMap),
                    n(e.specularIntensityMap, t.specularIntensityMapTransform));
                })(t, r, a))
            : r.isMeshMatcapMaterial
            ? (i(t, r),
              (function (t, e) {
                e.matcap && (t.matcap.value = e.matcap);
              })(t, r))
            : r.isMeshDepthMaterial
            ? i(t, r)
            : r.isMeshDistanceMaterial
            ? (i(t, r),
              (function (t, n) {
                const i = e.get(n).light;
                t.referencePosition.value.setFromMatrixPosition(i.matrixWorld),
                  (t.nearDistance.value = i.shadow.camera.near),
                  (t.farDistance.value = i.shadow.camera.far);
              })(t, r))
            : r.isMeshNormalMaterial
            ? i(t, r)
            : r.isLineBasicMaterial
            ? ((function (t, e) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
              })(t, r),
              r.isLineDashedMaterial &&
                (function (t, e) {
                  (t.dashSize.value = e.dashSize),
                    (t.totalSize.value = e.dashSize + e.gapSize),
                    (t.scale.value = e.scale);
                })(t, r))
            : r.isPointsMaterial
            ? (function (t, e, i, r) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.size.value = e.size * i),
                  (t.scale.value = 0.5 * r),
                  e.map && ((t.map.value = e.map), n(e.map, t.uvTransform));
                e.alphaMap &&
                  ((t.alphaMap.value = e.alphaMap),
                  n(e.alphaMap, t.alphaMapTransform));
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
              })(t, r, s, o)
            : r.isSpriteMaterial
            ? (function (t, e) {
                t.diffuse.value.copy(e.color),
                  (t.opacity.value = e.opacity),
                  (t.rotation.value = e.rotation),
                  e.map && ((t.map.value = e.map), n(e.map, t.mapTransform));
                e.alphaMap &&
                  ((t.alphaMap.value = e.alphaMap),
                  n(e.alphaMap, t.alphaMapTransform));
                e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
              })(t, r)
            : r.isShadowMaterial
            ? (t.color.value.copy(r.color), (t.opacity.value = r.opacity))
            : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
        },
      };
    }
    function pv(t, e, n, i) {
      let r = {},
        s = {},
        o = [];
      const a = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
      function l(t, e, n) {
        const i = t.value;
        if (void 0 === n[e]) {
          if ("number" == typeof i) n[e] = i;
          else {
            const t = Array.isArray(i) ? i : [i],
              r = [];
            for (let e = 0; e < t.length; e++) r.push(t[e].clone());
            n[e] = r;
          }
          return !0;
        }
        if ("number" == typeof i) {
          if (n[e] !== i) return (n[e] = i), !0;
        } else {
          const t = Array.isArray(n[e]) ? n[e] : [n[e]],
            r = Array.isArray(i) ? i : [i];
          for (let e = 0; e < t.length; e++) {
            const n = t[e];
            if (!1 === n.equals(r[e])) return n.copy(r[e]), !0;
          }
        }
        return !1;
      }
      function c(t) {
        const e = {
          boundary: 0,
          storage: 0,
        };
        return (
          "number" == typeof t
            ? ((e.boundary = 4), (e.storage = 4))
            : t.isVector2
            ? ((e.boundary = 8), (e.storage = 8))
            : t.isVector3 || t.isColor
            ? ((e.boundary = 16), (e.storage = 12))
            : t.isVector4
            ? ((e.boundary = 16), (e.storage = 16))
            : t.isMatrix3
            ? ((e.boundary = 48), (e.storage = 48))
            : t.isMatrix4
            ? ((e.boundary = 64), (e.storage = 64))
            : t.isTexture
            ? console.warn(
                "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
              )
            : console.warn(
                "THREE.WebGLRenderer: Unsupported uniform value type.",
                t
              ),
          e
        );
      }
      function u(e) {
        const n = e.target;
        n.removeEventListener("dispose", u);
        const i = o.indexOf(n.__bindingPointIndex);
        o.splice(i, 1), t.deleteBuffer(r[n.id]), delete r[n.id], delete s[n.id];
      }
      return {
        bind: function (t, e) {
          const n = e.program;
          i.uniformBlockBinding(t, n);
        },
        update: function (n, h) {
          let d = r[n.id];
          void 0 === d &&
            (!(function (t) {
              const e = t.uniforms;
              let n = 0;
              let i = 0;
              for (let t = 0, r = e.length; t < r; t++) {
                const r = e[t],
                  s = {
                    boundary: 0,
                    storage: 0,
                  },
                  o = Array.isArray(r.value) ? r.value : [r.value];
                for (let t = 0, e = o.length; t < e; t++) {
                  const e = c(o[t]);
                  (s.boundary += e.boundary), (s.storage += e.storage);
                }
                if (
                  ((r.__data = new Float32Array(
                    s.storage / Float32Array.BYTES_PER_ELEMENT
                  )),
                  (r.__offset = n),
                  t > 0)
                ) {
                  i = n % 16;
                  const t = 16 - i;
                  0 !== i &&
                    t - s.boundary < 0 &&
                    ((n += 16 - i), (r.__offset = n));
                }
                n += s.storage;
              }
              (i = n % 16), i > 0 && (n += 16 - i);
              (t.__size = n), (t.__cache = {});
            })(n),
            (d = (function (e) {
              const n = (function () {
                for (let t = 0; t < a; t++)
                  if (-1 === o.indexOf(t)) return o.push(t), t;
                return (
                  console.error(
                    "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                  ),
                  0
                );
              })();
              e.__bindingPointIndex = n;
              const i = t.createBuffer(),
                r = e.__size,
                s = e.usage;
              return (
                t.bindBuffer(t.UNIFORM_BUFFER, i),
                t.bufferData(t.UNIFORM_BUFFER, r, s),
                t.bindBuffer(t.UNIFORM_BUFFER, null),
                t.bindBufferBase(t.UNIFORM_BUFFER, n, i),
                i
              );
            })(n)),
            (r[n.id] = d),
            n.addEventListener("dispose", u));
          const p = h.program;
          i.updateUBOMapping(n, p);
          const f = e.render.frame;
          s[n.id] !== f &&
            (!(function (e) {
              const n = r[e.id],
                i = e.uniforms,
                s = e.__cache;
              t.bindBuffer(t.UNIFORM_BUFFER, n);
              for (let e = 0, n = i.length; e < n; e++) {
                const n = i[e];
                if (!0 === l(n, e, s)) {
                  const e = n.__offset,
                    i = Array.isArray(n.value) ? n.value : [n.value];
                  let r = 0;
                  for (let s = 0; s < i.length; s++) {
                    const o = i[s],
                      a = c(o);
                    "number" == typeof o
                      ? ((n.__data[0] = o),
                        t.bufferSubData(t.UNIFORM_BUFFER, e + r, n.__data))
                      : o.isMatrix3
                      ? ((n.__data[0] = o.elements[0]),
                        (n.__data[1] = o.elements[1]),
                        (n.__data[2] = o.elements[2]),
                        (n.__data[3] = o.elements[0]),
                        (n.__data[4] = o.elements[3]),
                        (n.__data[5] = o.elements[4]),
                        (n.__data[6] = o.elements[5]),
                        (n.__data[7] = o.elements[0]),
                        (n.__data[8] = o.elements[6]),
                        (n.__data[9] = o.elements[7]),
                        (n.__data[10] = o.elements[8]),
                        (n.__data[11] = o.elements[0]))
                      : (o.toArray(n.__data, r),
                        (r += a.storage / Float32Array.BYTES_PER_ELEMENT));
                  }
                  t.bufferSubData(t.UNIFORM_BUFFER, e, n.__data);
                }
              }
              t.bindBuffer(t.UNIFORM_BUFFER, null);
            })(n),
            (s[n.id] = f));
        },
        dispose: function () {
          for (const e in r) t.deleteBuffer(r[e]);
          (o = []), (r = {}), (s = {});
        },
      };
    }
    function fv() {
      const t = Xh("canvas");
      return (t.style.display = "block"), t;
    }
    class mv {
      constructor(t = {}) {
        const {
          canvas: e = fv(),
          context: n = null,
          depth: i = !0,
          stencil: r = !0,
          alpha: s = !1,
          antialias: o = !1,
          premultipliedAlpha: a = !0,
          preserveDrawingBuffer: l = !1,
          powerPreference: c = "default",
          failIfMajorPerformanceCaveat: u = !1,
        } = t;
        let h;
        (this.isWebGLRenderer = !0),
          (h = null !== n ? n.getContextAttributes().alpha : s);
        const d = new Uint32Array(4),
          p = new Int32Array(4);
        let f = null,
          m = null;
        const g = [],
          v = [];
        (this.domElement = e),
          (this.debug = {
            checkShaderErrors: !0,
            onShaderError: null,
          }),
          (this.autoClear = !0),
          (this.autoClearColor = !0),
          (this.autoClearDepth = !0),
          (this.autoClearStencil = !0),
          (this.sortObjects = !0),
          (this.clippingPlanes = []),
          (this.localClippingEnabled = !1),
          (this.outputColorSpace = "srgb"),
          (this._useLegacyLights = !1),
          (this.toneMapping = 0),
          (this.toneMappingExposure = 1);
        const _ = this;
        let y = !1,
          x = 0,
          b = 0,
          S = null,
          E = -1,
          M = null;
        const T = new cd(),
          w = new cd();
        let D = null;
        const A = new Fp(0);
        let C = 0,
          P = e.width,
          R = e.height,
          L = 1,
          O = null,
          I = null;
        const F = new cd(0, 0, P, R),
          U = new cd(0, 0, P, R);
        let N = !1;
        const k = new Ff();
        let z = !1,
          B = !1,
          H = null;
        const V = new jd(),
          G = new Vh(),
          W = new md(),
          j = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0,
          };
        function X() {
          return null === S ? L : 1;
        }
        let q,
          Y,
          K,
          Z,
          J,
          $,
          Q,
          tt,
          et,
          nt,
          it,
          rt,
          st,
          ot,
          at,
          lt,
          ct,
          ut,
          ht,
          dt,
          pt,
          ft,
          mt,
          gt,
          vt = n;
        function _t(t, n) {
          for (let i = 0; i < t.length; i++) {
            const r = t[i],
              s = e.getContext(r, n);
            if (null !== s) return s;
          }
          return null;
        }
        try {
          const t = {
            alpha: !0,
            depth: i,
            stencil: r,
            antialias: o,
            premultipliedAlpha: a,
            preserveDrawingBuffer: l,
            powerPreference: c,
            failIfMajorPerformanceCaveat: u,
          };
          if (
            ("setAttribute" in e &&
              e.setAttribute("data-engine", "three.js r155"),
            e.addEventListener("webglcontextlost", bt, !1),
            e.addEventListener("webglcontextrestored", St, !1),
            e.addEventListener("webglcontextcreationerror", Et, !1),
            null === vt)
          ) {
            const e = ["webgl2", "webgl", "experimental-webgl"];
            if (
              (!0 === _.isWebGL1Renderer && e.shift(),
              (vt = _t(e, t)),
              null === vt)
            )
              throw _t(e)
                ? new Error(
                    "Error creating WebGL context with your selected attributes."
                  )
                : new Error("Error creating WebGL context.");
          }
          "undefined" != typeof WebGLRenderingContext &&
            vt instanceof WebGLRenderingContext &&
            console.warn(
              "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
            ),
            void 0 === vt.getShaderPrecisionFormat &&
              (vt.getShaderPrecisionFormat = function () {
                return {
                  rangeMin: 1,
                  rangeMax: 1,
                  precision: 1,
                };
              });
        } catch (t) {
          throw (console.error("THREE.WebGLRenderer: " + t.message), t);
        }
        function yt() {
          (q = new um(vt)),
            (Y = new Xf(vt, q, t)),
            q.init(Y),
            (ft = new sv(vt, q, Y)),
            (K = new iv(vt, q, Y)),
            (Z = new pm(vt)),
            (J = new Gg()),
            ($ = new rv(vt, q, K, J, Y, ft, Z)),
            (Q = new Yf(_)),
            (tt = new cm(_)),
            (et = new Nf(vt, Y)),
            (mt = new Wf(vt, q, et, Y)),
            (nt = new hm(vt, et, Z, mt)),
            (it = new vm(vt, nt, et, Z)),
            (ht = new gm(vt, Y, $)),
            (lt = new qf(J)),
            (rt = new Vg(_, Q, tt, q, Y, mt, lt)),
            (st = new dv(_, J)),
            (ot = new qg()),
            (at = new Qg(q, Y)),
            (ut = new Gf(_, Q, tt, K, it, h, a)),
            (ct = new nv(_, it, Y)),
            (gt = new pv(vt, Z, Y, K)),
            (dt = new jf(vt, q, Z, Y)),
            (pt = new dm(vt, q, Z, Y)),
            (Z.programs = rt.programs),
            (_.capabilities = Y),
            (_.extensions = q),
            (_.properties = J),
            (_.renderLists = ot),
            (_.shadowMap = ct),
            (_.state = K),
            (_.info = Z);
        }
        yt();
        const xt = new hv(_, vt);
        function bt(t) {
          t.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            (y = !0);
        }
        function St() {
          console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
          const t = Z.autoReset,
            e = ct.enabled,
            n = ct.autoUpdate,
            i = ct.needsUpdate,
            r = ct.type;
          yt(),
            (Z.autoReset = t),
            (ct.enabled = e),
            (ct.autoUpdate = n),
            (ct.needsUpdate = i),
            (ct.type = r);
        }
        function Et(t) {
          console.error(
            "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
            t.statusMessage
          );
        }
        function Mt(t) {
          const e = t.target;
          e.removeEventListener("dispose", Mt),
            (function (t) {
              (function (t) {
                const e = J.get(t).programs;
                void 0 !== e &&
                  (e.forEach(function (t) {
                    rt.releaseProgram(t);
                  }),
                  t.isShaderMaterial && rt.releaseShaderCache(t));
              })(t),
                J.remove(t);
            })(e);
        }
        (this.xr = xt),
          (this.getContext = function () {
            return vt;
          }),
          (this.getContextAttributes = function () {
            return vt.getContextAttributes();
          }),
          (this.forceContextLoss = function () {
            const t = q.get("WEBGL_lose_context");
            t && t.loseContext();
          }),
          (this.forceContextRestore = function () {
            const t = q.get("WEBGL_lose_context");
            t && t.restoreContext();
          }),
          (this.getPixelRatio = function () {
            return L;
          }),
          (this.setPixelRatio = function (t) {
            void 0 !== t && ((L = t), this.setSize(P, R, !1));
          }),
          (this.getSize = function (t) {
            return t.set(P, R);
          }),
          (this.setSize = function (t, n, i = !0) {
            xt.isPresenting
              ? console.warn(
                  "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                )
              : ((P = t),
                (R = n),
                (e.width = Math.floor(t * L)),
                (e.height = Math.floor(n * L)),
                !0 === i &&
                  ((e.style.width = t + "px"), (e.style.height = n + "px")),
                this.setViewport(0, 0, t, n));
          }),
          (this.getDrawingBufferSize = function (t) {
            return t.set(P * L, R * L).floor();
          }),
          (this.setDrawingBufferSize = function (t, n, i) {
            (P = t),
              (R = n),
              (L = i),
              (e.width = Math.floor(t * i)),
              (e.height = Math.floor(n * i)),
              this.setViewport(0, 0, t, n);
          }),
          (this.getCurrentViewport = function (t) {
            return t.copy(T);
          }),
          (this.getViewport = function (t) {
            return t.copy(F);
          }),
          (this.setViewport = function (t, e, n, i) {
            t.isVector4 ? F.set(t.x, t.y, t.z, t.w) : F.set(t, e, n, i),
              K.viewport(T.copy(F).multiplyScalar(L).floor());
          }),
          (this.getScissor = function (t) {
            return t.copy(U);
          }),
          (this.setScissor = function (t, e, n, i) {
            t.isVector4 ? U.set(t.x, t.y, t.z, t.w) : U.set(t, e, n, i),
              K.scissor(w.copy(U).multiplyScalar(L).floor());
          }),
          (this.getScissorTest = function () {
            return N;
          }),
          (this.setScissorTest = function (t) {
            K.setScissorTest((N = t));
          }),
          (this.setOpaqueSort = function (t) {
            O = t;
          }),
          (this.setTransparentSort = function (t) {
            I = t;
          }),
          (this.getClearColor = function (t) {
            return t.copy(ut.getClearColor());
          }),
          (this.setClearColor = function () {
            ut.setClearColor.apply(ut, arguments);
          }),
          (this.getClearAlpha = function () {
            return ut.getClearAlpha();
          }),
          (this.setClearAlpha = function () {
            ut.setClearAlpha.apply(ut, arguments);
          }),
          (this.clear = function (t = !0, e = !0, n = !0) {
            let i = 0;
            if (t) {
              let t = !1;
              if (null !== S) {
                const e = S.texture.format;
                t = 1033 === e || 1031 === e || 1029 === e;
              }
              if (t) {
                const t = S.texture.type,
                  e =
                    1009 === t ||
                    1014 === t ||
                    1012 === t ||
                    1020 === t ||
                    1017 === t ||
                    1018 === t,
                  n = ut.getClearColor(),
                  i = ut.getClearAlpha(),
                  r = n.r,
                  s = n.g,
                  o = n.b;
                e
                  ? ((d[0] = r),
                    (d[1] = s),
                    (d[2] = o),
                    (d[3] = i),
                    vt.clearBufferuiv(vt.COLOR, 0, d))
                  : ((p[0] = r),
                    (p[1] = s),
                    (p[2] = o),
                    (p[3] = i),
                    vt.clearBufferiv(vt.COLOR, 0, p));
              } else i |= vt.COLOR_BUFFER_BIT;
            }
            e && (i |= vt.DEPTH_BUFFER_BIT),
              n && (i |= vt.STENCIL_BUFFER_BIT),
              vt.clear(i);
          }),
          (this.clearColor = function () {
            this.clear(!0, !1, !1);
          }),
          (this.clearDepth = function () {
            this.clear(!1, !0, !1);
          }),
          (this.clearStencil = function () {
            this.clear(!1, !1, !0);
          }),
          (this.dispose = function () {
            e.removeEventListener("webglcontextlost", bt, !1),
              e.removeEventListener("webglcontextrestored", St, !1),
              e.removeEventListener("webglcontextcreationerror", Et, !1),
              ot.dispose(),
              at.dispose(),
              J.dispose(),
              Q.dispose(),
              tt.dispose(),
              it.dispose(),
              mt.dispose(),
              gt.dispose(),
              rt.dispose(),
              xt.dispose(),
              xt.removeEventListener("sessionstart", wt),
              xt.removeEventListener("sessionend", Dt),
              H && (H.dispose(), (H = null)),
              At.stop();
          }),
          (this.renderBufferDirect = function (t, e, n, i, r, s) {
            null === e && (e = j);
            const o = r.isMesh && r.matrixWorld.determinant() < 0,
              a = (function (t, e, n, i, r) {
                !0 !== e.isScene && (e = j);
                $.resetTextureUnits();
                const s = e.fog,
                  o = i.isMeshStandardMaterial ? e.environment : null,
                  a =
                    null === S
                      ? _.outputColorSpace
                      : !0 === S.isXRRenderTarget
                      ? S.texture.colorSpace
                      : "srgb-linear",
                  l = (i.isMeshStandardMaterial ? tt : Q).get(i.envMap || o),
                  c =
                    !0 === i.vertexColors &&
                    !!n.attributes.color &&
                    4 === n.attributes.color.itemSize,
                  u =
                    !!n.attributes.tangent &&
                    (!!i.normalMap || i.anisotropy > 0),
                  h = !!n.morphAttributes.position,
                  d = !!n.morphAttributes.normal,
                  p = !!n.morphAttributes.color;
                let f = 0;
                i.toneMapped &&
                  ((null !== S && !0 !== S.isXRRenderTarget) ||
                    (f = _.toneMapping));
                const g =
                    n.morphAttributes.position ||
                    n.morphAttributes.normal ||
                    n.morphAttributes.color,
                  v = void 0 !== g ? g.length : 0,
                  y = J.get(i),
                  x = m.state.lights;
                if (!0 === z && (!0 === B || t !== M)) {
                  const e = t === M && i.id === E;
                  lt.setState(i, t, e);
                }
                let b = !1;
                i.version === y.__version
                  ? (y.needsLights &&
                      y.lightsStateVersion !== x.state.version) ||
                    y.outputColorSpace !== a ||
                    (r.isInstancedMesh && !1 === y.instancing)
                    ? (b = !0)
                    : r.isInstancedMesh || !0 !== y.instancing
                    ? r.isSkinnedMesh && !1 === y.skinning
                      ? (b = !0)
                      : r.isSkinnedMesh || !0 !== y.skinning
                      ? (r.isInstancedMesh &&
                          !0 === y.instancingColor &&
                          null === r.instanceColor) ||
                        (r.isInstancedMesh &&
                          !1 === y.instancingColor &&
                          null !== r.instanceColor) ||
                        y.envMap !== l ||
                        (!0 === i.fog && y.fog !== s)
                        ? (b = !0)
                        : void 0 === y.numClippingPlanes ||
                          (y.numClippingPlanes === lt.numPlanes &&
                            y.numIntersection === lt.numIntersection)
                        ? (y.vertexAlphas !== c ||
                            y.vertexTangents !== u ||
                            y.morphTargets !== h ||
                            y.morphNormals !== d ||
                            y.morphColors !== p ||
                            y.toneMapping !== f ||
                            (!0 === Y.isWebGL2 && y.morphTargetsCount !== v)) &&
                          (b = !0)
                        : (b = !0)
                      : (b = !0)
                    : (b = !0)
                  : ((b = !0), (y.__version = i.version));
                let T = y.currentProgram;
                !0 === b && (T = Lt(i, e, r));
                let w = !1,
                  D = !1,
                  A = !1;
                const C = T.getUniforms(),
                  P = y.uniforms;
                K.useProgram(T.program) && ((w = !0), (D = !0), (A = !0));
                i.id !== E && ((E = i.id), (D = !0));
                if (w || M !== t) {
                  if (
                    (C.setValue(vt, "projectionMatrix", t.projectionMatrix),
                    Y.logarithmicDepthBuffer &&
                      C.setValue(
                        vt,
                        "logDepthBufFC",
                        2 / (Math.log(t.far + 1) / Math.LN2)
                      ),
                    M !== t && ((M = t), (D = !0), (A = !0)),
                    i.isShaderMaterial ||
                      i.isMeshPhongMaterial ||
                      i.isMeshToonMaterial ||
                      i.isMeshStandardMaterial ||
                      i.envMap)
                  ) {
                    const e = C.map.cameraPosition;
                    void 0 !== e &&
                      e.setValue(vt, W.setFromMatrixPosition(t.matrixWorld));
                  }
                  (i.isMeshPhongMaterial ||
                    i.isMeshToonMaterial ||
                    i.isMeshLambertMaterial ||
                    i.isMeshBasicMaterial ||
                    i.isMeshStandardMaterial ||
                    i.isShaderMaterial) &&
                    C.setValue(
                      vt,
                      "isOrthographic",
                      !0 === t.isOrthographicCamera
                    ),
                    (i.isMeshPhongMaterial ||
                      i.isMeshToonMaterial ||
                      i.isMeshLambertMaterial ||
                      i.isMeshBasicMaterial ||
                      i.isMeshStandardMaterial ||
                      i.isShaderMaterial ||
                      i.isShadowMaterial ||
                      r.isSkinnedMesh) &&
                      C.setValue(vt, "viewMatrix", t.matrixWorldInverse);
                }
                if (r.isSkinnedMesh) {
                  C.setOptional(vt, r, "bindMatrix"),
                    C.setOptional(vt, r, "bindMatrixInverse");
                  const t = r.skeleton;
                  t &&
                    (Y.floatVertexTextures
                      ? (null === t.boneTexture && t.computeBoneTexture(),
                        C.setValue(vt, "boneTexture", t.boneTexture, $),
                        C.setValue(vt, "boneTextureSize", t.boneTextureSize))
                      : console.warn(
                          "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                        ));
                }
                const O = n.morphAttributes;
                (void 0 !== O.position ||
                  void 0 !== O.normal ||
                  (void 0 !== O.color && !0 === Y.isWebGL2)) &&
                  ht.update(r, n, T);
                (D || y.receiveShadow !== r.receiveShadow) &&
                  ((y.receiveShadow = r.receiveShadow),
                  C.setValue(vt, "receiveShadow", r.receiveShadow));
                i.isMeshGouraudMaterial &&
                  null !== i.envMap &&
                  ((P.envMap.value = l),
                  (P.flipEnvMap.value =
                    l.isCubeTexture && !1 === l.isRenderTargetTexture
                      ? -1
                      : 1));
                D &&
                  (C.setValue(vt, "toneMappingExposure", _.toneMappingExposure),
                  y.needsLights &&
                    ((F = A),
                    ((I = P).ambientLightColor.needsUpdate = F),
                    (I.lightProbe.needsUpdate = F),
                    (I.directionalLights.needsUpdate = F),
                    (I.directionalLightShadows.needsUpdate = F),
                    (I.pointLights.needsUpdate = F),
                    (I.pointLightShadows.needsUpdate = F),
                    (I.spotLights.needsUpdate = F),
                    (I.spotLightShadows.needsUpdate = F),
                    (I.rectAreaLights.needsUpdate = F),
                    (I.hemisphereLights.needsUpdate = F)),
                  s && !0 === i.fog && st.refreshFogUniforms(P, s),
                  st.refreshMaterialUniforms(P, i, L, R, H),
                  bg.upload(vt, y.uniformsList, P, $));
                var I, F;
                i.isShaderMaterial &&
                  !0 === i.uniformsNeedUpdate &&
                  (bg.upload(vt, y.uniformsList, P, $),
                  (i.uniformsNeedUpdate = !1));
                i.isSpriteMaterial && C.setValue(vt, "center", r.center);
                if (
                  (C.setValue(vt, "modelViewMatrix", r.modelViewMatrix),
                  C.setValue(vt, "normalMatrix", r.normalMatrix),
                  C.setValue(vt, "modelMatrix", r.matrixWorld),
                  i.isShaderMaterial || i.isRawShaderMaterial)
                ) {
                  const t = i.uniformsGroups;
                  for (let e = 0, n = t.length; e < n; e++)
                    if (Y.isWebGL2) {
                      const n = t[e];
                      gt.update(n, T), gt.bind(n, T);
                    } else
                      console.warn(
                        "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                      );
                }
                return T;
              })(t, e, n, i, r);
            K.setMaterial(i, o);
            let l = n.index,
              c = 1;
            if (!0 === i.wireframe) {
              if (((l = nt.getWireframeAttribute(n)), void 0 === l)) return;
              c = 2;
            }
            const u = n.drawRange,
              h = n.attributes.position;
            let d = u.start * c,
              p = (u.start + u.count) * c;
            null !== s &&
              ((d = Math.max(d, s.start * c)),
              (p = Math.min(p, (s.start + s.count) * c))),
              null !== l
                ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
                : null != h &&
                  ((d = Math.max(d, 0)), (p = Math.min(p, h.count)));
            const f = p - d;
            if (f < 0 || f === 1 / 0) return;
            let g;
            mt.setup(r, i, a, n, l);
            let v = dt;
            if (
              (null !== l && ((g = et.get(l)), (v = pt), v.setIndex(g)),
              r.isMesh)
            )
              !0 === i.wireframe
                ? (K.setLineWidth(i.wireframeLinewidth * X()),
                  v.setMode(vt.LINES))
                : v.setMode(vt.TRIANGLES);
            else if (r.isLine) {
              let t = i.linewidth;
              void 0 === t && (t = 1),
                K.setLineWidth(t * X()),
                r.isLineSegments
                  ? v.setMode(vt.LINES)
                  : r.isLineLoop
                  ? v.setMode(vt.LINE_LOOP)
                  : v.setMode(vt.LINE_STRIP);
            } else
              r.isPoints
                ? v.setMode(vt.POINTS)
                : r.isSprite && v.setMode(vt.TRIANGLES);
            if (r.isInstancedMesh) v.renderInstances(d, f, r.count);
            else if (n.isInstancedBufferGeometry) {
              const t =
                  void 0 !== n._maxInstanceCount ? n._maxInstanceCount : 1 / 0,
                e = Math.min(n.instanceCount, t);
              v.renderInstances(d, f, e);
            } else v.render(d, f);
          }),
          (this.compile = function (t, e) {
            function n(t, e, n) {
              !0 === t.transparent && 2 === t.side && !1 === t.forceSinglePass
                ? ((t.side = 1),
                  (t.needsUpdate = !0),
                  Lt(t, e, n),
                  (t.side = 0),
                  (t.needsUpdate = !0),
                  Lt(t, e, n),
                  (t.side = 2))
                : Lt(t, e, n);
            }
            (m = at.get(t)),
              m.init(),
              v.push(m),
              t.traverseVisible(function (t) {
                t.isLight &&
                  t.layers.test(e.layers) &&
                  (m.pushLight(t), t.castShadow && m.pushShadow(t));
              }),
              m.setupLights(_._useLegacyLights),
              t.traverse(function (e) {
                const i = e.material;
                if (i)
                  if (Array.isArray(i))
                    for (let r = 0; r < i.length; r++) {
                      n(i[r], t, e);
                    }
                  else n(i, t, e);
              }),
              v.pop(),
              (m = null);
          });
        let Tt = null;
        function wt() {
          At.stop();
        }
        function Dt() {
          At.start();
        }
        const At = new Uf();
        function Ct(t, e, n, i) {
          const r = t.opaque,
            s = t.transmissive,
            o = t.transparent;
          m.setupLightsView(n),
            !0 === z && lt.setGlobalState(_.clippingPlanes, n),
            s.length > 0 &&
              (function (t, e, n, i) {
                const r = Y.isWebGL2;
                null === H &&
                  (H = new hd(1, 1, {
                    generateMipmaps: !0,
                    type: q.has("EXT_color_buffer_half_float") ? 1016 : 1009,
                    minFilter: 1008,
                    samples: r ? 4 : 0,
                  }));
                _.getDrawingBufferSize(G),
                  r ? H.setSize(G.x, G.y) : H.setSize(zh(G.x), zh(G.y));
                const s = _.getRenderTarget();
                _.setRenderTarget(H),
                  _.getClearColor(A),
                  (C = _.getClearAlpha()),
                  C < 1 && _.setClearColor(16777215, 0.5);
                _.clear();
                const o = _.toneMapping;
                (_.toneMapping = 0),
                  Pt(t, n, i),
                  $.updateMultisampleRenderTarget(H),
                  $.updateRenderTargetMipmap(H);
                let a = !1;
                for (let t = 0, r = e.length; t < r; t++) {
                  const r = e[t],
                    s = r.object,
                    o = r.geometry,
                    l = r.material,
                    c = r.group;
                  if (2 === l.side && s.layers.test(i.layers)) {
                    const t = l.side;
                    (l.side = 1),
                      (l.needsUpdate = !0),
                      Rt(s, n, i, o, l, c),
                      (l.side = t),
                      (l.needsUpdate = !0),
                      (a = !0);
                  }
                }
                !0 === a &&
                  ($.updateMultisampleRenderTarget(H),
                  $.updateRenderTargetMipmap(H));
                _.setRenderTarget(s),
                  _.setClearColor(A, C),
                  (_.toneMapping = o);
              })(r, s, e, n),
            i && K.viewport(T.copy(i)),
            r.length > 0 && Pt(r, e, n),
            s.length > 0 && Pt(s, e, n),
            o.length > 0 && Pt(o, e, n),
            K.buffers.depth.setTest(!0),
            K.buffers.depth.setMask(!0),
            K.buffers.color.setMask(!0),
            K.setPolygonOffset(!1);
        }
        function Pt(t, e, n) {
          const i = !0 === e.isScene ? e.overrideMaterial : null;
          for (let r = 0, s = t.length; r < s; r++) {
            const s = t[r],
              o = s.object,
              a = s.geometry,
              l = null === i ? s.material : i,
              c = s.group;
            o.layers.test(n.layers) && Rt(o, e, n, a, l, c);
          }
        }
        function Rt(t, e, n, i, r, s) {
          t.onBeforeRender(_, e, n, i, r, s),
            t.modelViewMatrix.multiplyMatrices(
              n.matrixWorldInverse,
              t.matrixWorld
            ),
            t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
            r.onBeforeRender(_, e, n, i, t, s),
            !0 === r.transparent && 2 === r.side && !1 === r.forceSinglePass
              ? ((r.side = 1),
                (r.needsUpdate = !0),
                _.renderBufferDirect(n, e, i, r, t, s),
                (r.side = 0),
                (r.needsUpdate = !0),
                _.renderBufferDirect(n, e, i, r, t, s),
                (r.side = 2))
              : _.renderBufferDirect(n, e, i, r, t, s),
            t.onAfterRender(_, e, n, i, r, s);
        }
        function Lt(t, e, n) {
          !0 !== e.isScene && (e = j);
          const i = J.get(t),
            r = m.state.lights,
            s = m.state.shadowsArray,
            o = r.state.version,
            a = rt.getParameters(t, r.state, s, e, n),
            l = rt.getProgramCacheKey(a);
          let c = i.programs;
          (i.environment = t.isMeshStandardMaterial ? e.environment : null),
            (i.fog = e.fog),
            (i.envMap = (t.isMeshStandardMaterial ? tt : Q).get(
              t.envMap || i.environment
            )),
            void 0 === c &&
              (t.addEventListener("dispose", Mt),
              (c = new Map()),
              (i.programs = c));
          let u = c.get(l);
          if (void 0 !== u) {
            if (i.currentProgram === u && i.lightsStateVersion === o)
              return Ot(t, a), u;
          } else
            (a.uniforms = rt.getUniforms(t)),
              t.onBuild(n, a, _),
              t.onBeforeCompile(a, _),
              (u = rt.acquireProgram(a, l)),
              c.set(l, u),
              (i.uniforms = a.uniforms);
          const h = i.uniforms;
          ((t.isShaderMaterial || t.isRawShaderMaterial) &&
            !0 !== t.clipping) ||
            (h.clippingPlanes = lt.uniform),
            Ot(t, a),
            (i.needsLights = (function (t) {
              return (
                t.isMeshLambertMaterial ||
                t.isMeshToonMaterial ||
                t.isMeshPhongMaterial ||
                t.isMeshStandardMaterial ||
                t.isShadowMaterial ||
                (t.isShaderMaterial && !0 === t.lights)
              );
            })(t)),
            (i.lightsStateVersion = o),
            i.needsLights &&
              ((h.ambientLightColor.value = r.state.ambient),
              (h.lightProbe.value = r.state.probe),
              (h.directionalLights.value = r.state.directional),
              (h.directionalLightShadows.value = r.state.directionalShadow),
              (h.spotLights.value = r.state.spot),
              (h.spotLightShadows.value = r.state.spotShadow),
              (h.rectAreaLights.value = r.state.rectArea),
              (h.ltc_1.value = r.state.rectAreaLTC1),
              (h.ltc_2.value = r.state.rectAreaLTC2),
              (h.pointLights.value = r.state.point),
              (h.pointLightShadows.value = r.state.pointShadow),
              (h.hemisphereLights.value = r.state.hemi),
              (h.directionalShadowMap.value = r.state.directionalShadowMap),
              (h.directionalShadowMatrix.value =
                r.state.directionalShadowMatrix),
              (h.spotShadowMap.value = r.state.spotShadowMap),
              (h.spotLightMatrix.value = r.state.spotLightMatrix),
              (h.spotLightMap.value = r.state.spotLightMap),
              (h.pointShadowMap.value = r.state.pointShadowMap),
              (h.pointShadowMatrix.value = r.state.pointShadowMatrix));
          const d = u.getUniforms(),
            p = bg.seqWithValue(d.seq, h);
          return (i.currentProgram = u), (i.uniformsList = p), u;
        }
        function Ot(t, e) {
          const n = J.get(t);
          (n.outputColorSpace = e.outputColorSpace),
            (n.instancing = e.instancing),
            (n.instancingColor = e.instancingColor),
            (n.skinning = e.skinning),
            (n.morphTargets = e.morphTargets),
            (n.morphNormals = e.morphNormals),
            (n.morphColors = e.morphColors),
            (n.morphTargetsCount = e.morphTargetsCount),
            (n.numClippingPlanes = e.numClippingPlanes),
            (n.numIntersection = e.numClipIntersection),
            (n.vertexAlphas = e.vertexAlphas),
            (n.vertexTangents = e.vertexTangents),
            (n.toneMapping = e.toneMapping);
        }
        At.setAnimationLoop(function (t) {
          Tt && Tt(t);
        }),
          "undefined" != typeof self && At.setContext(self),
          (this.setAnimationLoop = function (t) {
            (Tt = t),
              xt.setAnimationLoop(t),
              null === t ? At.stop() : At.start();
          }),
          xt.addEventListener("sessionstart", wt),
          xt.addEventListener("sessionend", Dt),
          (this.render = function (t, e) {
            if (void 0 !== e && !0 !== e.isCamera)
              return void console.error(
                "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
              );
            if (!0 === y) return;
            !0 === t.matrixWorldAutoUpdate && t.updateMatrixWorld(),
              null === e.parent &&
                !0 === e.matrixWorldAutoUpdate &&
                e.updateMatrixWorld(),
              !0 === xt.enabled &&
                !0 === xt.isPresenting &&
                (!0 === xt.cameraAutoUpdate && xt.updateCamera(e),
                (e = xt.getCamera())),
              !0 === t.isScene && t.onBeforeRender(_, t, e, S),
              (m = at.get(t, v.length)),
              m.init(),
              v.push(m),
              V.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              k.setFromProjectionMatrix(V),
              (B = this.localClippingEnabled),
              (z = lt.init(this.clippingPlanes, B)),
              (f = ot.get(t, g.length)),
              f.init(),
              g.push(f),
              (function t(e, n, i, r) {
                if (!1 === e.visible) return;
                if (e.layers.test(n.layers))
                  if (e.isGroup) i = e.renderOrder;
                  else if (e.isLOD) !0 === e.autoUpdate && e.update(n);
                  else if (e.isLight)
                    m.pushLight(e), e.castShadow && m.pushShadow(e);
                  else if (e.isSprite) {
                    if (!e.frustumCulled || k.intersectsSprite(e)) {
                      r &&
                        W.setFromMatrixPosition(e.matrixWorld).applyMatrix4(V);
                      const t = it.update(e),
                        n = e.material;
                      n.visible && f.push(e, t, n, i, W.z, null);
                    }
                  } else if (
                    (e.isMesh || e.isLine || e.isPoints) &&
                    (!e.frustumCulled || k.intersectsObject(e))
                  ) {
                    const t = it.update(e),
                      n = e.material;
                    if (
                      (r &&
                        (void 0 !== e.boundingSphere
                          ? (null === e.boundingSphere &&
                              e.computeBoundingSphere(),
                            W.copy(e.boundingSphere.center))
                          : (null === t.boundingSphere &&
                              t.computeBoundingSphere(),
                            W.copy(t.boundingSphere.center)),
                        W.applyMatrix4(e.matrixWorld).applyMatrix4(V)),
                      Array.isArray(n))
                    ) {
                      const r = t.groups;
                      for (let s = 0, o = r.length; s < o; s++) {
                        const o = r[s],
                          a = n[o.materialIndex];
                        a && a.visible && f.push(e, t, a, i, W.z, o);
                      }
                    } else n.visible && f.push(e, t, n, i, W.z, null);
                  }
                const s = e.children;
                for (let e = 0, o = s.length; e < o; e++) t(s[e], n, i, r);
              })(t, e, 0, _.sortObjects),
              f.finish(),
              !0 === _.sortObjects && f.sort(O, I),
              this.info.render.frame++,
              !0 === z && lt.beginShadows();
            const n = m.state.shadowsArray;
            if (
              (ct.render(n, t, e),
              !0 === z && lt.endShadows(),
              !0 === this.info.autoReset && this.info.reset(),
              ut.render(f, t),
              m.setupLights(_._useLegacyLights),
              e.isArrayCamera)
            ) {
              const n = e.cameras;
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                Ct(f, t, i, i.viewport);
              }
            } else Ct(f, t, e);
            null !== S &&
              ($.updateMultisampleRenderTarget(S),
              $.updateRenderTargetMipmap(S)),
              !0 === t.isScene && t.onAfterRender(_, t, e),
              mt.resetDefaultState(),
              (E = -1),
              (M = null),
              v.pop(),
              (m = v.length > 0 ? v[v.length - 1] : null),
              g.pop(),
              (f = g.length > 0 ? g[g.length - 1] : null);
          }),
          (this.getActiveCubeFace = function () {
            return x;
          }),
          (this.getActiveMipmapLevel = function () {
            return b;
          }),
          (this.getRenderTarget = function () {
            return S;
          }),
          (this.setRenderTargetTextures = function (t, e, n) {
            (J.get(t.texture).__webglTexture = e),
              (J.get(t.depthTexture).__webglTexture = n);
            const i = J.get(t);
            (i.__hasExternalTextures = !0),
              i.__hasExternalTextures &&
                ((i.__autoAllocateDepthBuffer = void 0 === n),
                i.__autoAllocateDepthBuffer ||
                  (!0 === q.has("WEBGL_multisampled_render_to_texture") &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (i.__useRenderToTexture = !1))));
          }),
          (this.setRenderTargetFramebuffer = function (t, e) {
            const n = J.get(t);
            (n.__webglFramebuffer = e),
              (n.__useDefaultFramebuffer = void 0 === e);
          }),
          (this.setRenderTarget = function (t, e = 0, n = 0) {
            (S = t), (x = e), (b = n);
            let i = !0,
              r = null,
              s = !1,
              o = !1;
            if (t) {
              const a = J.get(t);
              void 0 !== a.__useDefaultFramebuffer
                ? (K.bindFramebuffer(vt.FRAMEBUFFER, null), (i = !1))
                : void 0 === a.__webglFramebuffer
                ? $.setupRenderTarget(t)
                : a.__hasExternalTextures &&
                  $.rebindTextures(
                    t,
                    J.get(t.texture).__webglTexture,
                    J.get(t.depthTexture).__webglTexture
                  );
              const l = t.texture;
              (l.isData3DTexture ||
                l.isDataArrayTexture ||
                l.isCompressedArrayTexture) &&
                (o = !0);
              const c = J.get(t).__webglFramebuffer;
              t.isWebGLCubeRenderTarget
                ? ((r = Array.isArray(c[e]) ? c[e][n] : c[e]), (s = !0))
                : (r =
                    Y.isWebGL2 &&
                    t.samples > 0 &&
                    !1 === $.useMultisampledRTT(t)
                      ? J.get(t).__webglMultisampledFramebuffer
                      : Array.isArray(c)
                      ? c[n]
                      : c),
                T.copy(t.viewport),
                w.copy(t.scissor),
                (D = t.scissorTest);
            } else
              T.copy(F).multiplyScalar(L).floor(),
                w.copy(U).multiplyScalar(L).floor(),
                (D = N);
            if (
              (K.bindFramebuffer(vt.FRAMEBUFFER, r) &&
                Y.drawBuffers &&
                i &&
                K.drawBuffers(t, r),
              K.viewport(T),
              K.scissor(w),
              K.setScissorTest(D),
              s)
            ) {
              const i = J.get(t.texture);
              vt.framebufferTexture2D(
                vt.FRAMEBUFFER,
                vt.COLOR_ATTACHMENT0,
                vt.TEXTURE_CUBE_MAP_POSITIVE_X + e,
                i.__webglTexture,
                n
              );
            } else if (o) {
              const i = J.get(t.texture),
                r = e || 0;
              vt.framebufferTextureLayer(
                vt.FRAMEBUFFER,
                vt.COLOR_ATTACHMENT0,
                i.__webglTexture,
                n || 0,
                r
              );
            }
            E = -1;
          }),
          (this.readRenderTargetPixels = function (t, e, n, i, r, s, o) {
            if (!t || !t.isWebGLRenderTarget)
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
              );
            let a = J.get(t).__webglFramebuffer;
            if ((t.isWebGLCubeRenderTarget && void 0 !== o && (a = a[o]), a)) {
              K.bindFramebuffer(vt.FRAMEBUFFER, a);
              try {
                const o = t.texture,
                  a = o.format,
                  l = o.type;
                if (
                  1023 !== a &&
                  ft.convert(a) !==
                    vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_FORMAT)
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                  );
                const c =
                  1016 === l &&
                  (q.has("EXT_color_buffer_half_float") ||
                    (Y.isWebGL2 && q.has("EXT_color_buffer_float")));
                if (
                  !(
                    1009 === l ||
                    ft.convert(l) ===
                      vt.getParameter(vt.IMPLEMENTATION_COLOR_READ_TYPE) ||
                    (1015 === l &&
                      (Y.isWebGL2 ||
                        q.has("OES_texture_float") ||
                        q.has("WEBGL_color_buffer_float"))) ||
                    c
                  )
                )
                  return void console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                e >= 0 &&
                  e <= t.width - i &&
                  n >= 0 &&
                  n <= t.height - r &&
                  vt.readPixels(e, n, i, r, ft.convert(a), ft.convert(l), s);
              } finally {
                const t = null !== S ? J.get(S).__webglFramebuffer : null;
                K.bindFramebuffer(vt.FRAMEBUFFER, t);
              }
            }
          }),
          (this.copyFramebufferToTexture = function (t, e, n = 0) {
            const i = Math.pow(2, -n),
              r = Math.floor(e.image.width * i),
              s = Math.floor(e.image.height * i);
            $.setTexture2D(e, 0),
              vt.copyTexSubImage2D(vt.TEXTURE_2D, n, 0, 0, t.x, t.y, r, s),
              K.unbindTexture();
          }),
          (this.copyTextureToTexture = function (t, e, n, i = 0) {
            const r = e.image.width,
              s = e.image.height,
              o = ft.convert(n.format),
              a = ft.convert(n.type);
            $.setTexture2D(n, 0),
              vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, n.flipY),
              vt.pixelStorei(
                vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                n.premultiplyAlpha
              ),
              vt.pixelStorei(vt.UNPACK_ALIGNMENT, n.unpackAlignment),
              e.isDataTexture
                ? vt.texSubImage2D(
                    vt.TEXTURE_2D,
                    i,
                    t.x,
                    t.y,
                    r,
                    s,
                    o,
                    a,
                    e.image.data
                  )
                : e.isCompressedTexture
                ? vt.compressedTexSubImage2D(
                    vt.TEXTURE_2D,
                    i,
                    t.x,
                    t.y,
                    e.mipmaps[0].width,
                    e.mipmaps[0].height,
                    o,
                    e.mipmaps[0].data
                  )
                : vt.texSubImage2D(vt.TEXTURE_2D, i, t.x, t.y, o, a, e.image),
              0 === i && n.generateMipmaps && vt.generateMipmap(vt.TEXTURE_2D),
              K.unbindTexture();
          }),
          (this.copyTextureToTexture3D = function (t, e, n, i, r = 0) {
            if (_.isWebGL1Renderer)
              return void console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
              );
            const s = t.max.x - t.min.x + 1,
              o = t.max.y - t.min.y + 1,
              a = t.max.z - t.min.z + 1,
              l = ft.convert(i.format),
              c = ft.convert(i.type);
            let u;
            if (i.isData3DTexture) $.setTexture3D(i, 0), (u = vt.TEXTURE_3D);
            else {
              if (!i.isDataArrayTexture)
                return void console.warn(
                  "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
                );
              $.setTexture2DArray(i, 0), (u = vt.TEXTURE_2D_ARRAY);
            }
            vt.pixelStorei(vt.UNPACK_FLIP_Y_WEBGL, i.flipY),
              vt.pixelStorei(
                vt.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                i.premultiplyAlpha
              ),
              vt.pixelStorei(vt.UNPACK_ALIGNMENT, i.unpackAlignment);
            const h = vt.getParameter(vt.UNPACK_ROW_LENGTH),
              d = vt.getParameter(vt.UNPACK_IMAGE_HEIGHT),
              p = vt.getParameter(vt.UNPACK_SKIP_PIXELS),
              f = vt.getParameter(vt.UNPACK_SKIP_ROWS),
              m = vt.getParameter(vt.UNPACK_SKIP_IMAGES),
              g = n.isCompressedTexture ? n.mipmaps[0] : n.image;
            vt.pixelStorei(vt.UNPACK_ROW_LENGTH, g.width),
              vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, g.height),
              vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, t.min.x),
              vt.pixelStorei(vt.UNPACK_SKIP_ROWS, t.min.y),
              vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, t.min.z),
              n.isDataTexture || n.isData3DTexture
                ? vt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g.data)
                : n.isCompressedArrayTexture
                ? (console.warn(
                    "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
                  ),
                  vt.compressedTexSubImage3D(
                    u,
                    r,
                    e.x,
                    e.y,
                    e.z,
                    s,
                    o,
                    a,
                    l,
                    g.data
                  ))
                : vt.texSubImage3D(u, r, e.x, e.y, e.z, s, o, a, l, c, g),
              vt.pixelStorei(vt.UNPACK_ROW_LENGTH, h),
              vt.pixelStorei(vt.UNPACK_IMAGE_HEIGHT, d),
              vt.pixelStorei(vt.UNPACK_SKIP_PIXELS, p),
              vt.pixelStorei(vt.UNPACK_SKIP_ROWS, f),
              vt.pixelStorei(vt.UNPACK_SKIP_IMAGES, m),
              0 === r && i.generateMipmaps && vt.generateMipmap(u),
              K.unbindTexture();
          }),
          (this.initTexture = function (t) {
            t.isCubeTexture
              ? $.setTextureCube(t, 0)
              : t.isData3DTexture
              ? $.setTexture3D(t, 0)
              : t.isDataArrayTexture || t.isCompressedArrayTexture
              ? $.setTexture2DArray(t, 0)
              : $.setTexture2D(t, 0),
              K.unbindTexture();
          }),
          (this.resetState = function () {
            (x = 0), (b = 0), (S = null), K.reset(), mt.reset();
          }),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", {
                detail: this,
              })
            );
      }
      get coordinateSystem() {
        return 2e3;
      }
      get physicallyCorrectLights() {
        return (
          console.warn(
            "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
          ),
          !this.useLegacyLights
        );
      }
      set physicallyCorrectLights(t) {
        console.warn(
          "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
        ),
          (this.useLegacyLights = !t);
      }
      get outputEncoding() {
        return (
          console.warn(
            "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
          ),
          "srgb" === this.outputColorSpace ? 3001 : 3e3
        );
      }
      set outputEncoding(t) {
        console.warn(
          "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
        ),
          (this.outputColorSpace = 3001 === t ? "srgb" : "srgb-linear");
      }
      get useLegacyLights() {
        return (
          console.warn(
            "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
          ),
          this._useLegacyLights
        );
      }
      set useLegacyLights(t) {
        console.warn(
          "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
        ),
          (this._useLegacyLights = t);
      }
    }
    (class extends mv {}).prototype.isWebGL1Renderer = !0;
    class gv extends gp {
      constructor() {
        super(),
          (this.isScene = !0),
          (this.type = "Scene"),
          (this.background = null),
          (this.environment = null),
          (this.fog = null),
          (this.backgroundBlurriness = 0),
          (this.backgroundIntensity = 1),
          (this.overrideMaterial = null),
          "undefined" != typeof __THREE_DEVTOOLS__ &&
            __THREE_DEVTOOLS__.dispatchEvent(
              new CustomEvent("observe", {
                detail: this,
              })
            );
      }
      copy(t, e) {
        return (
          super.copy(t, e),
          null !== t.background && (this.background = t.background.clone()),
          null !== t.environment && (this.environment = t.environment.clone()),
          null !== t.fog && (this.fog = t.fog.clone()),
          (this.backgroundBlurriness = t.backgroundBlurriness),
          (this.backgroundIntensity = t.backgroundIntensity),
          null !== t.overrideMaterial &&
            (this.overrideMaterial = t.overrideMaterial.clone()),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this
        );
      }
      toJSON(t) {
        const e = super.toJSON(t);
        return (
          null !== this.fog && (e.object.fog = this.fog.toJSON()),
          this.backgroundBlurriness > 0 &&
            (e.object.backgroundBlurriness = this.backgroundBlurriness),
          1 !== this.backgroundIntensity &&
            (e.object.backgroundIntensity = this.backgroundIntensity),
          e
        );
      }
    }
    class vv extends ld {
      constructor(t, e, n, i, r, s, o, a, l) {
        super(t, e, n, i, r, s, o, a, l),
          (this.isVideoTexture = !0),
          (this.minFilter = void 0 !== s ? s : 1006),
          (this.magFilter = void 0 !== r ? r : 1006),
          (this.generateMipmaps = !1);
        const c = this;
        "requestVideoFrameCallback" in t &&
          t.requestVideoFrameCallback(function e() {
            (c.needsUpdate = !0), t.requestVideoFrameCallback(e);
          });
      }
      clone() {
        return new this.constructor(this.image).copy(this);
      }
      update() {
        const t = this.image;
        !1 === "requestVideoFrameCallback" in t &&
          t.readyState >= t.HAVE_CURRENT_DATA &&
          (this.needsUpdate = !0);
      }
    }
    function _v(t, e, n) {
      return xv(t)
        ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length))
        : t.slice(e, n);
    }
    function yv(t, e, n) {
      return !t || (!n && t.constructor === e)
        ? t
        : "number" == typeof e.BYTES_PER_ELEMENT
        ? new e(t)
        : Array.prototype.slice.call(t);
    }
    function xv(t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    }
    class bv {
      constructor(t, e, n, i) {
        (this.parameterPositions = t),
          (this._cachedIndex = 0),
          (this.resultBuffer = void 0 !== i ? i : new e.constructor(n)),
          (this.sampleValues = e),
          (this.valueSize = n),
          (this.settings = null),
          (this.DefaultSettings_ = {});
      }
      evaluate(t) {
        const e = this.parameterPositions;
        let n = this._cachedIndex,
          i = e[n],
          r = e[n - 1];
        t: {
          e: {
            let s;
            n: {
              i: if (!(t < i)) {
                for (let s = n + 2; ; ) {
                  if (void 0 === i) {
                    if (t < r) break i;
                    return (
                      (n = e.length),
                      (this._cachedIndex = n),
                      this.copySampleValue_(n - 1)
                    );
                  }
                  if (n === s) break;
                  if (((r = i), (i = e[++n]), t < i)) break e;
                }
                s = e.length;
                break n;
              }
              if (t >= r) break t;
              {
                const o = e[1];
                t < o && ((n = 2), (r = o));
                for (let s = n - 2; ; ) {
                  if (void 0 === r)
                    return (this._cachedIndex = 0), this.copySampleValue_(0);
                  if (n === s) break;
                  if (((i = r), (r = e[--n - 1]), t >= r)) break e;
                }
                (s = n), (n = 0);
              }
            }
            for (; n < s; ) {
              const i = (n + s) >>> 1;
              t < e[i] ? (s = i) : (n = i + 1);
            }
            if (((i = e[n]), (r = e[n - 1]), void 0 === r))
              return (this._cachedIndex = 0), this.copySampleValue_(0);
            if (void 0 === i)
              return (
                (n = e.length),
                (this._cachedIndex = n),
                this.copySampleValue_(n - 1)
              );
          }
          (this._cachedIndex = n), this.intervalChanged_(n, r, i);
        }
        return this.interpolate_(n, r, t, i);
      }
      getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
      copySampleValue_(t) {
        const e = this.resultBuffer,
          n = this.sampleValues,
          i = this.valueSize,
          r = t * i;
        for (let t = 0; t !== i; ++t) e[t] = n[r + t];
        return e;
      }
      interpolate_() {
        throw new Error("call to abstract method");
      }
      intervalChanged_() {}
    }
    class Sv extends bv {
      constructor(t, e, n, i) {
        super(t, e, n, i),
          (this._weightPrev = -0),
          (this._offsetPrev = -0),
          (this._weightNext = -0),
          (this._offsetNext = -0),
          (this.DefaultSettings_ = {
            endingStart: 2400,
            endingEnd: 2400,
          });
      }
      intervalChanged_(t, e, n) {
        const i = this.parameterPositions;
        let r = t - 2,
          s = t + 1,
          o = i[r],
          a = i[s];
        if (void 0 === o)
          switch (this.getSettings_().endingStart) {
            case 2401:
              (r = t), (o = 2 * e - n);
              break;
            case 2402:
              (r = i.length - 2), (o = e + i[r] - i[r + 1]);
              break;
            default:
              (r = t), (o = n);
          }
        if (void 0 === a)
          switch (this.getSettings_().endingEnd) {
            case 2401:
              (s = t), (a = 2 * n - e);
              break;
            case 2402:
              (s = 1), (a = n + i[1] - i[0]);
              break;
            default:
              (s = t - 1), (a = e);
          }
        const l = 0.5 * (n - e),
          c = this.valueSize;
        (this._weightPrev = l / (e - o)),
          (this._weightNext = l / (a - n)),
          (this._offsetPrev = r * c),
          (this._offsetNext = s * c);
      }
      interpolate_(t, e, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = t * o,
          l = a - o,
          c = this._offsetPrev,
          u = this._offsetNext,
          h = this._weightPrev,
          d = this._weightNext,
          p = (n - e) / (i - e),
          f = p * p,
          m = f * p,
          g = -h * m + 2 * h * f - h * p,
          v = (1 + h) * m + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
          _ = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
          y = d * m - d * f;
        for (let t = 0; t !== o; ++t)
          r[t] = g * s[c + t] + v * s[l + t] + _ * s[a + t] + y * s[u + t];
        return r;
      }
    }
    class Ev extends bv {
      constructor(t, e, n, i) {
        super(t, e, n, i);
      }
      interpolate_(t, e, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = t * o,
          l = a - o,
          c = (n - e) / (i - e),
          u = 1 - c;
        for (let t = 0; t !== o; ++t) r[t] = s[l + t] * u + s[a + t] * c;
        return r;
      }
    }
    class Mv extends bv {
      constructor(t, e, n, i) {
        super(t, e, n, i);
      }
      interpolate_(t) {
        return this.copySampleValue_(t - 1);
      }
    }
    class Tv {
      constructor(t, e, n, i) {
        if (void 0 === t)
          throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length)
          throw new Error(
            "THREE.KeyframeTrack: no keyframes in track named " + t
          );
        (this.name = t),
          (this.times = yv(e, this.TimeBufferType)),
          (this.values = yv(n, this.ValueBufferType)),
          this.setInterpolation(i || this.DefaultInterpolation);
      }
      static toJSON(t) {
        const e = t.constructor;
        let n;
        if (e.toJSON !== this.toJSON) n = e.toJSON(t);
        else {
          n = {
            name: t.name,
            times: yv(t.times, Array),
            values: yv(t.values, Array),
          };
          const e = t.getInterpolation();
          e !== t.DefaultInterpolation && (n.interpolation = e);
        }
        return (n.type = t.ValueTypeName), n;
      }
      InterpolantFactoryMethodDiscrete(t) {
        return new Mv(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodLinear(t) {
        return new Ev(this.times, this.values, this.getValueSize(), t);
      }
      InterpolantFactoryMethodSmooth(t) {
        return new Sv(this.times, this.values, this.getValueSize(), t);
      }
      setInterpolation(t) {
        let e;
        switch (t) {
          case 2300:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case 2301:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case 2302:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 === e) {
          const e =
            "unsupported interpolation for " +
            this.ValueTypeName +
            " keyframe track named " +
            this.name;
          if (void 0 === this.createInterpolant) {
            if (t === this.DefaultInterpolation) throw new Error(e);
            this.setInterpolation(this.DefaultInterpolation);
          }
          return console.warn("THREE.KeyframeTrack:", e), this;
        }
        return (this.createInterpolant = e), this;
      }
      getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return 2300;
          case this.InterpolantFactoryMethodLinear:
            return 2301;
          case this.InterpolantFactoryMethodSmooth:
            return 2302;
        }
      }
      getValueSize() {
        return this.values.length / this.times.length;
      }
      shift(t) {
        if (0 !== t) {
          const e = this.times;
          for (let n = 0, i = e.length; n !== i; ++n) e[n] += t;
        }
        return this;
      }
      scale(t) {
        if (1 !== t) {
          const e = this.times;
          for (let n = 0, i = e.length; n !== i; ++n) e[n] *= t;
        }
        return this;
      }
      trim(t, e) {
        const n = this.times,
          i = n.length;
        let r = 0,
          s = i - 1;
        for (; r !== i && n[r] < t; ) ++r;
        for (; -1 !== s && n[s] > e; ) --s;
        if ((++s, 0 !== r || s !== i)) {
          r >= s && ((s = Math.max(s, 1)), (r = s - 1));
          const t = this.getValueSize();
          (this.times = _v(n, r, s)),
            (this.values = _v(this.values, r * t, s * t));
        }
        return this;
      }
      validate() {
        let t = !0;
        const e = this.getValueSize();
        e - Math.floor(e) != 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this
          ),
          (t = !1));
        const n = this.times,
          i = this.values,
          r = n.length;
        0 === r &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (t = !1));
        let s = null;
        for (let e = 0; e !== r; e++) {
          const i = n[e];
          if ("number" == typeof i && isNaN(i)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              e,
              i
            ),
              (t = !1);
            break;
          }
          if (null !== s && s > i) {
            console.error(
              "THREE.KeyframeTrack: Out of order keys.",
              this,
              e,
              i,
              s
            ),
              (t = !1);
            break;
          }
          s = i;
        }
        if (void 0 !== i && xv(i))
          for (let e = 0, n = i.length; e !== n; ++e) {
            const n = i[e];
            if (isNaN(n)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                e,
                n
              ),
                (t = !1);
              break;
            }
          }
        return t;
      }
      optimize() {
        const t = _v(this.times),
          e = _v(this.values),
          n = this.getValueSize(),
          i = 2302 === this.getInterpolation(),
          r = t.length - 1;
        let s = 1;
        for (let o = 1; o < r; ++o) {
          let r = !1;
          const a = t[o];
          if (a !== t[o + 1] && (1 !== o || a !== t[0]))
            if (i) r = !0;
            else {
              const t = o * n,
                i = t - n,
                s = t + n;
              for (let o = 0; o !== n; ++o) {
                const n = e[t + o];
                if (n !== e[i + o] || n !== e[s + o]) {
                  r = !0;
                  break;
                }
              }
            }
          if (r) {
            if (o !== s) {
              t[s] = t[o];
              const i = o * n,
                r = s * n;
              for (let t = 0; t !== n; ++t) e[r + t] = e[i + t];
            }
            ++s;
          }
        }
        if (r > 0) {
          t[s] = t[r];
          for (let t = r * n, i = s * n, o = 0; o !== n; ++o)
            e[i + o] = e[t + o];
          ++s;
        }
        return (
          s !== t.length
            ? ((this.times = _v(t, 0, s)), (this.values = _v(e, 0, s * n)))
            : ((this.times = t), (this.values = e)),
          this
        );
      }
      clone() {
        const t = _v(this.times, 0),
          e = _v(this.values, 0),
          n = new (0, this.constructor)(this.name, t, e);
        return (n.createInterpolant = this.createInterpolant), n;
      }
    }
    (Tv.prototype.TimeBufferType = Float32Array),
      (Tv.prototype.ValueBufferType = Float32Array),
      (Tv.prototype.DefaultInterpolation = 2301);
    class wv extends Tv {}
    (wv.prototype.ValueTypeName = "bool"),
      (wv.prototype.ValueBufferType = Array),
      (wv.prototype.DefaultInterpolation = 2300),
      (wv.prototype.InterpolantFactoryMethodLinear = void 0),
      (wv.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Dv extends Tv {}
    Dv.prototype.ValueTypeName = "color";
    class Av extends Tv {}
    Av.prototype.ValueTypeName = "number";
    class Cv extends bv {
      constructor(t, e, n, i) {
        super(t, e, n, i);
      }
      interpolate_(t, e, n, i) {
        const r = this.resultBuffer,
          s = this.sampleValues,
          o = this.valueSize,
          a = (n - e) / (i - e);
        let l = t * o;
        for (let t = l + o; l !== t; l += 4)
          fd.slerpFlat(r, 0, s, l - o, s, l, a);
        return r;
      }
    }
    class Pv extends Tv {
      InterpolantFactoryMethodLinear(t) {
        return new Cv(this.times, this.values, this.getValueSize(), t);
      }
    }
    (Pv.prototype.ValueTypeName = "quaternion"),
      (Pv.prototype.DefaultInterpolation = 2301),
      (Pv.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Rv extends Tv {}
    (Rv.prototype.ValueTypeName = "string"),
      (Rv.prototype.ValueBufferType = Array),
      (Rv.prototype.DefaultInterpolation = 2300),
      (Rv.prototype.InterpolantFactoryMethodLinear = void 0),
      (Rv.prototype.InterpolantFactoryMethodSmooth = void 0);
    class Lv extends Tv {}
    Lv.prototype.ValueTypeName = "vector";
    class Ov {
      constructor(t, e, n) {
        const i = this;
        let r = !1,
          s = 0,
          o = 0,
          a = void 0;
        const l = [];
        (this.onStart = void 0),
          (this.onLoad = t),
          (this.onProgress = e),
          (this.onError = n),
          (this.itemStart = function (t) {
            o++,
              !1 === r && void 0 !== i.onStart && i.onStart(t, s, o),
              (r = !0);
          }),
          (this.itemEnd = function (t) {
            s++,
              void 0 !== i.onProgress && i.onProgress(t, s, o),
              s === o && ((r = !1), void 0 !== i.onLoad && i.onLoad());
          }),
          (this.itemError = function (t) {
            void 0 !== i.onError && i.onError(t);
          }),
          (this.resolveURL = function (t) {
            return a ? a(t) : t;
          }),
          (this.setURLModifier = function (t) {
            return (a = t), this;
          }),
          (this.addHandler = function (t, e) {
            return l.push(t, e), this;
          }),
          (this.removeHandler = function (t) {
            const e = l.indexOf(t);
            return -1 !== e && l.splice(e, 2), this;
          }),
          (this.getHandler = function (t) {
            for (let e = 0, n = l.length; e < n; e += 2) {
              const n = l[e],
                i = l[e + 1];
              if ((n.global && (n.lastIndex = 0), n.test(t))) return i;
            }
            return null;
          });
      }
    }
    const Iv = new Ov();
    class Fv {
      constructor(t) {
        (this.manager = void 0 !== t ? t : Iv),
          (this.crossOrigin = "anonymous"),
          (this.withCredentials = !1),
          (this.path = ""),
          (this.resourcePath = ""),
          (this.requestHeader = {});
      }
      load() {}
      loadAsync(t, e) {
        const n = this;
        return new Promise(function (i, r) {
          n.load(t, i, e, r);
        });
      }
      parse() {}
      setCrossOrigin(t) {
        return (this.crossOrigin = t), this;
      }
      setWithCredentials(t) {
        return (this.withCredentials = t), this;
      }
      setPath(t) {
        return (this.path = t), this;
      }
      setResourcePath(t) {
        return (this.resourcePath = t), this;
      }
      setRequestHeader(t) {
        return (this.requestHeader = t), this;
      }
    }
    Fv.DEFAULT_MATERIAL_NAME = "__DEFAULT";
    Error;
    class Uv {
      constructor(t = !0) {
        (this.autoStart = t),
          (this.startTime = 0),
          (this.oldTime = 0),
          (this.elapsedTime = 0),
          (this.running = !1);
      }
      start() {
        (this.startTime = Nv()),
          (this.oldTime = this.startTime),
          (this.elapsedTime = 0),
          (this.running = !0);
      }
      stop() {
        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
      }
      getElapsedTime() {
        return this.getDelta(), this.elapsedTime;
      }
      getDelta() {
        let t = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
          const e = Nv();
          (t = (e - this.oldTime) / 1e3),
            (this.oldTime = e),
            (this.elapsedTime += t);
        }
        return t;
      }
    }
    function Nv() {
      return ("undefined" == typeof performance ? Date : performance).now();
    }
    const kv = new RegExp("[\\[\\]\\.:\\/]", "g"),
      zv = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
      Bv = new RegExp(
        "^" +
          /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]") +
          /(WCOD+)?/.source.replace("WCOD", zv) +
          /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]") +
          /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]") +
          "$"
      ),
      Hv = ["material", "materials", "bones", "map"];
    class Vv {
      constructor(t, e, n) {
        (this.path = e),
          (this.parsedPath = n || Vv.parseTrackName(e)),
          (this.node = Vv.findNode(t, this.parsedPath.nodeName)),
          (this.rootNode = t),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
      static create(t, e, n) {
        return t && t.isAnimationObjectGroup
          ? new Vv.Composite(t, e, n)
          : new Vv(t, e, n);
      }
      static sanitizeNodeName(t) {
        return t.replace(/\s/g, "_").replace(kv, "");
      }
      static parseTrackName(t) {
        const e = Bv.exec(t);
        if (null === e)
          throw new Error("PropertyBinding: Cannot parse trackName: " + t);
        const n = {
            nodeName: e[2],
            objectName: e[3],
            objectIndex: e[4],
            propertyName: e[5],
            propertyIndex: e[6],
          },
          i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (void 0 !== i && -1 !== i) {
          const t = n.nodeName.substring(i + 1);
          -1 !== Hv.indexOf(t) &&
            ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = t));
        }
        if (null === n.propertyName || 0 === n.propertyName.length)
          throw new Error(
            "PropertyBinding: can not parse propertyName from trackName: " + t
          );
        return n;
      }
      static findNode(t, e) {
        if (
          void 0 === e ||
          "" === e ||
          "." === e ||
          -1 === e ||
          e === t.name ||
          e === t.uuid
        )
          return t;
        if (t.skeleton) {
          const n = t.skeleton.getBoneByName(e);
          if (void 0 !== n) return n;
        }
        if (t.children) {
          const n = function (t) {
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                if (r.name === e || r.uuid === e) return r;
                const s = n(r.children);
                if (s) return s;
              }
              return null;
            },
            i = n(t.children);
          if (i) return i;
        }
        return null;
      }
      _getValue_unavailable() {}
      _setValue_unavailable() {}
      _getValue_direct(t, e) {
        t[e] = this.targetObject[this.propertyName];
      }
      _getValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) t[e++] = n[i];
      }
      _getValue_arrayElement(t, e) {
        t[e] = this.resolvedProperty[this.propertyIndex];
      }
      _getValue_toArray(t, e) {
        this.resolvedProperty.toArray(t, e);
      }
      _setValue_direct(t, e) {
        this.targetObject[this.propertyName] = t[e];
      }
      _setValue_direct_setNeedsUpdate(t, e) {
        (this.targetObject[this.propertyName] = t[e]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
        (this.targetObject[this.propertyName] = t[e]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_array(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
      }
      _setValue_array_setNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        this.targetObject.needsUpdate = !0;
      }
      _setValue_array_setMatrixWorldNeedsUpdate(t, e) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
        this.targetObject.matrixWorldNeedsUpdate = !0;
      }
      _setValue_arrayElement(t, e) {
        this.resolvedProperty[this.propertyIndex] = t[e];
      }
      _setValue_arrayElement_setNeedsUpdate(t, e) {
        (this.resolvedProperty[this.propertyIndex] = t[e]),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
        (this.resolvedProperty[this.propertyIndex] = t[e]),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _setValue_fromArray(t, e) {
        this.resolvedProperty.fromArray(t, e);
      }
      _setValue_fromArray_setNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e),
          (this.targetObject.needsUpdate = !0);
      }
      _setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
        this.resolvedProperty.fromArray(t, e),
          (this.targetObject.matrixWorldNeedsUpdate = !0);
      }
      _getValue_unbound(t, e) {
        this.bind(), this.getValue(t, e);
      }
      _setValue_unbound(t, e) {
        this.bind(), this.setValue(t, e);
      }
      bind() {
        let t = this.node;
        const e = this.parsedPath,
          n = e.objectName,
          i = e.propertyName;
        let r = e.propertyIndex;
        if (
          (t || ((t = Vv.findNode(this.rootNode, e.nodeName)), (this.node = t)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          !t)
        )
          return void console.warn(
            "THREE.PropertyBinding: No target node found for track: " +
              this.path +
              "."
          );
        if (n) {
          let i = e.objectIndex;
          switch (n) {
            case "materials":
              if (!t.material)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
              if (!t.material.materials)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                  this
                );
              t = t.material.materials;
              break;
            case "bones":
              if (!t.skeleton)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                  this
                );
              t = t.skeleton.bones;
              for (let e = 0; e < t.length; e++)
                if (t[e].name === i) {
                  i = e;
                  break;
                }
              break;
            case "map":
              if ("map" in t) {
                t = t.map;
                break;
              }
              if (!t.material)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                  this
                );
              if (!t.material.map)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                  this
                );
              t = t.material.map;
              break;
            default:
              if (void 0 === t[n])
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                  this
                );
              t = t[n];
          }
          if (void 0 !== i) {
            if (void 0 === t[i])
              return void console.error(
                "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                this,
                t
              );
            t = t[i];
          }
        }
        const s = t[i];
        if (void 0 === s) {
          const n = e.nodeName;
          return void console.error(
            "THREE.PropertyBinding: Trying to update property for track: " +
              n +
              "." +
              i +
              " but it wasn't found.",
            t
          );
        }
        let o = this.Versioning.None;
        (this.targetObject = t),
          void 0 !== t.needsUpdate
            ? (o = this.Versioning.NeedsUpdate)
            : void 0 !== t.matrixWorldNeedsUpdate &&
              (o = this.Versioning.MatrixWorldNeedsUpdate);
        let a = this.BindingType.Direct;
        if (void 0 !== r) {
          if ("morphTargetInfluences" === i) {
            if (!t.geometry)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                this
              );
            if (!t.geometry.morphAttributes)
              return void console.error(
                "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                this
              );
            void 0 !== t.morphTargetDictionary[r] &&
              (r = t.morphTargetDictionary[r]);
          }
          (a = this.BindingType.ArrayElement),
            (this.resolvedProperty = s),
            (this.propertyIndex = r);
        } else
          void 0 !== s.fromArray && void 0 !== s.toArray
            ? ((a = this.BindingType.HasFromToArray),
              (this.resolvedProperty = s))
            : Array.isArray(s)
            ? ((a = this.BindingType.EntireArray), (this.resolvedProperty = s))
            : (this.propertyName = i);
        (this.getValue = this.GetterByBindingType[a]),
          (this.setValue = this.SetterByBindingTypeAndVersioning[a][o]);
      }
      unbind() {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
    }
    (Vv.Composite = class {
      constructor(t, e, n) {
        const i = n || Vv.parseTrackName(e);
        (this._targetGroup = t), (this._bindings = t.subscribe_(e, i));
      }
      getValue(t, e) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
          i = this._bindings[n];
        void 0 !== i && i.getValue(t, e);
      }
      setValue(t, e) {
        const n = this._bindings;
        for (
          let i = this._targetGroup.nCachedObjects_, r = n.length;
          i !== r;
          ++i
        )
          n[i].setValue(t, e);
      }
      bind() {
        const t = this._bindings;
        for (
          let e = this._targetGroup.nCachedObjects_, n = t.length;
          e !== n;
          ++e
        )
          t[e].bind();
      }
      unbind() {
        const t = this._bindings;
        for (
          let e = this._targetGroup.nCachedObjects_, n = t.length;
          e !== n;
          ++e
        )
          t[e].unbind();
      }
    }),
      (Vv.prototype.BindingType = {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      }),
      (Vv.prototype.Versioning = {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2,
      }),
      (Vv.prototype.GetterByBindingType = [
        Vv.prototype._getValue_direct,
        Vv.prototype._getValue_array,
        Vv.prototype._getValue_arrayElement,
        Vv.prototype._getValue_toArray,
      ]),
      (Vv.prototype.SetterByBindingTypeAndVersioning = [
        [
          Vv.prototype._setValue_direct,
          Vv.prototype._setValue_direct_setNeedsUpdate,
          Vv.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
        ],
        [
          Vv.prototype._setValue_array,
          Vv.prototype._setValue_array_setNeedsUpdate,
          Vv.prototype._setValue_array_setMatrixWorldNeedsUpdate,
        ],
        [
          Vv.prototype._setValue_arrayElement,
          Vv.prototype._setValue_arrayElement_setNeedsUpdate,
          Vv.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
        ],
        [
          Vv.prototype._setValue_fromArray,
          Vv.prototype._setValue_fromArray_setNeedsUpdate,
          Vv.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
        ],
      ]);
    new Float32Array(1);
    "undefined" != typeof __THREE_DEVTOOLS__ &&
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent("register", {
          detail: {
            revision: "155",
          },
        })
      ),
      "undefined" != typeof window &&
        (window.__THREE__
          ? console.warn(
              "WARNING: Multiple instances of Three.js being imported."
            )
          : (window.__THREE__ = "155"));
    const Gv = Math.PI / 180,
      Wv = 180 / Math.PI;
    function jv(t) {
      return t * Gv;
    }
    function Xv(t) {
      return t * Wv;
    }
    const qv = {
      name: "CopyShader",
      uniforms: {
        tDiffuse: {
          value: null,
        },
        opacity: {
          value: 1,
        },
      },
      vertexShader:
        "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
      fragmentShader:
        "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}",
    };
    class Yv {
      constructor() {
        (this.isPass = !0),
          (this.enabled = !0),
          (this.needsSwap = !0),
          (this.clear = !1),
          (this.renderToScreen = !1);
      }
      setSize() {}
      render() {
        console.error(
          "THREE.Pass: .render() must be implemented in derived pass."
        );
      }
      dispose() {}
    }
    const Kv = new Kf(-1, 1, 1, -1, 0, 1),
      Zv = new Jp();
    Zv.setAttribute("position", new Gp([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
      Zv.setAttribute("uv", new Gp([0, 2, 0, 0, 2, 0], 2));
    class Jv {
      constructor(t) {
        this._mesh = new gf(Zv, t);
      }
      dispose() {
        this._mesh.geometry.dispose();
      }
      render(t) {
        t.render(this._mesh, Kv);
      }
      get material() {
        return this._mesh.material;
      }
      set material(t) {
        this._mesh.material = t;
      }
    }
    class $v extends Yv {
      constructor(t, e) {
        super(),
          (this.textureID = void 0 !== e ? e : "tDiffuse"),
          t instanceof Ef
            ? ((this.uniforms = t.uniforms), (this.material = t))
            : t &&
              ((this.uniforms = Sf.clone(t.uniforms)),
              (this.material = new Ef({
                name: void 0 !== t.name ? t.name : "unspecified",
                defines: Object.assign({}, t.defines),
                uniforms: this.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader,
              }))),
          (this.fsQuad = new Jv(this.material));
      }
      render(t, e, n) {
        this.uniforms[this.textureID] &&
          (this.uniforms[this.textureID].value = n.texture),
          (this.fsQuad.material = this.material),
          this.renderToScreen
            ? (t.setRenderTarget(null), this.fsQuad.render(t))
            : (t.setRenderTarget(e),
              this.clear &&
                t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
              this.fsQuad.render(t));
      }
      dispose() {
        this.material.dispose(), this.fsQuad.dispose();
      }
    }
    class Qv extends Yv {
      constructor(t, e) {
        super(),
          (this.scene = t),
          (this.camera = e),
          (this.clear = !0),
          (this.needsSwap = !1),
          (this.inverse = !1);
      }
      render(t, e, n) {
        const i = t.getContext(),
          r = t.state;
        let s, o;
        r.buffers.color.setMask(!1),
          r.buffers.depth.setMask(!1),
          r.buffers.color.setLocked(!0),
          r.buffers.depth.setLocked(!0),
          this.inverse ? ((s = 0), (o = 1)) : ((s = 1), (o = 0)),
          r.buffers.stencil.setTest(!0),
          r.buffers.stencil.setOp(i.REPLACE, i.REPLACE, i.REPLACE),
          r.buffers.stencil.setFunc(i.ALWAYS, s, 4294967295),
          r.buffers.stencil.setClear(o),
          r.buffers.stencil.setLocked(!0),
          t.setRenderTarget(n),
          this.clear && t.clear(),
          t.render(this.scene, this.camera),
          t.setRenderTarget(e),
          this.clear && t.clear(),
          t.render(this.scene, this.camera),
          r.buffers.color.setLocked(!1),
          r.buffers.depth.setLocked(!1),
          r.buffers.color.setMask(!0),
          r.buffers.depth.setMask(!0),
          r.buffers.stencil.setLocked(!1),
          r.buffers.stencil.setFunc(i.EQUAL, 1, 4294967295),
          r.buffers.stencil.setOp(i.KEEP, i.KEEP, i.KEEP),
          r.buffers.stencil.setLocked(!0);
      }
    }
    class t_ extends Yv {
      constructor() {
        super(), (this.needsSwap = !1);
      }
      render(t) {
        t.state.buffers.stencil.setLocked(!1),
          t.state.buffers.stencil.setTest(!1);
      }
    }
    class e_ {
      constructor(t, e) {
        if (
          ((this.renderer = t),
          (this._pixelRatio = t.getPixelRatio()),
          void 0 === e)
        ) {
          const n = t.getSize(new Vh());
          (this._width = n.width),
            (this._height = n.height),
            ((e = new hd(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio,
              {
                type: 1016,
              }
            )).texture.name = "EffectComposer.rt1");
        } else (this._width = e.width), (this._height = e.height);
        (this.renderTarget1 = e),
          (this.renderTarget2 = e.clone()),
          (this.renderTarget2.texture.name = "EffectComposer.rt2"),
          (this.writeBuffer = this.renderTarget1),
          (this.readBuffer = this.renderTarget2),
          (this.renderToScreen = !0),
          (this.passes = []),
          (this.copyPass = new $v(qv)),
          (this.copyPass.material.blending = 0),
          (this.clock = new Uv());
      }
      swapBuffers() {
        const t = this.readBuffer;
        (this.readBuffer = this.writeBuffer), (this.writeBuffer = t);
      }
      addPass(t) {
        this.passes.push(t),
          t.setSize(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio
          );
      }
      insertPass(t, e) {
        this.passes.splice(e, 0, t),
          t.setSize(
            this._width * this._pixelRatio,
            this._height * this._pixelRatio
          );
      }
      removePass(t) {
        const e = this.passes.indexOf(t);
        -1 !== e && this.passes.splice(e, 1);
      }
      isLastEnabledPass(t) {
        for (let e = t + 1; e < this.passes.length; e++)
          if (this.passes[e].enabled) return !1;
        return !0;
      }
      render(t) {
        void 0 === t && (t = this.clock.getDelta());
        const e = this.renderer.getRenderTarget();
        let n = !1;
        for (let e = 0, i = this.passes.length; e < i; e++) {
          const i = this.passes[e];
          if (!1 !== i.enabled) {
            if (
              ((i.renderToScreen =
                this.renderToScreen && this.isLastEnabledPass(e)),
              i.render(this.renderer, this.writeBuffer, this.readBuffer, t, n),
              i.needsSwap)
            ) {
              if (n) {
                const e = this.renderer.getContext(),
                  n = this.renderer.state.buffers.stencil;
                n.setFunc(e.NOTEQUAL, 1, 4294967295),
                  this.copyPass.render(
                    this.renderer,
                    this.writeBuffer,
                    this.readBuffer,
                    t
                  ),
                  n.setFunc(e.EQUAL, 1, 4294967295);
              }
              this.swapBuffers();
            }
            void 0 !== Qv &&
              (i instanceof Qv ? (n = !0) : i instanceof t_ && (n = !1));
          }
        }
        this.renderer.setRenderTarget(e);
      }
      reset(t) {
        if (void 0 === t) {
          const e = this.renderer.getSize(new Vh());
          (this._pixelRatio = this.renderer.getPixelRatio()),
            (this._width = e.width),
            (this._height = e.height),
            (t = this.renderTarget1.clone()).setSize(
              this._width * this._pixelRatio,
              this._height * this._pixelRatio
            );
        }
        this.renderTarget1.dispose(),
          this.renderTarget2.dispose(),
          (this.renderTarget1 = t),
          (this.renderTarget2 = t.clone()),
          (this.writeBuffer = this.renderTarget1),
          (this.readBuffer = this.renderTarget2);
      }
      setSize(t, e) {
        (this._width = t), (this._height = e);
        const n = this._width * this._pixelRatio,
          i = this._height * this._pixelRatio;
        this.renderTarget1.setSize(n, i), this.renderTarget2.setSize(n, i);
        for (let t = 0; t < this.passes.length; t++)
          this.passes[t].setSize(n, i);
      }
      setPixelRatio(t) {
        (this._pixelRatio = t), this.setSize(this._width, this._height);
      }
      dispose() {
        this.renderTarget1.dispose(),
          this.renderTarget2.dispose(),
          this.copyPass.dispose();
      }
    }
    class n_ extends Yv {
      constructor(t, e, n, i, r) {
        super(),
          (this.scene = t),
          (this.camera = e),
          (this.overrideMaterial = n),
          (this.clearColor = i),
          (this.clearAlpha = void 0 !== r ? r : 0),
          (this.clear = !0),
          (this.clearDepth = !1),
          (this.needsSwap = !1),
          (this._oldClearColor = new Fp());
      }
      render(t, e, n) {
        const i = t.autoClear;
        let r, s;
        (t.autoClear = !1),
          void 0 !== this.overrideMaterial &&
            ((s = this.scene.overrideMaterial),
            (this.scene.overrideMaterial = this.overrideMaterial)),
          this.clearColor &&
            (t.getClearColor(this._oldClearColor),
            (r = t.getClearAlpha()),
            t.setClearColor(this.clearColor, this.clearAlpha)),
          this.clearDepth && t.clearDepth(),
          t.setRenderTarget(this.renderToScreen ? null : n),
          this.clear &&
            t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
          t.render(this.scene, this.camera),
          this.clearColor && t.setClearColor(this._oldClearColor, r),
          void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = s),
          (t.autoClear = i);
      }
    }
    var i_ = {
        uniforms: {
          tDiffuse: {
            type: "t",
            value: null,
          },
          time: {
            type: "f",
            value: 0,
          },
          distortion: {
            type: "f",
            value: 3,
          },
          distortion2: {
            type: "f",
            value: 5,
          },
          speed: {
            type: "f",
            value: 0.2,
          },
          rollSpeed: {
            type: "f",
            value: 0.1,
          },
        },
        vertexShader: [
          "varying vec2 vUv;",
          "void main() {",
          "vUv = uv;",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "}",
        ].join("\n"),
        fragmentShader: [
          "uniform sampler2D tDiffuse;",
          "uniform float time;",
          "uniform float distortion;",
          "uniform float distortion2;",
          "uniform float speed;",
          "uniform float rollSpeed;",
          "varying vec2 vUv;",
          "vec3 mod289(vec3 x) {",
          "  return x - floor(x * (1.0 / 289.0)) * 289.0;",
          "}",
          "vec2 mod289(vec2 x) {",
          "  return x - floor(x * (1.0 / 289.0)) * 289.0;",
          "}",
          "vec3 permute(vec3 x) {",
          "  return mod289(((x*34.0)+1.0)*x);",
          "}",
          "float snoise(vec2 v)",
          "  {",
          "  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0",
          "                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)",
          "                     -0.577350269189626,  // -1.0 + 2.0 * C.x",
          "                      0.024390243902439); // 1.0 / 41.0",
          "  vec2 i  = floor(v + dot(v, C.yy) );",
          "  vec2 x0 = v -   i + dot(i, C.xx);",
          "  vec2 i1;",
          "  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);",
          "  vec4 x12 = x0.xyxy + C.xxzz;",
          " x12.xy -= i1;",
          "  i = mod289(i); // Avoid truncation effects in permutation",
          "  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))",
          "\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));",
          "  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);",
          "  m = m*m ;",
          "  m = m*m ;",
          "  vec3 x = 2.0 * fract(p * C.www) - 1.0;",
          "  vec3 h = abs(x) - 0.5;",
          "  vec3 ox = floor(x + 0.5);",
          "  vec3 a0 = x - ox;",
          "  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );",
          "  vec3 g;",
          "  g.x  = a0.x  * x0.x  + h.x  * x0.y;",
          "  g.yz = a0.yz * x12.xz + h.yz * x12.yw;",
          "  return 130.0 * dot(m, g);",
          "}",
          "void main() {",
          "vec2 p = vUv;",
          "p -= vec2(0.5);",
          "p *= 1. - (distortion * 0.03);",
          "p += vec2(0.5);",
          "float ty = time*speed;",
          "float yt = p.y - ty;",
          "float offset = snoise(vec2(yt*3.0,0.0))*0.2;",
          "offset = offset * distortion * offset * distortion * offset;",
          "offset += snoise(vec2(yt*50.0,0.0))*distortion2*0.001;",
          "gl_FragColor = texture2D(tDiffuse, vec2(fract(p.x + offset), fract(p.y+ offset)));",
          "}",
        ].join("\n"),
      },
      r_ = {
        uniforms: {
          tDiffuse: {
            type: "t",
            value: null,
          },
          time: {
            type: "f",
            value: 0,
          },
          amount: {
            type: "f",
            value: 0.5,
          },
          size: {
            type: "f",
            value: 4,
          },
        },
        vertexShader: [
          "varying vec2 vUv;",
          "void main() {",
          "vUv = uv;",
          "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
          "}",
        ].join("\n"),
        fragmentShader: [
          "uniform sampler2D tDiffuse;",
          "uniform float time;",
          "uniform float amount;",
          "uniform float size;",
          "varying vec2 vUv;",
          "float rand(vec2 co){",
          "return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);",
          "}",
          "void main() {",
          "vec2 p = vUv;",
          "vec4 color = texture2D(tDiffuse, p);",
          "float xs = floor(gl_FragCoord.x / size);",
          "float ys = floor(gl_FragCoord.y / size);",
          "vec4 snow = vec4(rand(vec2(xs * time,ys * time))*amount);",
          "gl_FragColor = color+ snow;",
          "}",
        ].join("\n"),
      };
    function s_(t, e) {
      return (s_ = Object.setPrototypeOf
        ? Object.setPrototypeOf.bind()
        : function (t, e) {
            return (t.__proto__ = e), t;
          })(t, e);
    }
    var o_ = new a({
      define: [
        {
          namespace: "ajax",
          component: c,
          options: {
            updateSelectors: ["title", "meta", ".cb-menu", "#view-main"],
          },
        },
        {
          namespace: "layout",
          assign: ".cb-layout",
          component: ml,
        },
        {
          namespace: "cursor",
          component: _l,
        },
        {
          namespace: "loader",
          assign: ".cb-loader",
          component: xl,
        },
        {
          namespace: "divider",
          assign: ".cb-divider",
          component: Jl,
        },
        {
          namespace: "button",
          assign: ".cb-btn",
          component: Ql,
        },
        {
          namespace: "checkbox",
          assign: ".cb-checkbox",
          component: kc,
        },
        {
          namespace: "input.light",
          assign: ".cb-input_light",
          component: qc,
        },
        {
          namespace: "input.file",
          assign: ".cb-input_file",
          component: Yc,
        },
        {
          namespace: "modal",
          assign: ".cb-modal",
          component: Zc,
        },
        {
          namespace: "navbar",
          assign: ".cb-navbar",
          component: $c,
        },
        {
          namespace: "menu",
          assign: ".cb-menu",
          component: tu,
        },
        {
          namespace: "intouch",
          assign: ".cb-intouch",
          component: nu,
        },
        {
          namespace: "embedded",
          assign: ".cb-embedded",
          component: ru,
        },
        {
          namespace: "tophead",
          assign: ".cb-tophead",
          component: ou,
        },
        {
          namespace: "contact",
          assign: ".cb-contact",
          component: lu,
        },
        {
          namespace: "work",
          assign: ".cb-work",
          component: uu,
        },
        {
          namespace: "entrylist",
          assign: ".cb-entrylist",
          component: du,
        },
        {
          namespace: "featured",
          assign: ".cb-featured",
          component: fu,
        },
        {
          namespace: "overview",
          assign: ".cb-overview",
          component: mh,
        },
        {
          namespace: "splitshow",
          assign: ".cb-splitshow",
          component: vh,
        },
        {
          namespace: "summary",
          assign: ".cb-summary",
          component: bh,
        },
        {
          namespace: "screenshot",
          assign: ".cb-screenshot",
          component: Eh,
        },
        {
          namespace: "nextcase",
          assign: ".cb-nextcase",
          component: Th,
        },
        {
          namespace: "smfeed",
          assign: ".cb-smfeed",
          component: Dh,
        },
        {
          namespace: "outro",
          assign: ".cb-outro",
          component: Ch,
        },
        {
          namespace: "footer",
          assign: ".cb-footer",
          component: (function (t) {
            var e, n;
            function i() {
              var e;
              return (
                ((e = t.apply(this, arguments) || this).header =
                  e.el.querySelector(".cb-footer-header")),
                (e.bgMedia = e.el.querySelector(".cb-footer-bg-media")),
                (e.bgVideo = e.bgMedia.querySelector("video")),
                (e.action = e.el.querySelector(".cb-footer-action")),
                (e.actionBtn = e.action.querySelector("a")),
                (e.tag = e.el.querySelectorAll(".cb-footer-tag")),
                (e.link = e.el.querySelectorAll(".cb-footer-link")),
                (e.sceneVisible = !1),
                e
              );
            }
            (n = t),
              ((e = i).prototype = Object.create(n.prototype)),
              (e.prototype.constructor = e),
              s_(e, n);
            var r = i.prototype;
            return (
              (r.onInit = function () {
                try {
                  var t = this;
                  return Promise.resolve(t.loadScene()).then(function () {
                    t.magicShow();
                  });
                } catch (t) {
                  return Promise.reject(t);
                }
              }),
              (r.onLeave = function () {
                try {
                  return (
                    No.isTouch ||
                      ((this.sceneVisible = !1),
                      this.bgVideo.pause(),
                      this.renderFn && Yi.ticker.remove(this.renderFn),
                      this.resizeFn &&
                        window.removeEventListener("resize", this.resizeFn)),
                    Promise.resolve()
                  );
                } catch (t) {
                  return Promise.reject(t);
                }
              }),
              (r.loadScene = function () {
                try {
                  var t = this;
                  return (
                    No.isTouch ||
                      ((t.bgVideo.style.display = "none"),
                      t.bgVideo.pause(),
                      No.create({
                        trigger: t.el,
                        onToggle: function (e) {
                          e.progress, e.direction;
                          var n = e.isActive;
                          (t.sceneVisible = n),
                            n ? t.bgVideo.play() : t.bgVideo.pause();
                        },
                      }),
                      (t.sceneTexture = new vv(t.bgVideo)),
                      (t.sceneTexture.minFilter = 1006),
                      (t.sceneTexture.magFilter = 1006),
                      (t.sceneMaterial = new Np({
                        map: t.sceneTexture,
                      })),
                      (t.sceneGeometry = new kf(1600, 900, 1, 1)),
                      (t.scenePlane = new gf(t.sceneGeometry, t.sceneMaterial)),
                      (t.scenePlane.z = 0),
                      (t.sceneFov = 45),
                      (t.sceneCamera = new Tf(
                        t.sceneFov,
                        t.bgMedia.offsetWidth / t.bgMedia.offsetHeight,
                        20,
                        3e3
                      )),
                      (t.sceneCamera.position.z = 1e3),
                      (t.sceneMain = new gv()),
                      t.sceneMain.add(t.scenePlane),
                      (t.sceneRenderer = new mv({
                        antialias: !1,
                        alpha: !1,
                        powerPreference: "high-performance",
                      })),
                      t.sceneRenderer.setSize(
                        t.bgMedia.offsetWidth,
                        t.bgMedia.offsetHeight
                      ),
                      t.bgMedia.appendChild(t.sceneRenderer.domElement),
                      (t.sceneComposer = new e_(t.sceneRenderer)),
                      (t.sceneRenderPass = new n_(t.sceneMain, t.sceneCamera)),
                      (t.sceneBadTVPass = new $v(i_)),
                      (t.sceneStaticPass = new $v(r_)),
                      t.sceneComposer.addPass(t.sceneRenderPass),
                      t.sceneComposer.addPass(t.sceneBadTVPass),
                      t.sceneComposer.addPass(t.sceneStaticPass),
                      (t.sceneBadTVPass.uniforms.distortion.value = 0),
                      (t.sceneBadTVPass.uniforms.distortion2.value = 0),
                      (t.sceneBadTVPass.uniforms.speed.value = 0.22),
                      (t.sceneBadTVPass.uniforms.rollSpeed.value = 0),
                      (t.sceneStaticPass.uniforms.amount.value = 0.03),
                      (t.sceneStaticPass.uniforms.size.value = 3),
                      (t.renderFn = function (e) {
                        t.sceneVisible &&
                          (t.sceneComposer.render(0.1),
                          (t.sceneBadTVPass.uniforms.time.value = e),
                          (t.sceneStaticPass.uniforms.time.value = e));
                      }),
                      Yi.ticker.add(t.renderFn),
                      (t.resizeFn = function () {
                        setTimeout(function () {
                          if (
                            (t.sceneRenderer.setSize(
                              t.bgMedia.offsetWidth,
                              t.bgMedia.offsetHeight
                            ),
                            (t.sceneCamera.aspect =
                              t.bgMedia.offsetWidth / t.bgMedia.offsetHeight),
                            t.sceneCamera.updateProjectionMatrix(),
                            t.sceneCamera.aspect > 16 / 9)
                          ) {
                            var e = Math.tan(jv(t.sceneFov / 2)),
                              n = t.sceneCamera.aspect / (16 / 9);
                            t.sceneCamera.fov = 2 * Xv(Math.atan(e / n));
                          } else t.sceneCamera.fov = t.sceneFov;
                        }, 1e3);
                      }),
                      window.addEventListener("resize", t.resizeFn),
                      t.actionBtn.addEventListener("mouseenter", function () {
                        Yi.to(t.sceneBadTVPass.uniforms.distortion, {
                          value: 5,
                          duration: 0.5,
                        }),
                          Yi.to(t.sceneStaticPass.uniforms.amount, {
                            value: 0.1,
                            duration: 0.5,
                          });
                      }),
                      t.actionBtn.addEventListener("mouseleave", function () {
                        Yi.to(t.sceneBadTVPass.uniforms.distortion, {
                          value: 0,
                          duration: 0.5,
                        }),
                          Yi.to(t.sceneStaticPass.uniforms.amount, {
                            value: 0.03,
                            duration: 0.5,
                          });
                      })),
                    Promise.resolve()
                  );
                } catch (t) {
                  return Promise.reject(t);
                }
              }),
              (r.magicShow = function () {
                this.header &&
                  Tc(this.header.firstElementChild, {
                    type: "lines",
                    stagger: 0.3,
                  }),
                  this.actionBtn && Ic(this.actionBtn),
                  this.tag.length &&
                    this.link.length &&
                    Lc([this.tag, this.link]);
              }),
              i
            );
          })(l),
        },
      ],
    });
    (window.app = o_),
      window.addEventListener("pagehide", function () {
        return window.scrollTo(0, 0);
      });
  },
]);
